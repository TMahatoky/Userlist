{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst graphql = require('graphql');\n\nconst utils = require('@graphql-tools/utils');\n\nconst merge = require('@graphql-tools/merge');\n\nfunction assertResolversPresent(schema) {\n  let resolverValidationOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    requireResolversForArgs,\n    requireResolversForNonScalar,\n    requireResolversForAllFields\n  } = resolverValidationOptions;\n\n  if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {\n    throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' + 'Please configure either requireResolversForAllFields or requireResolversForArgs / ' + 'requireResolversForNonScalar, but not a combination of them.');\n  }\n\n  utils.forEachField(schema, (field, typeName, fieldName) => {\n    // requires a resolver for *every* field.\n    if (requireResolversForAllFields) {\n      expectResolver('requireResolversForAllFields', requireResolversForAllFields, field, typeName, fieldName);\n    } // requires a resolver on every field that has arguments\n\n\n    if (requireResolversForArgs && field.args.length > 0) {\n      expectResolver('requireResolversForArgs', requireResolversForArgs, field, typeName, fieldName);\n    } // requires a resolver on every field that returns a non-scalar type\n\n\n    if (requireResolversForNonScalar !== 'ignore' && !graphql.isScalarType(graphql.getNamedType(field.type))) {\n      expectResolver('requireResolversForNonScalar', requireResolversForNonScalar, field, typeName, fieldName);\n    }\n  });\n}\n\nfunction expectResolver(validator, behavior, field, typeName, fieldName) {\n  if (!field.resolve) {\n    const message = `Resolver missing for \"${typeName}.${fieldName}\".\nTo disable this validator, use:\n  resolverValidationOptions: {\n    ${validator}: 'ignore'\n  }`;\n\n    if (behavior === 'error') {\n      throw new Error(message);\n    }\n\n    if (behavior === 'warn') {\n      console.warn(message);\n    }\n\n    return;\n  }\n\n  if (typeof field.resolve !== 'function') {\n    throw new Error(`Resolver \"${typeName}.${fieldName}\" must be a function`);\n  }\n}\n\nfunction chainResolvers(resolvers) {\n  return (root, args, ctx, info) => resolvers.reduce((prev, curResolver) => {\n    if (curResolver != null) {\n      return curResolver(prev, args, ctx, info);\n    }\n\n    return graphql.defaultFieldResolver(prev, args, ctx, info);\n  }, root);\n} // If we have any union or interface types throw if no there is no resolveType resolver\n\n\nfunction checkForResolveTypeResolver(schema, requireResolversForResolveType) {\n  utils.mapSchema(schema, {\n    [utils.MapperKind.ABSTRACT_TYPE]: type => {\n      if (!type.resolveType) {\n        const message = `Type \"${type.name}\" is missing a \"__resolveType\" resolver. Pass 'ignore' into ` + '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.';\n\n        if (requireResolversForResolveType === 'error') {\n          throw new Error(message);\n        }\n\n        if (requireResolversForResolveType === 'warn') {\n          console.warn(message);\n        }\n      }\n\n      return undefined;\n    }\n  });\n}\n\nfunction extendResolversFromInterfaces(schema, resolvers) {\n  const extendedResolvers = {};\n  const typeMap = schema.getTypeMap();\n\n  for (const typeName in typeMap) {\n    const type = typeMap[typeName];\n\n    if ('getInterfaces' in type) {\n      extendedResolvers[typeName] = {};\n\n      for (const iFace of type.getInterfaces()) {\n        if (resolvers[iFace.name]) {\n          for (const fieldName in resolvers[iFace.name]) {\n            if (fieldName === '__isTypeOf' || !fieldName.startsWith('__')) {\n              extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];\n            }\n          }\n        }\n      }\n\n      const typeResolvers = resolvers[typeName];\n      extendedResolvers[typeName] = { ...extendedResolvers[typeName],\n        ...typeResolvers\n      };\n    } else {\n      const typeResolvers = resolvers[typeName];\n\n      if (typeResolvers != null) {\n        extendedResolvers[typeName] = typeResolvers;\n      }\n    }\n  }\n\n  return extendedResolvers;\n}\n\nfunction addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {\n  const options = graphql.isSchema(schemaOrOptions) ? {\n    schema: schemaOrOptions,\n    resolvers: legacyInputResolvers !== null && legacyInputResolvers !== void 0 ? legacyInputResolvers : {},\n    resolverValidationOptions: legacyInputValidationOptions\n  } : schemaOrOptions;\n  let {\n    schema,\n    resolvers: inputResolvers,\n    defaultFieldResolver,\n    resolverValidationOptions = {},\n    inheritResolversFromInterfaces = false,\n    updateResolversInPlace = false\n  } = options;\n  const {\n    requireResolversToMatchSchema = 'error',\n    requireResolversForResolveType\n  } = resolverValidationOptions;\n  const resolvers = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers;\n\n  for (const typeName in resolvers) {\n    const resolverValue = resolvers[typeName];\n    const resolverType = typeof resolverValue;\n\n    if (resolverType !== 'object') {\n      throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". The resolver's value must be of type object.`);\n    }\n\n    const type = schema.getType(typeName);\n\n    if (type == null) {\n      if (requireResolversToMatchSchema === 'ignore') {\n        continue;\n      }\n\n      throw new Error(`\"${typeName}\" defined in resolvers, but not in schema`);\n    } else if (graphql.isSpecifiedScalarType(type)) {\n      // allow -- without recommending -- overriding of specified scalar types\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        } else {\n          type[fieldName] = resolverValue[fieldName];\n        }\n      }\n    } else if (graphql.isEnumType(type)) {\n      const values = type.getValues();\n\n      for (const fieldName in resolverValue) {\n        if (!fieldName.startsWith('__') && !values.some(value => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);\n        }\n      }\n    } else if (graphql.isUnionType(type)) {\n      for (const fieldName in resolverValue) {\n        if (!fieldName.startsWith('__') && requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);\n        }\n      }\n    } else if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {\n      for (const fieldName in resolverValue) {\n        if (!fieldName.startsWith('__')) {\n          const fields = type.getFields();\n          const field = fields[fieldName];\n\n          if (field == null) {\n            // Field present in resolver but not in schema\n            if (requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n              throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);\n            }\n          } else {\n            // Field present in both the resolver and schema\n            const fieldResolve = resolverValue[fieldName];\n\n            if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {\n              throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);\n\n  if (requireResolversForResolveType && requireResolversForResolveType !== 'ignore') {\n    checkForResolveTypeResolver(schema, requireResolversForResolveType);\n  }\n\n  return schema;\n}\n\nfunction addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n\n  const typeMap = schema.getTypeMap();\n\n  for (const typeName in resolvers) {\n    const type = schema.getType(typeName);\n    const resolverValue = resolvers[typeName];\n\n    if (graphql.isScalarType(type)) {\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        } else if (fieldName === 'astNode' && type.astNode != null) {\n          type.astNode = { ...type.astNode,\n            description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.astNode.description,\n            directives: ((_c = type.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])\n          };\n        } else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {\n          type.extensionASTNodes = type.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);\n        } else if (fieldName === 'extensions' && type.extensions != null && resolverValue.extensions != null) {\n          type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n        } else {\n          type[fieldName] = resolverValue[fieldName];\n        }\n      }\n    } else if (graphql.isEnumType(type)) {\n      const config = type.toConfig();\n      const enumValueConfigMap = config.values;\n\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          config[fieldName.substring(2)] = resolverValue[fieldName];\n        } else if (fieldName === 'astNode' && config.astNode != null) {\n          config.astNode = { ...config.astNode,\n            description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config.astNode.description,\n            directives: ((_j = config.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : [])\n          };\n        } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n          config.extensionASTNodes = config.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);\n        } else if (fieldName === 'extensions' && type.extensions != null && resolverValue.extensions != null) {\n          type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n        } else if (enumValueConfigMap[fieldName]) {\n          enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n        }\n      }\n\n      typeMap[typeName] = new graphql.GraphQLEnumType(config);\n    } else if (graphql.isUnionType(type)) {\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        }\n      }\n    } else if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          // this is for isTypeOf and resolveType and all the other stuff.\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n          continue;\n        }\n\n        const fields = type.getFields();\n        const field = fields[fieldName];\n\n        if (field != null) {\n          const fieldResolve = resolverValue[fieldName];\n\n          if (typeof fieldResolve === 'function') {\n            // for convenience. Allows shorter syntax in resolver definition file\n            field.resolve = fieldResolve.bind(resolverValue);\n          } else {\n            setFieldProperties(field, fieldResolve);\n          }\n        }\n      }\n    }\n  } // serialize all default values prior to healing fields with new scalar/enum types.\n\n\n  utils.forEachDefaultValue(schema, utils.serializeInputValue); // schema may have new scalar/enum types that require healing\n\n  utils.healSchema(schema); // reparse all default values with new parsing functions.\n\n  utils.forEachDefaultValue(schema, utils.parseInputValue);\n\n  if (defaultFieldResolver != null) {\n    utils.forEachField(schema, field => {\n      if (!field.resolve) {\n        field.resolve = defaultFieldResolver;\n      }\n    });\n  }\n\n  return schema;\n}\n\nfunction createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {\n  schema = utils.mapSchema(schema, {\n    [utils.MapperKind.SCALAR_TYPE]: type => {\n      var _a, _b, _c, _d, _e, _f;\n\n      const config = type.toConfig();\n      const resolverValue = resolvers[type.name];\n\n      if (!graphql.isSpecifiedScalarType(type) && resolverValue != null) {\n        for (const fieldName in resolverValue) {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && config.astNode != null) {\n            config.astNode = { ...config.astNode,\n              description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,\n              directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])\n            };\n          } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);\n          } else if (fieldName === 'extensions' && config.extensions != null && resolverValue.extensions != null) {\n            config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n          } else {\n            config[fieldName] = resolverValue[fieldName];\n          }\n        }\n\n        return new graphql.GraphQLScalarType(config);\n      }\n    },\n    [utils.MapperKind.ENUM_TYPE]: type => {\n      var _a, _b, _c, _d, _e, _f;\n\n      const resolverValue = resolvers[type.name];\n      const config = type.toConfig();\n      const enumValueConfigMap = config.values;\n\n      if (resolverValue != null) {\n        for (const fieldName in resolverValue) {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && config.astNode != null) {\n            config.astNode = { ...config.astNode,\n              description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,\n              directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])\n            };\n          } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);\n          } else if (fieldName === 'extensions' && config.extensions != null && resolverValue.extensions != null) {\n            config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n          } else if (enumValueConfigMap[fieldName]) {\n            enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n          }\n        }\n\n        return new graphql.GraphQLEnumType(config);\n      }\n    },\n    [utils.MapperKind.UNION_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n\n      if (resolverValue != null) {\n        const config = type.toConfig();\n\n        if (resolverValue['__resolveType']) {\n          config.resolveType = resolverValue['__resolveType'];\n        }\n\n        return new graphql.GraphQLUnionType(config);\n      }\n    },\n    [utils.MapperKind.OBJECT_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n\n      if (resolverValue != null) {\n        const config = type.toConfig();\n\n        if (resolverValue['__isTypeOf']) {\n          config.isTypeOf = resolverValue['__isTypeOf'];\n        }\n\n        return new graphql.GraphQLObjectType(config);\n      }\n    },\n    [utils.MapperKind.INTERFACE_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n\n      if (resolverValue != null) {\n        const config = type.toConfig();\n\n        if (resolverValue['__resolveType']) {\n          config.resolveType = resolverValue['__resolveType'];\n        }\n\n        return new graphql.GraphQLInterfaceType(config);\n      }\n    },\n    [utils.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n      const resolverValue = resolvers[typeName];\n\n      if (resolverValue != null) {\n        const fieldResolve = resolverValue[fieldName];\n\n        if (fieldResolve != null) {\n          const newFieldConfig = { ...fieldConfig\n          };\n\n          if (typeof fieldResolve === 'function') {\n            // for convenience. Allows shorter syntax in resolver definition file\n            newFieldConfig.resolve = fieldResolve.bind(resolverValue);\n          } else {\n            setFieldProperties(newFieldConfig, fieldResolve);\n          }\n\n          return newFieldConfig;\n        }\n      }\n    }\n  });\n\n  if (defaultFieldResolver != null) {\n    schema = utils.mapSchema(schema, {\n      [utils.MapperKind.OBJECT_FIELD]: fieldConfig => ({ ...fieldConfig,\n        resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver\n      })\n    });\n  }\n\n  return schema;\n}\n\nfunction setFieldProperties(field, propertiesObj) {\n  for (const propertyName in propertiesObj) {\n    field[propertyName] = propertiesObj[propertyName];\n  }\n}\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use `graphql-tag` to not only parse a string into a\n * `DocumentNode` but also to provide additional syntax highlighting in your\n * editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = gql`\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\n\n\nfunction makeExecutableSchema(_ref) {\n  let {\n    typeDefs,\n    resolvers = {},\n    resolverValidationOptions = {},\n    parseOptions = {},\n    inheritResolversFromInterfaces = false,\n    pruningOptions,\n    updateResolversInPlace = false,\n    schemaExtensions\n  } = _ref;\n\n  // Validate and clean up arguments\n  if (typeof resolverValidationOptions !== 'object') {\n    throw new Error('Expected `resolverValidationOptions` to be an object');\n  }\n\n  if (!typeDefs) {\n    throw new Error('Must provide typeDefs');\n  }\n\n  let schema;\n\n  if (graphql.isSchema(typeDefs)) {\n    schema = typeDefs;\n  } else if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.commentDescriptions) {\n    const mergedTypeDefs = merge.mergeTypeDefs(typeDefs, { ...parseOptions,\n      commentDescriptions: true\n    });\n    schema = graphql.buildSchema(mergedTypeDefs, parseOptions);\n  } else {\n    const mergedTypeDefs = merge.mergeTypeDefs(typeDefs, parseOptions);\n    schema = graphql.buildASTSchema(mergedTypeDefs, parseOptions);\n  }\n\n  if (pruningOptions) {\n    schema = utils.pruneSchema(schema);\n  } // We allow passing in an array of resolver maps, in which case we merge them\n\n\n  schema = addResolversToSchema({\n    schema,\n    resolvers: merge.mergeResolvers(resolvers),\n    resolverValidationOptions,\n    inheritResolversFromInterfaces,\n    updateResolversInPlace\n  });\n\n  if (Object.keys(resolverValidationOptions).length > 0) {\n    assertResolversPresent(schema, resolverValidationOptions);\n  }\n\n  if (schemaExtensions) {\n    schemaExtensions = merge.mergeExtensions(utils.asArray(schemaExtensions));\n    merge.applyExtensions(schema, schemaExtensions);\n  }\n\n  return schema;\n}\n/**\n * Synchronously merges multiple schemas, typeDefinitions and/or resolvers into a single schema.\n * @param config Configuration object\n */\n\n\nfunction mergeSchemas(config) {\n  const extractedTypeDefs = utils.asArray(config.typeDefs || []);\n  const extractedResolvers = utils.asArray(config.resolvers || []);\n  const extractedSchemaExtensions = utils.asArray(config.schemaExtensions || []);\n  const schemas = config.schemas || [];\n\n  for (const schema of schemas) {\n    extractedTypeDefs.push(schema);\n    extractedResolvers.push(utils.getResolversFromSchema(schema));\n    extractedSchemaExtensions.push(merge.extractExtensionsFromSchema(schema));\n  }\n\n  return makeExecutableSchema({\n    parseOptions: config,\n    ...config,\n    typeDefs: extractedTypeDefs,\n    resolvers: extractedResolvers,\n    schemaExtensions: extractedSchemaExtensions\n  });\n}\n\nexports.addResolversToSchema = addResolversToSchema;\nexports.assertResolversPresent = assertResolversPresent;\nexports.chainResolvers = chainResolvers;\nexports.checkForResolveTypeResolver = checkForResolveTypeResolver;\nexports.extendResolversFromInterfaces = extendResolversFromInterfaces;\nexports.makeExecutableSchema = makeExecutableSchema;\nexports.mergeSchemas = mergeSchemas;","map":{"version":3,"names":["Object","defineProperty","exports","value","graphql","require","utils","merge","assertResolversPresent","schema","resolverValidationOptions","requireResolversForArgs","requireResolversForNonScalar","requireResolversForAllFields","TypeError","forEachField","field","typeName","fieldName","expectResolver","args","length","isScalarType","getNamedType","type","validator","behavior","resolve","message","Error","console","warn","chainResolvers","resolvers","root","ctx","info","reduce","prev","curResolver","defaultFieldResolver","checkForResolveTypeResolver","requireResolversForResolveType","mapSchema","MapperKind","ABSTRACT_TYPE","resolveType","name","undefined","extendResolversFromInterfaces","extendedResolvers","typeMap","getTypeMap","iFace","getInterfaces","startsWith","typeResolvers","addResolversToSchema","schemaOrOptions","legacyInputResolvers","legacyInputValidationOptions","options","isSchema","inputResolvers","inheritResolversFromInterfaces","updateResolversInPlace","requireResolversToMatchSchema","resolverValue","resolverType","getType","isSpecifiedScalarType","substring","isEnumType","values","getValues","some","isUnionType","isObjectType","isInterfaceType","fields","getFields","fieldResolve","addResolversToExistingSchema","createNewSchemaWithResolvers","_a","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","astNode","description","directives","concat","extensionASTNodes","extensions","assign","create","config","toConfig","enumValueConfigMap","GraphQLEnumType","bind","setFieldProperties","forEachDefaultValue","serializeInputValue","healSchema","parseInputValue","SCALAR_TYPE","GraphQLScalarType","ENUM_TYPE","UNION_TYPE","GraphQLUnionType","OBJECT_TYPE","isTypeOf","GraphQLObjectType","INTERFACE_TYPE","GraphQLInterfaceType","COMPOSITE_FIELD","fieldConfig","newFieldConfig","OBJECT_FIELD","propertiesObj","propertyName","makeExecutableSchema","typeDefs","parseOptions","pruningOptions","schemaExtensions","commentDescriptions","mergedTypeDefs","mergeTypeDefs","buildSchema","buildASTSchema","pruneSchema","mergeResolvers","keys","mergeExtensions","asArray","applyExtensions","mergeSchemas","extractedTypeDefs","extractedResolvers","extractedSchemaExtensions","schemas","push","getResolversFromSchema","extractExtensionsFromSchema"],"sources":["C:/Users/User/node_modules/@graphql-tools/schema/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst graphql = require('graphql');\nconst utils = require('@graphql-tools/utils');\nconst merge = require('@graphql-tools/merge');\n\nfunction assertResolversPresent(schema, resolverValidationOptions = {}) {\n    const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;\n    if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {\n        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +\n            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +\n            'requireResolversForNonScalar, but not a combination of them.');\n    }\n    utils.forEachField(schema, (field, typeName, fieldName) => {\n        // requires a resolver for *every* field.\n        if (requireResolversForAllFields) {\n            expectResolver('requireResolversForAllFields', requireResolversForAllFields, field, typeName, fieldName);\n        }\n        // requires a resolver on every field that has arguments\n        if (requireResolversForArgs && field.args.length > 0) {\n            expectResolver('requireResolversForArgs', requireResolversForArgs, field, typeName, fieldName);\n        }\n        // requires a resolver on every field that returns a non-scalar type\n        if (requireResolversForNonScalar !== 'ignore' && !graphql.isScalarType(graphql.getNamedType(field.type))) {\n            expectResolver('requireResolversForNonScalar', requireResolversForNonScalar, field, typeName, fieldName);\n        }\n    });\n}\nfunction expectResolver(validator, behavior, field, typeName, fieldName) {\n    if (!field.resolve) {\n        const message = `Resolver missing for \"${typeName}.${fieldName}\".\nTo disable this validator, use:\n  resolverValidationOptions: {\n    ${validator}: 'ignore'\n  }`;\n        if (behavior === 'error') {\n            throw new Error(message);\n        }\n        if (behavior === 'warn') {\n            console.warn(message);\n        }\n        return;\n    }\n    if (typeof field.resolve !== 'function') {\n        throw new Error(`Resolver \"${typeName}.${fieldName}\" must be a function`);\n    }\n}\n\nfunction chainResolvers(resolvers) {\n    return (root, args, ctx, info) => resolvers.reduce((prev, curResolver) => {\n        if (curResolver != null) {\n            return curResolver(prev, args, ctx, info);\n        }\n        return graphql.defaultFieldResolver(prev, args, ctx, info);\n    }, root);\n}\n\n// If we have any union or interface types throw if no there is no resolveType resolver\nfunction checkForResolveTypeResolver(schema, requireResolversForResolveType) {\n    utils.mapSchema(schema, {\n        [utils.MapperKind.ABSTRACT_TYPE]: type => {\n            if (!type.resolveType) {\n                const message = `Type \"${type.name}\" is missing a \"__resolveType\" resolver. Pass 'ignore' into ` +\n                    '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.';\n                if (requireResolversForResolveType === 'error') {\n                    throw new Error(message);\n                }\n                if (requireResolversForResolveType === 'warn') {\n                    console.warn(message);\n                }\n            }\n            return undefined;\n        },\n    });\n}\n\nfunction extendResolversFromInterfaces(schema, resolvers) {\n    const extendedResolvers = {};\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = typeMap[typeName];\n        if ('getInterfaces' in type) {\n            extendedResolvers[typeName] = {};\n            for (const iFace of type.getInterfaces()) {\n                if (resolvers[iFace.name]) {\n                    for (const fieldName in resolvers[iFace.name]) {\n                        if (fieldName === '__isTypeOf' || !fieldName.startsWith('__')) {\n                            extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];\n                        }\n                    }\n                }\n            }\n            const typeResolvers = resolvers[typeName];\n            extendedResolvers[typeName] = {\n                ...extendedResolvers[typeName],\n                ...typeResolvers,\n            };\n        }\n        else {\n            const typeResolvers = resolvers[typeName];\n            if (typeResolvers != null) {\n                extendedResolvers[typeName] = typeResolvers;\n            }\n        }\n    }\n    return extendedResolvers;\n}\n\nfunction addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {\n    const options = graphql.isSchema(schemaOrOptions)\n        ? {\n            schema: schemaOrOptions,\n            resolvers: legacyInputResolvers !== null && legacyInputResolvers !== void 0 ? legacyInputResolvers : {},\n            resolverValidationOptions: legacyInputValidationOptions,\n        }\n        : schemaOrOptions;\n    let { schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, } = options;\n    const { requireResolversToMatchSchema = 'error', requireResolversForResolveType } = resolverValidationOptions;\n    const resolvers = inheritResolversFromInterfaces\n        ? extendResolversFromInterfaces(schema, inputResolvers)\n        : inputResolvers;\n    for (const typeName in resolvers) {\n        const resolverValue = resolvers[typeName];\n        const resolverType = typeof resolverValue;\n        if (resolverType !== 'object') {\n            throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". The resolver's value must be of type object.`);\n        }\n        const type = schema.getType(typeName);\n        if (type == null) {\n            if (requireResolversToMatchSchema === 'ignore') {\n                continue;\n            }\n            throw new Error(`\"${typeName}\" defined in resolvers, but not in schema`);\n        }\n        else if (graphql.isSpecifiedScalarType(type)) {\n            // allow -- without recommending -- overriding of specified scalar types\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else {\n                    type[fieldName] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if (graphql.isEnumType(type)) {\n            const values = type.getValues();\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__') &&\n                    !values.some(value => value.name === fieldName) &&\n                    requireResolversToMatchSchema &&\n                    requireResolversToMatchSchema !== 'ignore') {\n                    throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);\n                }\n            }\n        }\n        else if (graphql.isUnionType(type)) {\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__') &&\n                    requireResolversToMatchSchema &&\n                    requireResolversToMatchSchema !== 'ignore') {\n                    throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);\n                }\n            }\n        }\n        else if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__')) {\n                    const fields = type.getFields();\n                    const field = fields[fieldName];\n                    if (field == null) {\n                        // Field present in resolver but not in schema\n                        if (requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n                            throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);\n                        }\n                    }\n                    else {\n                        // Field present in both the resolver and schema\n                        const fieldResolve = resolverValue[fieldName];\n                        if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {\n                            throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    schema = updateResolversInPlace\n        ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver)\n        : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);\n    if (requireResolversForResolveType && requireResolversForResolveType !== 'ignore') {\n        checkForResolveTypeResolver(schema, requireResolversForResolveType);\n    }\n    return schema;\n}\nfunction addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n    const typeMap = schema.getTypeMap();\n    for (const typeName in resolvers) {\n        const type = schema.getType(typeName);\n        const resolverValue = resolvers[typeName];\n        if (graphql.isScalarType(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else if (fieldName === 'astNode' && type.astNode != null) {\n                    type.astNode = {\n                        ...type.astNode,\n                        description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.astNode.description,\n                        directives: ((_c = type.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : []),\n                    };\n                }\n                else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {\n                    type.extensionASTNodes = type.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);\n                }\n                else if (fieldName === 'extensions' &&\n                    type.extensions != null &&\n                    resolverValue.extensions != null) {\n                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                }\n                else {\n                    type[fieldName] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if (graphql.isEnumType(type)) {\n            const config = type.toConfig();\n            const enumValueConfigMap = config.values;\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    config[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else if (fieldName === 'astNode' && config.astNode != null) {\n                    config.astNode = {\n                        ...config.astNode,\n                        description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config.astNode.description,\n                        directives: ((_j = config.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : []),\n                    };\n                }\n                else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                    config.extensionASTNodes = config.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);\n                }\n                else if (fieldName === 'extensions' &&\n                    type.extensions != null &&\n                    resolverValue.extensions != null) {\n                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                }\n                else if (enumValueConfigMap[fieldName]) {\n                    enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                }\n            }\n            typeMap[typeName] = new graphql.GraphQLEnumType(config);\n        }\n        else if (graphql.isUnionType(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    // this is for isTypeOf and resolveType and all the other stuff.\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                    continue;\n                }\n                const fields = type.getFields();\n                const field = fields[fieldName];\n                if (field != null) {\n                    const fieldResolve = resolverValue[fieldName];\n                    if (typeof fieldResolve === 'function') {\n                        // for convenience. Allows shorter syntax in resolver definition file\n                        field.resolve = fieldResolve.bind(resolverValue);\n                    }\n                    else {\n                        setFieldProperties(field, fieldResolve);\n                    }\n                }\n            }\n        }\n    }\n    // serialize all default values prior to healing fields with new scalar/enum types.\n    utils.forEachDefaultValue(schema, utils.serializeInputValue);\n    // schema may have new scalar/enum types that require healing\n    utils.healSchema(schema);\n    // reparse all default values with new parsing functions.\n    utils.forEachDefaultValue(schema, utils.parseInputValue);\n    if (defaultFieldResolver != null) {\n        utils.forEachField(schema, field => {\n            if (!field.resolve) {\n                field.resolve = defaultFieldResolver;\n            }\n        });\n    }\n    return schema;\n}\nfunction createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {\n    schema = utils.mapSchema(schema, {\n        [utils.MapperKind.SCALAR_TYPE]: type => {\n            var _a, _b, _c, _d, _e, _f;\n            const config = type.toConfig();\n            const resolverValue = resolvers[type.name];\n            if (!graphql.isSpecifiedScalarType(type) && resolverValue != null) {\n                for (const fieldName in resolverValue) {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,\n                            directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                    }\n                    else {\n                        config[fieldName] = resolverValue[fieldName];\n                    }\n                }\n                return new graphql.GraphQLScalarType(config);\n            }\n        },\n        [utils.MapperKind.ENUM_TYPE]: type => {\n            var _a, _b, _c, _d, _e, _f;\n            const resolverValue = resolvers[type.name];\n            const config = type.toConfig();\n            const enumValueConfigMap = config.values;\n            if (resolverValue != null) {\n                for (const fieldName in resolverValue) {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,\n                            directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                    }\n                    else if (enumValueConfigMap[fieldName]) {\n                        enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                    }\n                }\n                return new graphql.GraphQLEnumType(config);\n            }\n        },\n        [utils.MapperKind.UNION_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__resolveType']) {\n                    config.resolveType = resolverValue['__resolveType'];\n                }\n                return new graphql.GraphQLUnionType(config);\n            }\n        },\n        [utils.MapperKind.OBJECT_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__isTypeOf']) {\n                    config.isTypeOf = resolverValue['__isTypeOf'];\n                }\n                return new graphql.GraphQLObjectType(config);\n            }\n        },\n        [utils.MapperKind.INTERFACE_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__resolveType']) {\n                    config.resolveType = resolverValue['__resolveType'];\n                }\n                return new graphql.GraphQLInterfaceType(config);\n            }\n        },\n        [utils.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n            const resolverValue = resolvers[typeName];\n            if (resolverValue != null) {\n                const fieldResolve = resolverValue[fieldName];\n                if (fieldResolve != null) {\n                    const newFieldConfig = { ...fieldConfig };\n                    if (typeof fieldResolve === 'function') {\n                        // for convenience. Allows shorter syntax in resolver definition file\n                        newFieldConfig.resolve = fieldResolve.bind(resolverValue);\n                    }\n                    else {\n                        setFieldProperties(newFieldConfig, fieldResolve);\n                    }\n                    return newFieldConfig;\n                }\n            }\n        },\n    });\n    if (defaultFieldResolver != null) {\n        schema = utils.mapSchema(schema, {\n            [utils.MapperKind.OBJECT_FIELD]: fieldConfig => ({\n                ...fieldConfig,\n                resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver,\n            }),\n        });\n    }\n    return schema;\n}\nfunction setFieldProperties(field, propertiesObj) {\n    for (const propertyName in propertiesObj) {\n        field[propertyName] = propertiesObj[propertyName];\n    }\n}\n\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use `graphql-tag` to not only parse a string into a\n * `DocumentNode` but also to provide additional syntax highlighting in your\n * editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = gql`\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\nfunction makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, parseOptions = {}, inheritResolversFromInterfaces = false, pruningOptions, updateResolversInPlace = false, schemaExtensions, }) {\n    // Validate and clean up arguments\n    if (typeof resolverValidationOptions !== 'object') {\n        throw new Error('Expected `resolverValidationOptions` to be an object');\n    }\n    if (!typeDefs) {\n        throw new Error('Must provide typeDefs');\n    }\n    let schema;\n    if (graphql.isSchema(typeDefs)) {\n        schema = typeDefs;\n    }\n    else if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.commentDescriptions) {\n        const mergedTypeDefs = merge.mergeTypeDefs(typeDefs, {\n            ...parseOptions,\n            commentDescriptions: true,\n        });\n        schema = graphql.buildSchema(mergedTypeDefs, parseOptions);\n    }\n    else {\n        const mergedTypeDefs = merge.mergeTypeDefs(typeDefs, parseOptions);\n        schema = graphql.buildASTSchema(mergedTypeDefs, parseOptions);\n    }\n    if (pruningOptions) {\n        schema = utils.pruneSchema(schema);\n    }\n    // We allow passing in an array of resolver maps, in which case we merge them\n    schema = addResolversToSchema({\n        schema,\n        resolvers: merge.mergeResolvers(resolvers),\n        resolverValidationOptions,\n        inheritResolversFromInterfaces,\n        updateResolversInPlace,\n    });\n    if (Object.keys(resolverValidationOptions).length > 0) {\n        assertResolversPresent(schema, resolverValidationOptions);\n    }\n    if (schemaExtensions) {\n        schemaExtensions = merge.mergeExtensions(utils.asArray(schemaExtensions));\n        merge.applyExtensions(schema, schemaExtensions);\n    }\n    return schema;\n}\n\n/**\n * Synchronously merges multiple schemas, typeDefinitions and/or resolvers into a single schema.\n * @param config Configuration object\n */\nfunction mergeSchemas(config) {\n    const extractedTypeDefs = utils.asArray(config.typeDefs || []);\n    const extractedResolvers = utils.asArray(config.resolvers || []);\n    const extractedSchemaExtensions = utils.asArray(config.schemaExtensions || []);\n    const schemas = config.schemas || [];\n    for (const schema of schemas) {\n        extractedTypeDefs.push(schema);\n        extractedResolvers.push(utils.getResolversFromSchema(schema));\n        extractedSchemaExtensions.push(merge.extractExtensionsFromSchema(schema));\n    }\n    return makeExecutableSchema({\n        parseOptions: config,\n        ...config,\n        typeDefs: extractedTypeDefs,\n        resolvers: extractedResolvers,\n        schemaExtensions: extractedSchemaExtensions,\n    });\n}\n\nexports.addResolversToSchema = addResolversToSchema;\nexports.assertResolversPresent = assertResolversPresent;\nexports.chainResolvers = chainResolvers;\nexports.checkForResolveTypeResolver = checkForResolveTypeResolver;\nexports.extendResolversFromInterfaces = extendResolversFromInterfaces;\nexports.makeExecutableSchema = makeExecutableSchema;\nexports.mergeSchemas = mergeSchemas;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}