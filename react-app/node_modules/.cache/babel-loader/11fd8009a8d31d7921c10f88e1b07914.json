{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deny = exports.allow = exports.not = exports.or = exports.race = exports.chain = exports.and = exports.inputRule = exports.rule = void 0;\n\nconst rules_1 = require(\"./rules\");\n/**\n *\n * @param name\n * @param options\n *\n * Wraps a function into a Rule class. This way we can identify rules\n * once we start generating middleware from our ruleTree.\n *\n * 1.\n * const auth = rule()(async (parent, args, ctx, info) => {\n *  return true\n * })\n *\n * 2.\n * const auth = rule('name')(async (parent, args, ctx, info) => {\n *  return true\n * })\n *\n * 3.\n * const auth = rule({\n *  name: 'name',\n *  fragment: 'string',\n *  cache: 'cache',\n * })(async (parent, args, ctx, info) => {\n *  return true\n * })\n *\n */\n\n\nconst rule = (name, options) => func => {\n  if (typeof name === 'object') {\n    options = name;\n    name = Math.random().toString();\n  } else if (typeof name === 'string') {\n    options = options || {};\n  } else {\n    name = Math.random().toString();\n    options = {};\n  }\n\n  return new rules_1.Rule(name, func, {\n    fragment: options.fragment,\n    cache: options.cache\n  });\n};\n\nexports.rule = rule;\n/**\n *\n * Constructs a new InputRule based on the schema.\n *\n * @param schema\n */\n\nconst inputRule = name => (schema, options) => {\n  if (typeof name === 'string') {\n    return new rules_1.InputRule(name, schema, options);\n  } else {\n    return new rules_1.InputRule(Math.random().toString(), schema, options);\n  }\n};\n\nexports.inputRule = inputRule;\n/**\n *\n * @param rules\n *\n * Logical operator and serves as a wrapper for and operation.\n *\n */\n\nconst and = function () {\n  for (var _len = arguments.length, rules = new Array(_len), _key = 0; _key < _len; _key++) {\n    rules[_key] = arguments[_key];\n  }\n\n  return new rules_1.RuleAnd(rules);\n};\n\nexports.and = and;\n/**\n *\n * @param rules\n *\n * Logical operator and serves as a wrapper for and operation.\n *\n */\n\nconst chain = function () {\n  for (var _len2 = arguments.length, rules = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    rules[_key2] = arguments[_key2];\n  }\n\n  return new rules_1.RuleChain(rules);\n};\n\nexports.chain = chain;\n/**\n *\n * @param rules\n *\n * Logical operator and serves as a wrapper for and operation.\n *\n */\n\nconst race = function () {\n  for (var _len3 = arguments.length, rules = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    rules[_key3] = arguments[_key3];\n  }\n\n  return new rules_1.RuleRace(rules);\n};\n\nexports.race = race;\n/**\n *\n * @param rules\n *\n * Logical operator or serves as a wrapper for or operation.\n *\n */\n\nconst or = function () {\n  for (var _len4 = arguments.length, rules = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    rules[_key4] = arguments[_key4];\n  }\n\n  return new rules_1.RuleOr(rules);\n};\n\nexports.or = or;\n/**\n *\n * @param rule\n *\n * Logical operator not serves as a wrapper for not operation.\n *\n */\n\nconst not = (rule, error) => {\n  if (typeof error === 'string') return new rules_1.RuleNot(rule, new Error(error));\n  return new rules_1.RuleNot(rule, error);\n};\n\nexports.not = not;\n/**\n *\n * Allow queries.\n *\n */\n\nexports.allow = new rules_1.RuleTrue();\n/**\n *\n * Deny queries.\n *\n */\n\nexports.deny = new rules_1.RuleFalse();","map":{"version":3,"mappings":";;;;;;;AAOA;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BO,MAAMA,IAAI,GAAG,CAClBC,IADkB,EAElBC,OAFkB,KAGdC,IAAD,IAA8B;EACjC,IAAI,OAAOF,IAAP,KAAgB,QAApB,EAA8B;IAC5BC,OAAO,GAAGD,IAAV;IACAA,IAAI,GAAGG,IAAI,CAACC,MAAL,GAAcC,QAAd,EAAP;EACD,CAHD,MAGO,IAAI,OAAOL,IAAP,KAAgB,QAApB,EAA8B;IACnCC,OAAO,GAAGA,OAAO,IAAI,EAArB;EACD,CAFM,MAEA;IACLD,IAAI,GAAGG,IAAI,CAACC,MAAL,GAAcC,QAAd,EAAP;IACAJ,OAAO,GAAG,EAAV;EACD;;EAED,OAAO,IAAIK,YAAJ,CAASN,IAAT,EAAeE,IAAf,EAAqB;IAC1BK,QAAQ,EAAEN,OAAO,CAACM,QADQ;IAE1BC,KAAK,EAAEP,OAAO,CAACO;EAFW,CAArB,CAAP;AAID,CAlBM;;AAAMC,eAAIV,IAAJ;AAoBb;;;;;;;AAMO,MAAMW,SAAS,GAAOV,IAAJ,IAAsB,CAC7CW,MAD6C,EAE7CV,OAF6C,KAG3C;EACF,IAAI,OAAOD,IAAP,KAAgB,QAApB,EAA8B;IAC5B,OAAO,IAAIM,iBAAJ,CAAcN,IAAd,EAAoBW,MAApB,EAA4BV,OAA5B,CAAP;EACD,CAFD,MAEO;IACL,OAAO,IAAIK,iBAAJ,CAAcH,IAAI,CAACC,MAAL,GAAcC,QAAd,EAAd,EAAwCM,MAAxC,EAAgDV,OAAhD,CAAP;EACD;AACF,CATM;;AAAMQ,oBAASC,SAAT;AAWb;;;;;;;;AAOO,MAAME,GAAG,GAAG,YAAoC;EAAA,kCAAhCC,KAAgC;IAAhCA,KAAgC;EAAA;;EACrD,OAAO,IAAIP,eAAJ,CAAYO,KAAZ,CAAP;AACD,CAFM;;AAAMJ,cAAGG,GAAH;AAIb;;;;;;;;AAOO,MAAME,KAAK,GAAG,YAAsC;EAAA,mCAAlCD,KAAkC;IAAlCA,KAAkC;EAAA;;EACzD,OAAO,IAAIP,iBAAJ,CAAcO,KAAd,CAAP;AACD,CAFM;;AAAMJ,gBAAKK,KAAL;AAIb;;;;;;;;AAOO,MAAMC,IAAI,GAAG,YAAqC;EAAA,mCAAjCF,KAAiC;IAAjCA,KAAiC;EAAA;;EACvD,OAAO,IAAIP,gBAAJ,CAAaO,KAAb,CAAP;AACD,CAFM;;AAAMJ,eAAIM,IAAJ;AAIb;;;;;;;;AAOO,MAAMC,EAAE,GAAG,YAAmC;EAAA,mCAA/BH,KAA+B;IAA/BA,KAA+B;EAAA;;EACnD,OAAO,IAAIP,cAAJ,CAAWO,KAAX,CAAP;AACD,CAFM;;AAAMJ,aAAEO,EAAF;AAIb;;;;;;;;AAOO,MAAMC,GAAG,GAAG,CAAClB,IAAD,EAAmBmB,KAAnB,KAAsD;EACvE,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B,OAAO,IAAIZ,eAAJ,CAAYP,IAAZ,EAAkB,IAAIoB,KAAJ,CAAUD,KAAV,CAAlB,CAAP;EAC/B,OAAO,IAAIZ,eAAJ,CAAYP,IAAZ,EAAkBmB,KAAlB,CAAP;AACD,CAHM;;AAAMT,cAAGQ,GAAH;AAKb;;;;;;AAKaR,gBAAQ,IAAIH,gBAAJ,EAAR;AAEb;;;;;;AAKaG,eAAO,IAAIH,iBAAJ,EAAP","names":["rule","name","options","func","Math","random","toString","rules_1","fragment","cache","exports","inputRule","schema","and","rules","chain","race","or","not","error","Error"],"sources":["../src/constructors.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}