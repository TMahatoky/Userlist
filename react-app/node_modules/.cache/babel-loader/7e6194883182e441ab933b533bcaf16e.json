{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst utils = require('@graphql-tools/utils');\n\nconst graphql = require('graphql');\n/**\n * Deep merges multiple resolver definition objects into a single definition.\n * @param resolversDefinitions Resolver definitions to be merged\n * @param options Additional options\n *\n * ```js\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const clientResolver = require('./clientResolver');\n * const productResolver = require('./productResolver');\n *\n * const resolvers = mergeResolvers([\n *  clientResolver,\n *  productResolver,\n * ]);\n * ```\n *\n * If you don't want to manually create the array of resolver objects, you can\n * also use this function along with loadFiles:\n *\n * ```js\n * const path = require('path');\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const { loadFilesSync } = require('@graphql-tools/load-files');\n *\n * const resolversArray = loadFilesSync(path.join(__dirname, './resolvers'));\n *\n * const resolvers = mergeResolvers(resolversArray)\n * ```\n */\n\n\nfunction mergeResolvers(resolversDefinitions, options) {\n  if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {\n    return {};\n  }\n\n  if (!Array.isArray(resolversDefinitions)) {\n    return resolversDefinitions;\n  }\n\n  if (resolversDefinitions.length === 1) {\n    return resolversDefinitions[0] || {};\n  }\n\n  const resolvers = new Array();\n\n  for (let resolversDefinition of resolversDefinitions) {\n    if (Array.isArray(resolversDefinition)) {\n      resolversDefinition = mergeResolvers(resolversDefinition);\n    }\n\n    if (typeof resolversDefinition === 'object' && resolversDefinition) {\n      resolvers.push(resolversDefinition);\n    }\n  }\n\n  const result = utils.mergeDeep(resolvers, true);\n\n  if (options === null || options === void 0 ? void 0 : options.exclusions) {\n    for (const exclusion of options.exclusions) {\n      const [typeName, fieldName] = exclusion.split('.');\n\n      if (!fieldName || fieldName === '*') {\n        delete result[typeName];\n      } else if (result[typeName]) {\n        delete result[typeName][fieldName];\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction mergeArguments(args1, args2, config) {\n  const result = deduplicateArguments([...args2, ...args1].filter(utils.isSome));\n\n  if (config && config.sort) {\n    result.sort(utils.compareNodes);\n  }\n\n  return result;\n}\n\nfunction deduplicateArguments(args) {\n  return args.reduce((acc, current) => {\n    const dup = acc.find(arg => arg.name.value === current.name.value);\n\n    if (!dup) {\n      return acc.concat([current]);\n    }\n\n    return acc;\n  }, []);\n}\n\nfunction directiveAlreadyExists(directivesArr, otherDirective) {\n  return !!directivesArr.find(directive => directive.name.value === otherDirective.name.value);\n}\n\nfunction nameAlreadyExists(name, namesArr) {\n  return namesArr.some(_ref => {\n    let {\n      value\n    } = _ref;\n    return value === name.value;\n  });\n}\n\nfunction mergeArguments$1(a1, a2) {\n  const result = [...a2];\n\n  for (const argument of a1) {\n    const existingIndex = result.findIndex(a => a.name.value === argument.name.value);\n\n    if (existingIndex > -1) {\n      const existingArg = result[existingIndex];\n\n      if (existingArg.value.kind === 'ListValue') {\n        const source = existingArg.value.values;\n        const target = argument.value.values; // merge values of two lists\n\n        existingArg.value.values = deduplicateLists(source, target, (targetVal, source) => {\n          const value = targetVal.value;\n          return !value || !source.some(sourceVal => sourceVal.value === value);\n        });\n      } else {\n        existingArg.value = argument.value;\n      }\n    } else {\n      result.push(argument);\n    }\n  }\n\n  return result;\n}\n\nfunction deduplicateDirectives(directives) {\n  return directives.map((directive, i, all) => {\n    const firstAt = all.findIndex(d => d.name.value === directive.name.value);\n\n    if (firstAt !== i) {\n      const dup = all[firstAt];\n      directive.arguments = mergeArguments$1(directive.arguments, dup.arguments);\n      return null;\n    }\n\n    return directive;\n  }).filter(utils.isSome);\n}\n\nfunction mergeDirectives() {\n  let d1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let d2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let config = arguments.length > 2 ? arguments[2] : undefined;\n  const reverseOrder = config && config.reverseDirectives;\n  const asNext = reverseOrder ? d1 : d2;\n  const asFirst = reverseOrder ? d2 : d1;\n  const result = deduplicateDirectives([...asNext]);\n\n  for (const directive of asFirst) {\n    if (directiveAlreadyExists(result, directive)) {\n      const existingDirectiveIndex = result.findIndex(d => d.name.value === directive.name.value);\n      const existingDirective = result[existingDirectiveIndex];\n      result[existingDirectiveIndex].arguments = mergeArguments$1(directive.arguments || [], existingDirective.arguments || []);\n    } else {\n      result.push(directive);\n    }\n  }\n\n  return result;\n}\n\nfunction validateInputs(node, existingNode) {\n  const printedNode = graphql.print({ ...node,\n    description: undefined\n  });\n  const printedExistingNode = graphql.print({ ...existingNode,\n    description: undefined\n  }); // eslint-disable-next-line\n\n  const leaveInputs = new RegExp('(directive @w*d*)|( on .*$)', 'g');\n  const sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');\n\n  if (!sameArguments) {\n    throw new Error(`Unable to merge GraphQL directive \"${node.name.value}\". \\nExisting directive:  \\n\\t${printedExistingNode} \\nReceived directive: \\n\\t${printedNode}`);\n  }\n}\n\nfunction mergeDirective(node, existingNode) {\n  if (existingNode) {\n    validateInputs(node, existingNode);\n    return { ...node,\n      locations: [...existingNode.locations, ...node.locations.filter(name => !nameAlreadyExists(name, existingNode.locations))]\n    };\n  }\n\n  return node;\n}\n\nfunction deduplicateLists(source, target, filterFn) {\n  return source.concat(target.filter(val => filterFn(val, source)));\n}\n\nfunction mergeEnumValues(first, second, config) {\n  if (config === null || config === void 0 ? void 0 : config.consistentEnumMerge) {\n    const reversed = [];\n\n    if (first) {\n      reversed.push(...first);\n    }\n\n    first = second;\n    second = reversed;\n  }\n\n  const enumValueMap = new Map();\n\n  if (first) {\n    for (const firstValue of first) {\n      enumValueMap.set(firstValue.name.value, firstValue);\n    }\n  }\n\n  if (second) {\n    for (const secondValue of second) {\n      const enumValue = secondValue.name.value;\n\n      if (enumValueMap.has(enumValue)) {\n        const firstValue = enumValueMap.get(enumValue);\n        firstValue.description = secondValue.description || firstValue.description;\n        firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives);\n      } else {\n        enumValueMap.set(enumValue, secondValue);\n      }\n    }\n  }\n\n  const result = [...enumValueMap.values()];\n\n  if (config && config.sort) {\n    result.sort(utils.compareNodes);\n  }\n\n  return result;\n}\n\nfunction mergeEnum(e1, e2, config) {\n  if (e2) {\n    return {\n      name: e1.name,\n      description: e1['description'] || e2['description'],\n      kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || e1.kind === 'EnumTypeDefinition' || e2.kind === 'EnumTypeDefinition' ? 'EnumTypeDefinition' : 'EnumTypeExtension',\n      loc: e1.loc,\n      directives: mergeDirectives(e1.directives, e2.directives, config),\n      values: mergeEnumValues(e1.values, e2.values, config)\n    };\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...e1,\n    kind: graphql.Kind.ENUM_TYPE_DEFINITION\n  } : e1;\n}\n\nfunction isStringTypes(types) {\n  return typeof types === 'string';\n}\n\nfunction isSourceTypes(types) {\n  return types instanceof graphql.Source;\n}\n\nfunction extractType(type) {\n  let visitedType = type;\n\n  while (visitedType.kind === graphql.Kind.LIST_TYPE || visitedType.kind === 'NonNullType') {\n    visitedType = visitedType.type;\n  }\n\n  return visitedType;\n}\n\nfunction isWrappingTypeNode(type) {\n  return type.kind !== graphql.Kind.NAMED_TYPE;\n}\n\nfunction isListTypeNode(type) {\n  return type.kind === graphql.Kind.LIST_TYPE;\n}\n\nfunction isNonNullTypeNode(type) {\n  return type.kind === graphql.Kind.NON_NULL_TYPE;\n}\n\nfunction printTypeNode(type) {\n  if (isListTypeNode(type)) {\n    return `[${printTypeNode(type.type)}]`;\n  }\n\n  if (isNonNullTypeNode(type)) {\n    return `${printTypeNode(type.type)}!`;\n  }\n\n  return type.name.value;\n}\n\n(function (CompareVal) {\n  CompareVal[CompareVal[\"A_SMALLER_THAN_B\"] = -1] = \"A_SMALLER_THAN_B\";\n  CompareVal[CompareVal[\"A_EQUALS_B\"] = 0] = \"A_EQUALS_B\";\n  CompareVal[CompareVal[\"A_GREATER_THAN_B\"] = 1] = \"A_GREATER_THAN_B\";\n})(exports.CompareVal || (exports.CompareVal = {}));\n\nfunction defaultStringComparator(a, b) {\n  if (a == null && b == null) {\n    return exports.CompareVal.A_EQUALS_B;\n  }\n\n  if (a == null) {\n    return exports.CompareVal.A_SMALLER_THAN_B;\n  }\n\n  if (b == null) {\n    return exports.CompareVal.A_GREATER_THAN_B;\n  }\n\n  if (a < b) return exports.CompareVal.A_SMALLER_THAN_B;\n  if (a > b) return exports.CompareVal.A_GREATER_THAN_B;\n  return exports.CompareVal.A_EQUALS_B;\n}\n\nfunction fieldAlreadyExists(fieldsArr, otherField, config) {\n  const result = fieldsArr.find(field => field.name.value === otherField.name.value);\n\n  if (result && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n    const t1 = extractType(result.type);\n    const t2 = extractType(otherField.type);\n\n    if (t1.name.value !== t2.name.value) {\n      throw new Error(`Field \"${otherField.name.value}\" already defined with a different type. Declared as \"${t1.name.value}\", but you tried to override with \"${t2.name.value}\"`);\n    }\n  }\n\n  return !!result;\n}\n\nfunction mergeFields(type, f1, f2, config) {\n  const result = [];\n\n  if (f2 != null) {\n    result.push(...f2);\n  }\n\n  if (f1 != null) {\n    for (const field of f1) {\n      if (fieldAlreadyExists(result, field, config)) {\n        const existing = result.find(f => f.name.value === field.name.value);\n\n        if (!(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n          if (config === null || config === void 0 ? void 0 : config.throwOnConflict) {\n            preventConflicts(type, existing, field, false);\n          } else {\n            preventConflicts(type, existing, field, true);\n          }\n\n          if (isNonNullTypeNode(field.type) && !isNonNullTypeNode(existing.type)) {\n            existing.type = field.type;\n          }\n        }\n\n        existing.arguments = mergeArguments(field['arguments'] || [], existing.arguments || [], config);\n        existing.directives = mergeDirectives(field.directives, existing.directives, config);\n        existing.description = field.description || existing.description;\n      } else {\n        result.push(field);\n      }\n    }\n  }\n\n  if (config && config.sort) {\n    result.sort(utils.compareNodes);\n  }\n\n  if (config && config.exclusions) {\n    const exclusions = config.exclusions;\n    return result.filter(field => !exclusions.includes(`${type.name.value}.${field.name.value}`));\n  }\n\n  return result;\n}\n\nfunction preventConflicts(type, a, b) {\n  let ignoreNullability = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const aType = printTypeNode(a.type);\n  const bType = printTypeNode(b.type);\n\n  if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {\n    throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);\n  }\n}\n\nfunction safeChangeForFieldType(oldType, newType) {\n  let ignoreNullability = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  // both are named\n  if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {\n    return oldType.toString() === newType.toString();\n  } // new is non-null\n\n\n  if (isNonNullTypeNode(newType)) {\n    const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;\n    return safeChangeForFieldType(ofType, newType.type);\n  } // old is non-null\n\n\n  if (isNonNullTypeNode(oldType)) {\n    return safeChangeForFieldType(newType, oldType, ignoreNullability);\n  } // old is list\n\n\n  if (isListTypeNode(oldType)) {\n    return isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type) || isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType['type']);\n  }\n\n  return false;\n}\n\nfunction mergeInputType(node, existingNode, config) {\n  if (existingNode) {\n    try {\n      return {\n        name: node.name,\n        description: node['description'] || existingNode['description'],\n        kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'InputObjectTypeDefinition' || existingNode.kind === 'InputObjectTypeDefinition' ? 'InputObjectTypeDefinition' : 'InputObjectTypeExtension',\n        loc: node.loc,\n        fields: mergeFields(node, node.fields, existingNode.fields, config),\n        directives: mergeDirectives(node.directives, existingNode.directives, config)\n      };\n    } catch (e) {\n      throw new Error(`Unable to merge GraphQL input type \"${node.name.value}\": ${e.message}`);\n    }\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...node,\n    kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION\n  } : node;\n}\n\nfunction mergeInterface(node, existingNode, config) {\n  if (existingNode) {\n    try {\n      return {\n        name: node.name,\n        description: node['description'] || existingNode['description'],\n        kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'InterfaceTypeDefinition' || existingNode.kind === 'InterfaceTypeDefinition' ? 'InterfaceTypeDefinition' : 'InterfaceTypeExtension',\n        loc: node.loc,\n        fields: mergeFields(node, node.fields, existingNode.fields, config),\n        directives: mergeDirectives(node.directives, existingNode.directives, config),\n        interfaces: node['interfaces'] ? mergeNamedTypeArray(node['interfaces'], existingNode['interfaces'], config) : undefined\n      };\n    } catch (e) {\n      throw new Error(`Unable to merge GraphQL interface \"${node.name.value}\": ${e.message}`);\n    }\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...node,\n    kind: graphql.Kind.INTERFACE_TYPE_DEFINITION\n  } : node;\n}\n\nfunction alreadyExists(arr, other) {\n  return !!arr.find(i => i.name.value === other.name.value);\n}\n\nfunction mergeNamedTypeArray() {\n  let first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let second = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const result = [...second, ...first.filter(d => !alreadyExists(second, d))];\n\n  if (config && config.sort) {\n    result.sort(utils.compareNodes);\n  }\n\n  return result;\n}\n\nfunction mergeType(node, existingNode, config) {\n  if (existingNode) {\n    try {\n      return {\n        name: node.name,\n        description: node['description'] || existingNode['description'],\n        kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'ObjectTypeDefinition' || existingNode.kind === 'ObjectTypeDefinition' ? 'ObjectTypeDefinition' : 'ObjectTypeExtension',\n        loc: node.loc,\n        fields: mergeFields(node, node.fields, existingNode.fields, config),\n        directives: mergeDirectives(node.directives, existingNode.directives, config),\n        interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config)\n      };\n    } catch (e) {\n      throw new Error(`Unable to merge GraphQL type \"${node.name.value}\": ${e.message}`);\n    }\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...node,\n    kind: graphql.Kind.OBJECT_TYPE_DEFINITION\n  } : node;\n}\n\nfunction mergeScalar(node, existingNode, config) {\n  if (existingNode) {\n    return {\n      name: node.name,\n      description: node['description'] || existingNode['description'],\n      kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'ScalarTypeDefinition' || existingNode.kind === 'ScalarTypeDefinition' ? 'ScalarTypeDefinition' : 'ScalarTypeExtension',\n      loc: node.loc,\n      directives: mergeDirectives(node.directives, existingNode.directives, config)\n    };\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...node,\n    kind: graphql.Kind.SCALAR_TYPE_DEFINITION\n  } : node;\n}\n\nfunction mergeUnion(first, second, config) {\n  if (second) {\n    return {\n      name: first.name,\n      description: first['description'] || second['description'],\n      // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n      directives: mergeDirectives(first.directives, second.directives, config),\n      kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || first.kind === 'UnionTypeDefinition' || second.kind === 'UnionTypeDefinition' ? graphql.Kind.UNION_TYPE_DEFINITION : graphql.Kind.UNION_TYPE_EXTENSION,\n      loc: first.loc,\n      types: mergeNamedTypeArray(first.types, second.types, config)\n    };\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...first,\n    kind: graphql.Kind.UNION_TYPE_DEFINITION\n  } : first;\n}\n\nconst DEFAULT_OPERATION_TYPE_NAME_MAP = {\n  query: 'Query',\n  mutation: 'Mutation',\n  subscription: 'Subscription'\n};\n\nfunction mergeOperationTypes() {\n  let opNodeList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let existingOpNodeList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const finalOpNodeList = [];\n\n  for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {\n    const opNode = opNodeList.find(n => n.operation === opNodeType) || existingOpNodeList.find(n => n.operation === opNodeType);\n\n    if (opNode) {\n      finalOpNodeList.push(opNode);\n    }\n  }\n\n  return finalOpNodeList;\n}\n\nfunction mergeSchemaDefs(node, existingNode, config) {\n  if (existingNode) {\n    return {\n      kind: node.kind === graphql.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql.Kind.SCHEMA_DEFINITION ? graphql.Kind.SCHEMA_DEFINITION : graphql.Kind.SCHEMA_EXTENSION,\n      description: node['description'] || existingNode['description'],\n      directives: mergeDirectives(node.directives, existingNode.directives, config),\n      operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)\n    };\n  }\n\n  return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? { ...node,\n    kind: graphql.Kind.SCHEMA_DEFINITION\n  } : node;\n}\n\nconst schemaDefSymbol = 'SCHEMA_DEF_SYMBOL';\n\nfunction isNamedDefinitionNode(definitionNode) {\n  return 'name' in definitionNode;\n}\n\nfunction mergeGraphQLNodes(nodes, config) {\n  var _a, _b, _c;\n\n  const mergedResultMap = {};\n\n  for (const nodeDefinition of nodes) {\n    if (isNamedDefinitionNode(nodeDefinition)) {\n      const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;\n\n      if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n        utils.collectComment(nodeDefinition);\n      }\n\n      if (name == null) {\n        continue;\n      }\n\n      if (((_b = config === null || config === void 0 ? void 0 : config.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + '.*')) || ((_c = config === null || config === void 0 ? void 0 : config.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {\n        delete mergedResultMap[name];\n      } else {\n        switch (nodeDefinition.kind) {\n          case graphql.Kind.OBJECT_TYPE_DEFINITION:\n          case graphql.Kind.OBJECT_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case graphql.Kind.ENUM_TYPE_DEFINITION:\n          case graphql.Kind.ENUM_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case graphql.Kind.UNION_TYPE_DEFINITION:\n          case graphql.Kind.UNION_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case graphql.Kind.SCALAR_TYPE_DEFINITION:\n          case graphql.Kind.SCALAR_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n          case graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case graphql.Kind.INTERFACE_TYPE_DEFINITION:\n          case graphql.Kind.INTERFACE_TYPE_EXTENSION:\n            mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config);\n            break;\n\n          case graphql.Kind.DIRECTIVE_DEFINITION:\n            mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);\n            break;\n        }\n      }\n    } else if (nodeDefinition.kind === graphql.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql.Kind.SCHEMA_EXTENSION) {\n      mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config);\n    }\n  }\n\n  return mergedResultMap;\n}\n\nfunction mergeTypeDefs(typeSource, config) {\n  utils.resetComments();\n  const doc = {\n    kind: graphql.Kind.DOCUMENT,\n    definitions: mergeGraphQLTypes(typeSource, {\n      useSchemaDefinition: true,\n      forceSchemaDefinition: false,\n      throwOnConflict: false,\n      commentDescriptions: false,\n      ...config\n    })\n  };\n  let result;\n\n  if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n    result = utils.printWithComments(doc);\n  } else {\n    result = doc;\n  }\n\n  utils.resetComments();\n  return result;\n}\n\nfunction visitTypeSources(typeSource, options) {\n  let allNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let visitedTypeSources = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Set();\n\n  if (typeSource && !visitedTypeSources.has(typeSource)) {\n    visitedTypeSources.add(typeSource);\n\n    if (typeof typeSource === 'function') {\n      visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);\n    } else if (Array.isArray(typeSource)) {\n      for (const type of typeSource) {\n        visitTypeSources(type, options, allNodes, visitedTypeSources);\n      }\n    } else if (graphql.isSchema(typeSource)) {\n      const documentNode = utils.getDocumentNodeFromSchema(typeSource, options);\n      visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n    } else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {\n      const documentNode = graphql.parse(typeSource, options);\n      visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n    } else if (typeof typeSource === 'object' && graphql.isDefinitionNode(typeSource)) {\n      allNodes.push(typeSource);\n    } else if (utils.isDocumentNode(typeSource)) {\n      visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);\n    } else {\n      throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);\n    }\n  }\n\n  return allNodes;\n}\n\nfunction mergeGraphQLTypes(typeSource, config) {\n  var _a, _b, _c;\n\n  utils.resetComments();\n  const allNodes = visitTypeSources(typeSource, config);\n  const mergedNodes = mergeGraphQLNodes(allNodes, config);\n\n  if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {\n    // XXX: right now we don't handle multiple schema definitions\n    const schemaDef = mergedNodes[schemaDefSymbol] || {\n      kind: graphql.Kind.SCHEMA_DEFINITION,\n      operationTypes: []\n    };\n    const operationTypes = schemaDef.operationTypes;\n\n    for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {\n      const opTypeDefNode = operationTypes.find(operationType => operationType.operation === opTypeDefNodeType);\n\n      if (!opTypeDefNode) {\n        const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];\n        const existingPossibleRootType = mergedNodes[possibleRootTypeName];\n\n        if (existingPossibleRootType != null && existingPossibleRootType.name != null) {\n          operationTypes.push({\n            kind: graphql.Kind.OPERATION_TYPE_DEFINITION,\n            type: {\n              kind: graphql.Kind.NAMED_TYPE,\n              name: existingPossibleRootType.name\n            },\n            operation: opTypeDefNodeType\n          });\n        }\n      }\n    }\n\n    if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {\n      mergedNodes[schemaDefSymbol] = schemaDef;\n    }\n  }\n\n  if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {\n    mergedNodes[schemaDefSymbol] = {\n      kind: graphql.Kind.SCHEMA_DEFINITION,\n      operationTypes: [{\n        kind: graphql.Kind.OPERATION_TYPE_DEFINITION,\n        operation: 'query',\n        type: {\n          kind: graphql.Kind.NAMED_TYPE,\n          name: {\n            kind: graphql.Kind.NAME,\n            value: 'Query'\n          }\n        }\n      }]\n    };\n  }\n\n  const mergedNodeDefinitions = Object.values(mergedNodes);\n\n  if (config === null || config === void 0 ? void 0 : config.sort) {\n    const sortFn = typeof config.sort === 'function' ? config.sort : defaultStringComparator;\n    mergedNodeDefinitions.sort((a, b) => {\n      var _a, _b;\n\n      return sortFn((_a = a.name) === null || _a === void 0 ? void 0 : _a.value, (_b = b.name) === null || _b === void 0 ? void 0 : _b.value);\n    });\n  }\n\n  return mergedNodeDefinitions;\n}\n\nfunction travelSchemaPossibleExtensions(schema, hooks) {\n  hooks.onSchema(schema);\n  const typesMap = schema.getTypeMap();\n\n  for (const [, type] of Object.entries(typesMap)) {\n    const isPredefinedScalar = graphql.isScalarType(type) && graphql.isSpecifiedScalarType(type);\n    const isIntrospection = graphql.isIntrospectionType(type);\n\n    if (isPredefinedScalar || isIntrospection) {\n      continue;\n    }\n\n    if (graphql.isObjectType(type)) {\n      hooks.onObjectType(type);\n      const fields = type.getFields();\n\n      for (const [, field] of Object.entries(fields)) {\n        hooks.onObjectField(type, field);\n        const args = field.args || [];\n\n        for (const arg of args) {\n          hooks.onObjectFieldArg(type, field, arg);\n        }\n      }\n    } else if (graphql.isInterfaceType(type)) {\n      hooks.onInterface(type);\n      const fields = type.getFields();\n\n      for (const [, field] of Object.entries(fields)) {\n        hooks.onInterfaceField(type, field);\n        const args = field.args || [];\n\n        for (const arg of args) {\n          hooks.onInterfaceFieldArg(type, field, arg);\n        }\n      }\n    } else if (graphql.isInputObjectType(type)) {\n      hooks.onInputType(type);\n      const fields = type.getFields();\n\n      for (const [, field] of Object.entries(fields)) {\n        hooks.onInputFieldType(type, field);\n      }\n    } else if (graphql.isUnionType(type)) {\n      hooks.onUnion(type);\n    } else if (graphql.isScalarType(type)) {\n      hooks.onScalar(type);\n    } else if (graphql.isEnumType(type)) {\n      hooks.onEnum(type);\n\n      for (const value of type.getValues()) {\n        hooks.onEnumValue(type, value);\n      }\n    }\n  }\n}\n\nfunction mergeExtensions(extensions) {\n  return utils.mergeDeep(extensions);\n}\n\nfunction applyExtensionObject(obj, extensions) {\n  if (!obj) {\n    return;\n  }\n\n  obj.extensions = utils.mergeDeep([obj.extensions || {}, extensions || {}]);\n}\n\nfunction applyExtensions(schema, extensions) {\n  applyExtensionObject(schema, extensions.schemaExtensions);\n\n  for (const [typeName, data] of Object.entries(extensions.types || {})) {\n    const type = schema.getType(typeName);\n\n    if (type) {\n      applyExtensionObject(type, data.extensions);\n\n      if (data.type === 'object' || data.type === 'interface') {\n        for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n          const field = type.getFields()[fieldName];\n\n          if (field) {\n            applyExtensionObject(field, fieldData.extensions);\n\n            for (const [arg, argData] of Object.entries(fieldData.arguments)) {\n              applyExtensionObject(field.args.find(a => a.name === arg), argData);\n            }\n          }\n        }\n      } else if (data.type === 'input') {\n        for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n          const field = type.getFields()[fieldName];\n          applyExtensionObject(field, fieldData.extensions);\n        }\n      } else if (data.type === 'enum') {\n        for (const [valueName, valueData] of Object.entries(data.values)) {\n          const value = type.getValue(valueName);\n          applyExtensionObject(value, valueData);\n        }\n      }\n    }\n  }\n\n  return schema;\n}\n\nfunction extractExtensionsFromSchema(schema) {\n  const result = {\n    schemaExtensions: {},\n    types: {}\n  };\n  travelSchemaPossibleExtensions(schema, {\n    onSchema: schema => result.schemaExtensions = schema.extensions || {},\n    onObjectType: type => result.types[type.name] = {\n      fields: {},\n      type: 'object',\n      extensions: type.extensions || {}\n    },\n    onObjectField: (type, field) => result.types[type.name].fields[field.name] = {\n      arguments: {},\n      extensions: field.extensions || {}\n    },\n    onObjectFieldArg: (type, field, arg) => result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},\n    onInterface: type => result.types[type.name] = {\n      fields: {},\n      type: 'interface',\n      extensions: type.extensions || {}\n    },\n    onInterfaceField: (type, field) => result.types[type.name].fields[field.name] = {\n      arguments: {},\n      extensions: field.extensions || {}\n    },\n    onInterfaceFieldArg: (type, field, arg) => result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},\n    onEnum: type => result.types[type.name] = {\n      values: {},\n      type: 'enum',\n      extensions: type.extensions || {}\n    },\n    onEnumValue: (type, value) => result.types[type.name].values[value.name] = value.extensions || {},\n    onScalar: type => result.types[type.name] = {\n      type: 'scalar',\n      extensions: type.extensions || {}\n    },\n    onUnion: type => result.types[type.name] = {\n      type: 'union',\n      extensions: type.extensions || {}\n    },\n    onInputType: type => result.types[type.name] = {\n      fields: {},\n      type: 'input',\n      extensions: type.extensions || {}\n    },\n    onInputFieldType: (type, field) => result.types[type.name].fields[field.name] = {\n      extensions: field.extensions || {}\n    }\n  });\n  return result;\n}\n\nexports.applyExtensions = applyExtensions;\nexports.defaultStringComparator = defaultStringComparator;\nexports.extractExtensionsFromSchema = extractExtensionsFromSchema;\nexports.extractType = extractType;\nexports.isListTypeNode = isListTypeNode;\nexports.isNamedDefinitionNode = isNamedDefinitionNode;\nexports.isNonNullTypeNode = isNonNullTypeNode;\nexports.isSourceTypes = isSourceTypes;\nexports.isStringTypes = isStringTypes;\nexports.isWrappingTypeNode = isWrappingTypeNode;\nexports.mergeArguments = mergeArguments;\nexports.mergeDirective = mergeDirective;\nexports.mergeDirectives = mergeDirectives;\nexports.mergeEnum = mergeEnum;\nexports.mergeEnumValues = mergeEnumValues;\nexports.mergeExtensions = mergeExtensions;\nexports.mergeFields = mergeFields;\nexports.mergeGraphQLNodes = mergeGraphQLNodes;\nexports.mergeGraphQLTypes = mergeGraphQLTypes;\nexports.mergeInputType = mergeInputType;\nexports.mergeInterface = mergeInterface;\nexports.mergeNamedTypeArray = mergeNamedTypeArray;\nexports.mergeResolvers = mergeResolvers;\nexports.mergeScalar = mergeScalar;\nexports.mergeType = mergeType;\nexports.mergeTypeDefs = mergeTypeDefs;\nexports.mergeUnion = mergeUnion;\nexports.printTypeNode = printTypeNode;\nexports.schemaDefSymbol = schemaDefSymbol;\nexports.travelSchemaPossibleExtensions = travelSchemaPossibleExtensions;","map":{"version":3,"names":["Object","defineProperty","exports","value","utils","require","graphql","mergeResolvers","resolversDefinitions","options","Array","isArray","length","resolvers","resolversDefinition","push","result","mergeDeep","exclusions","exclusion","typeName","fieldName","split","mergeArguments","args1","args2","config","deduplicateArguments","filter","isSome","sort","compareNodes","args","reduce","acc","current","dup","find","arg","name","concat","directiveAlreadyExists","directivesArr","otherDirective","directive","nameAlreadyExists","namesArr","some","mergeArguments$1","a1","a2","argument","existingIndex","findIndex","a","existingArg","kind","source","values","target","deduplicateLists","targetVal","sourceVal","deduplicateDirectives","directives","map","i","all","firstAt","d","arguments","mergeDirectives","d1","d2","reverseOrder","reverseDirectives","asNext","asFirst","existingDirectiveIndex","existingDirective","validateInputs","node","existingNode","printedNode","print","description","undefined","printedExistingNode","leaveInputs","RegExp","sameArguments","replace","Error","mergeDirective","locations","filterFn","val","mergeEnumValues","first","second","consistentEnumMerge","reversed","enumValueMap","Map","firstValue","set","secondValue","enumValue","has","get","mergeEnum","e1","e2","convertExtensions","loc","Kind","ENUM_TYPE_DEFINITION","isStringTypes","types","isSourceTypes","Source","extractType","type","visitedType","LIST_TYPE","isWrappingTypeNode","NAMED_TYPE","isListTypeNode","isNonNullTypeNode","NON_NULL_TYPE","printTypeNode","CompareVal","defaultStringComparator","b","A_EQUALS_B","A_SMALLER_THAN_B","A_GREATER_THAN_B","fieldAlreadyExists","fieldsArr","otherField","field","ignoreFieldConflicts","t1","t2","mergeFields","f1","f2","existing","f","throwOnConflict","preventConflicts","includes","ignoreNullability","aType","bType","safeChangeForFieldType","oldType","newType","toString","ofType","mergeInputType","fields","e","message","INPUT_OBJECT_TYPE_DEFINITION","mergeInterface","interfaces","mergeNamedTypeArray","INTERFACE_TYPE_DEFINITION","alreadyExists","arr","other","mergeType","OBJECT_TYPE_DEFINITION","mergeScalar","SCALAR_TYPE_DEFINITION","mergeUnion","UNION_TYPE_DEFINITION","UNION_TYPE_EXTENSION","DEFAULT_OPERATION_TYPE_NAME_MAP","query","mutation","subscription","mergeOperationTypes","opNodeList","existingOpNodeList","finalOpNodeList","opNodeType","opNode","n","operation","mergeSchemaDefs","SCHEMA_DEFINITION","SCHEMA_EXTENSION","operationTypes","schemaDefSymbol","isNamedDefinitionNode","definitionNode","mergeGraphQLNodes","nodes","_a","_b","_c","mergedResultMap","nodeDefinition","commentDescriptions","collectComment","OBJECT_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","SCALAR_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","DIRECTIVE_DEFINITION","mergeTypeDefs","typeSource","resetComments","doc","DOCUMENT","definitions","mergeGraphQLTypes","useSchemaDefinition","forceSchemaDefinition","printWithComments","visitTypeSources","allNodes","visitedTypeSources","Set","add","isSchema","documentNode","getDocumentNodeFromSchema","parse","isDefinitionNode","isDocumentNode","mergedNodes","schemaDef","opTypeDefNodeType","opTypeDefNode","operationType","possibleRootTypeName","existingPossibleRootType","OPERATION_TYPE_DEFINITION","NAME","mergedNodeDefinitions","sortFn","travelSchemaPossibleExtensions","schema","hooks","onSchema","typesMap","getTypeMap","entries","isPredefinedScalar","isScalarType","isSpecifiedScalarType","isIntrospection","isIntrospectionType","isObjectType","onObjectType","getFields","onObjectField","onObjectFieldArg","isInterfaceType","onInterface","onInterfaceField","onInterfaceFieldArg","isInputObjectType","onInputType","onInputFieldType","isUnionType","onUnion","onScalar","isEnumType","onEnum","getValues","onEnumValue","mergeExtensions","extensions","applyExtensionObject","obj","applyExtensions","schemaExtensions","data","getType","fieldData","argData","valueName","valueData","getValue","extractExtensionsFromSchema"],"sources":["C:/Users/User/node_modules/@graphql-tools/merge/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst utils = require('@graphql-tools/utils');\nconst graphql = require('graphql');\n\n/**\n * Deep merges multiple resolver definition objects into a single definition.\n * @param resolversDefinitions Resolver definitions to be merged\n * @param options Additional options\n *\n * ```js\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const clientResolver = require('./clientResolver');\n * const productResolver = require('./productResolver');\n *\n * const resolvers = mergeResolvers([\n *  clientResolver,\n *  productResolver,\n * ]);\n * ```\n *\n * If you don't want to manually create the array of resolver objects, you can\n * also use this function along with loadFiles:\n *\n * ```js\n * const path = require('path');\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const { loadFilesSync } = require('@graphql-tools/load-files');\n *\n * const resolversArray = loadFilesSync(path.join(__dirname, './resolvers'));\n *\n * const resolvers = mergeResolvers(resolversArray)\n * ```\n */\nfunction mergeResolvers(resolversDefinitions, options) {\n    if (!resolversDefinitions || (Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0)) {\n        return {};\n    }\n    if (!Array.isArray(resolversDefinitions)) {\n        return resolversDefinitions;\n    }\n    if (resolversDefinitions.length === 1) {\n        return resolversDefinitions[0] || {};\n    }\n    const resolvers = new Array();\n    for (let resolversDefinition of resolversDefinitions) {\n        if (Array.isArray(resolversDefinition)) {\n            resolversDefinition = mergeResolvers(resolversDefinition);\n        }\n        if (typeof resolversDefinition === 'object' && resolversDefinition) {\n            resolvers.push(resolversDefinition);\n        }\n    }\n    const result = utils.mergeDeep(resolvers, true);\n    if (options === null || options === void 0 ? void 0 : options.exclusions) {\n        for (const exclusion of options.exclusions) {\n            const [typeName, fieldName] = exclusion.split('.');\n            if (!fieldName || fieldName === '*') {\n                delete result[typeName];\n            }\n            else if (result[typeName]) {\n                delete result[typeName][fieldName];\n            }\n        }\n    }\n    return result;\n}\n\nfunction mergeArguments(args1, args2, config) {\n    const result = deduplicateArguments([...args2, ...args1].filter(utils.isSome));\n    if (config && config.sort) {\n        result.sort(utils.compareNodes);\n    }\n    return result;\n}\nfunction deduplicateArguments(args) {\n    return args.reduce((acc, current) => {\n        const dup = acc.find(arg => arg.name.value === current.name.value);\n        if (!dup) {\n            return acc.concat([current]);\n        }\n        return acc;\n    }, []);\n}\n\nfunction directiveAlreadyExists(directivesArr, otherDirective) {\n    return !!directivesArr.find(directive => directive.name.value === otherDirective.name.value);\n}\nfunction nameAlreadyExists(name, namesArr) {\n    return namesArr.some(({ value }) => value === name.value);\n}\nfunction mergeArguments$1(a1, a2) {\n    const result = [...a2];\n    for (const argument of a1) {\n        const existingIndex = result.findIndex(a => a.name.value === argument.name.value);\n        if (existingIndex > -1) {\n            const existingArg = result[existingIndex];\n            if (existingArg.value.kind === 'ListValue') {\n                const source = existingArg.value.values;\n                const target = argument.value.values;\n                // merge values of two lists\n                existingArg.value.values = deduplicateLists(source, target, (targetVal, source) => {\n                    const value = targetVal.value;\n                    return !value || !source.some((sourceVal) => sourceVal.value === value);\n                });\n            }\n            else {\n                existingArg.value = argument.value;\n            }\n        }\n        else {\n            result.push(argument);\n        }\n    }\n    return result;\n}\nfunction deduplicateDirectives(directives) {\n    return directives\n        .map((directive, i, all) => {\n        const firstAt = all.findIndex(d => d.name.value === directive.name.value);\n        if (firstAt !== i) {\n            const dup = all[firstAt];\n            directive.arguments = mergeArguments$1(directive.arguments, dup.arguments);\n            return null;\n        }\n        return directive;\n    })\n        .filter(utils.isSome);\n}\nfunction mergeDirectives(d1 = [], d2 = [], config) {\n    const reverseOrder = config && config.reverseDirectives;\n    const asNext = reverseOrder ? d1 : d2;\n    const asFirst = reverseOrder ? d2 : d1;\n    const result = deduplicateDirectives([...asNext]);\n    for (const directive of asFirst) {\n        if (directiveAlreadyExists(result, directive)) {\n            const existingDirectiveIndex = result.findIndex(d => d.name.value === directive.name.value);\n            const existingDirective = result[existingDirectiveIndex];\n            result[existingDirectiveIndex].arguments = mergeArguments$1(directive.arguments || [], existingDirective.arguments || []);\n        }\n        else {\n            result.push(directive);\n        }\n    }\n    return result;\n}\nfunction validateInputs(node, existingNode) {\n    const printedNode = graphql.print({\n        ...node,\n        description: undefined,\n    });\n    const printedExistingNode = graphql.print({\n        ...existingNode,\n        description: undefined,\n    });\n    // eslint-disable-next-line\n    const leaveInputs = new RegExp('(directive @w*d*)|( on .*$)', 'g');\n    const sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');\n    if (!sameArguments) {\n        throw new Error(`Unable to merge GraphQL directive \"${node.name.value}\". \\nExisting directive:  \\n\\t${printedExistingNode} \\nReceived directive: \\n\\t${printedNode}`);\n    }\n}\nfunction mergeDirective(node, existingNode) {\n    if (existingNode) {\n        validateInputs(node, existingNode);\n        return {\n            ...node,\n            locations: [\n                ...existingNode.locations,\n                ...node.locations.filter(name => !nameAlreadyExists(name, existingNode.locations)),\n            ],\n        };\n    }\n    return node;\n}\nfunction deduplicateLists(source, target, filterFn) {\n    return source.concat(target.filter(val => filterFn(val, source)));\n}\n\nfunction mergeEnumValues(first, second, config) {\n    if (config === null || config === void 0 ? void 0 : config.consistentEnumMerge) {\n        const reversed = [];\n        if (first) {\n            reversed.push(...first);\n        }\n        first = second;\n        second = reversed;\n    }\n    const enumValueMap = new Map();\n    if (first) {\n        for (const firstValue of first) {\n            enumValueMap.set(firstValue.name.value, firstValue);\n        }\n    }\n    if (second) {\n        for (const secondValue of second) {\n            const enumValue = secondValue.name.value;\n            if (enumValueMap.has(enumValue)) {\n                const firstValue = enumValueMap.get(enumValue);\n                firstValue.description = secondValue.description || firstValue.description;\n                firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives);\n            }\n            else {\n                enumValueMap.set(enumValue, secondValue);\n            }\n        }\n    }\n    const result = [...enumValueMap.values()];\n    if (config && config.sort) {\n        result.sort(utils.compareNodes);\n    }\n    return result;\n}\n\nfunction mergeEnum(e1, e2, config) {\n    if (e2) {\n        return {\n            name: e1.name,\n            description: e1['description'] || e2['description'],\n            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || e1.kind === 'EnumTypeDefinition' || e2.kind === 'EnumTypeDefinition'\n                ? 'EnumTypeDefinition'\n                : 'EnumTypeExtension',\n            loc: e1.loc,\n            directives: mergeDirectives(e1.directives, e2.directives, config),\n            values: mergeEnumValues(e1.values, e2.values, config),\n        };\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...e1,\n            kind: graphql.Kind.ENUM_TYPE_DEFINITION,\n        }\n        : e1;\n}\n\nfunction isStringTypes(types) {\n    return typeof types === 'string';\n}\nfunction isSourceTypes(types) {\n    return types instanceof graphql.Source;\n}\nfunction extractType(type) {\n    let visitedType = type;\n    while (visitedType.kind === graphql.Kind.LIST_TYPE || visitedType.kind === 'NonNullType') {\n        visitedType = visitedType.type;\n    }\n    return visitedType;\n}\nfunction isWrappingTypeNode(type) {\n    return type.kind !== graphql.Kind.NAMED_TYPE;\n}\nfunction isListTypeNode(type) {\n    return type.kind === graphql.Kind.LIST_TYPE;\n}\nfunction isNonNullTypeNode(type) {\n    return type.kind === graphql.Kind.NON_NULL_TYPE;\n}\nfunction printTypeNode(type) {\n    if (isListTypeNode(type)) {\n        return `[${printTypeNode(type.type)}]`;\n    }\n    if (isNonNullTypeNode(type)) {\n        return `${printTypeNode(type.type)}!`;\n    }\n    return type.name.value;\n}\n(function (CompareVal) {\n    CompareVal[CompareVal[\"A_SMALLER_THAN_B\"] = -1] = \"A_SMALLER_THAN_B\";\n    CompareVal[CompareVal[\"A_EQUALS_B\"] = 0] = \"A_EQUALS_B\";\n    CompareVal[CompareVal[\"A_GREATER_THAN_B\"] = 1] = \"A_GREATER_THAN_B\";\n})(exports.CompareVal || (exports.CompareVal = {}));\nfunction defaultStringComparator(a, b) {\n    if (a == null && b == null) {\n        return exports.CompareVal.A_EQUALS_B;\n    }\n    if (a == null) {\n        return exports.CompareVal.A_SMALLER_THAN_B;\n    }\n    if (b == null) {\n        return exports.CompareVal.A_GREATER_THAN_B;\n    }\n    if (a < b)\n        return exports.CompareVal.A_SMALLER_THAN_B;\n    if (a > b)\n        return exports.CompareVal.A_GREATER_THAN_B;\n    return exports.CompareVal.A_EQUALS_B;\n}\n\nfunction fieldAlreadyExists(fieldsArr, otherField, config) {\n    const result = fieldsArr.find(field => field.name.value === otherField.name.value);\n    if (result && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n        const t1 = extractType(result.type);\n        const t2 = extractType(otherField.type);\n        if (t1.name.value !== t2.name.value) {\n            throw new Error(`Field \"${otherField.name.value}\" already defined with a different type. Declared as \"${t1.name.value}\", but you tried to override with \"${t2.name.value}\"`);\n        }\n    }\n    return !!result;\n}\nfunction mergeFields(type, f1, f2, config) {\n    const result = [];\n    if (f2 != null) {\n        result.push(...f2);\n    }\n    if (f1 != null) {\n        for (const field of f1) {\n            if (fieldAlreadyExists(result, field, config)) {\n                const existing = result.find((f) => f.name.value === field.name.value);\n                if (!(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n                    if (config === null || config === void 0 ? void 0 : config.throwOnConflict) {\n                        preventConflicts(type, existing, field, false);\n                    }\n                    else {\n                        preventConflicts(type, existing, field, true);\n                    }\n                    if (isNonNullTypeNode(field.type) && !isNonNullTypeNode(existing.type)) {\n                        existing.type = field.type;\n                    }\n                }\n                existing.arguments = mergeArguments(field['arguments'] || [], existing.arguments || [], config);\n                existing.directives = mergeDirectives(field.directives, existing.directives, config);\n                existing.description = field.description || existing.description;\n            }\n            else {\n                result.push(field);\n            }\n        }\n    }\n    if (config && config.sort) {\n        result.sort(utils.compareNodes);\n    }\n    if (config && config.exclusions) {\n        const exclusions = config.exclusions;\n        return result.filter(field => !exclusions.includes(`${type.name.value}.${field.name.value}`));\n    }\n    return result;\n}\nfunction preventConflicts(type, a, b, ignoreNullability = false) {\n    const aType = printTypeNode(a.type);\n    const bType = printTypeNode(b.type);\n    if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {\n        throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);\n    }\n}\nfunction safeChangeForFieldType(oldType, newType, ignoreNullability = false) {\n    // both are named\n    if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {\n        return oldType.toString() === newType.toString();\n    }\n    // new is non-null\n    if (isNonNullTypeNode(newType)) {\n        const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;\n        return safeChangeForFieldType(ofType, newType.type);\n    }\n    // old is non-null\n    if (isNonNullTypeNode(oldType)) {\n        return safeChangeForFieldType(newType, oldType, ignoreNullability);\n    }\n    // old is list\n    if (isListTypeNode(oldType)) {\n        return ((isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type)) ||\n            (isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType['type'])));\n    }\n    return false;\n}\n\nfunction mergeInputType(node, existingNode, config) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) ||\n                    node.kind === 'InputObjectTypeDefinition' ||\n                    existingNode.kind === 'InputObjectTypeDefinition'\n                    ? 'InputObjectTypeDefinition'\n                    : 'InputObjectTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL input type \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...node,\n            kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        }\n        : node;\n}\n\nfunction mergeInterface(node, existingNode, config) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) ||\n                    node.kind === 'InterfaceTypeDefinition' ||\n                    existingNode.kind === 'InterfaceTypeDefinition'\n                    ? 'InterfaceTypeDefinition'\n                    : 'InterfaceTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config),\n                interfaces: node['interfaces']\n                    ? mergeNamedTypeArray(node['interfaces'], existingNode['interfaces'], config)\n                    : undefined,\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL interface \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...node,\n            kind: graphql.Kind.INTERFACE_TYPE_DEFINITION,\n        }\n        : node;\n}\n\nfunction alreadyExists(arr, other) {\n    return !!arr.find(i => i.name.value === other.name.value);\n}\nfunction mergeNamedTypeArray(first = [], second = [], config = {}) {\n    const result = [...second, ...first.filter(d => !alreadyExists(second, d))];\n    if (config && config.sort) {\n        result.sort(utils.compareNodes);\n    }\n    return result;\n}\n\nfunction mergeType(node, existingNode, config) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) ||\n                    node.kind === 'ObjectTypeDefinition' ||\n                    existingNode.kind === 'ObjectTypeDefinition'\n                    ? 'ObjectTypeDefinition'\n                    : 'ObjectTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config),\n                interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL type \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...node,\n            kind: graphql.Kind.OBJECT_TYPE_DEFINITION,\n        }\n        : node;\n}\n\nfunction mergeScalar(node, existingNode, config) {\n    if (existingNode) {\n        return {\n            name: node.name,\n            description: node['description'] || existingNode['description'],\n            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) ||\n                node.kind === 'ScalarTypeDefinition' ||\n                existingNode.kind === 'ScalarTypeDefinition'\n                ? 'ScalarTypeDefinition'\n                : 'ScalarTypeExtension',\n            loc: node.loc,\n            directives: mergeDirectives(node.directives, existingNode.directives, config),\n        };\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...node,\n            kind: graphql.Kind.SCALAR_TYPE_DEFINITION,\n        }\n        : node;\n}\n\nfunction mergeUnion(first, second, config) {\n    if (second) {\n        return {\n            name: first.name,\n            description: first['description'] || second['description'],\n            // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n            directives: mergeDirectives(first.directives, second.directives, config),\n            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || first.kind === 'UnionTypeDefinition' || second.kind === 'UnionTypeDefinition'\n                ? graphql.Kind.UNION_TYPE_DEFINITION\n                : graphql.Kind.UNION_TYPE_EXTENSION,\n            loc: first.loc,\n            types: mergeNamedTypeArray(first.types, second.types, config),\n        };\n    }\n    return (config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...first,\n            kind: graphql.Kind.UNION_TYPE_DEFINITION,\n        }\n        : first;\n}\n\nconst DEFAULT_OPERATION_TYPE_NAME_MAP = {\n    query: 'Query',\n    mutation: 'Mutation',\n    subscription: 'Subscription',\n};\nfunction mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {\n    const finalOpNodeList = [];\n    for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {\n        const opNode = opNodeList.find(n => n.operation === opNodeType) || existingOpNodeList.find(n => n.operation === opNodeType);\n        if (opNode) {\n            finalOpNodeList.push(opNode);\n        }\n    }\n    return finalOpNodeList;\n}\nfunction mergeSchemaDefs(node, existingNode, config) {\n    if (existingNode) {\n        return {\n            kind: node.kind === graphql.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql.Kind.SCHEMA_DEFINITION\n                ? graphql.Kind.SCHEMA_DEFINITION\n                : graphql.Kind.SCHEMA_EXTENSION,\n            description: node['description'] || existingNode['description'],\n            directives: mergeDirectives(node.directives, existingNode.directives, config),\n            operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes),\n        };\n    }\n    return ((config === null || config === void 0 ? void 0 : config.convertExtensions)\n        ? {\n            ...node,\n            kind: graphql.Kind.SCHEMA_DEFINITION,\n        }\n        : node);\n}\n\nconst schemaDefSymbol = 'SCHEMA_DEF_SYMBOL';\nfunction isNamedDefinitionNode(definitionNode) {\n    return 'name' in definitionNode;\n}\nfunction mergeGraphQLNodes(nodes, config) {\n    var _a, _b, _c;\n    const mergedResultMap = {};\n    for (const nodeDefinition of nodes) {\n        if (isNamedDefinitionNode(nodeDefinition)) {\n            const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;\n            if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n                utils.collectComment(nodeDefinition);\n            }\n            if (name == null) {\n                continue;\n            }\n            if (((_b = config === null || config === void 0 ? void 0 : config.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + '.*')) || ((_c = config === null || config === void 0 ? void 0 : config.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {\n                delete mergedResultMap[name];\n            }\n            else {\n                switch (nodeDefinition.kind) {\n                    case graphql.Kind.OBJECT_TYPE_DEFINITION:\n                    case graphql.Kind.OBJECT_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case graphql.Kind.ENUM_TYPE_DEFINITION:\n                    case graphql.Kind.ENUM_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case graphql.Kind.UNION_TYPE_DEFINITION:\n                    case graphql.Kind.UNION_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case graphql.Kind.SCALAR_TYPE_DEFINITION:\n                    case graphql.Kind.SCALAR_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n                    case graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case graphql.Kind.INTERFACE_TYPE_DEFINITION:\n                    case graphql.Kind.INTERFACE_TYPE_EXTENSION:\n                        mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config);\n                        break;\n                    case graphql.Kind.DIRECTIVE_DEFINITION:\n                        mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);\n                        break;\n                }\n            }\n        }\n        else if (nodeDefinition.kind === graphql.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql.Kind.SCHEMA_EXTENSION) {\n            mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config);\n        }\n    }\n    return mergedResultMap;\n}\n\nfunction mergeTypeDefs(typeSource, config) {\n    utils.resetComments();\n    const doc = {\n        kind: graphql.Kind.DOCUMENT,\n        definitions: mergeGraphQLTypes(typeSource, {\n            useSchemaDefinition: true,\n            forceSchemaDefinition: false,\n            throwOnConflict: false,\n            commentDescriptions: false,\n            ...config,\n        }),\n    };\n    let result;\n    if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n        result = utils.printWithComments(doc);\n    }\n    else {\n        result = doc;\n    }\n    utils.resetComments();\n    return result;\n}\nfunction visitTypeSources(typeSource, options, allNodes = [], visitedTypeSources = new Set()) {\n    if (typeSource && !visitedTypeSources.has(typeSource)) {\n        visitedTypeSources.add(typeSource);\n        if (typeof typeSource === 'function') {\n            visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);\n        }\n        else if (Array.isArray(typeSource)) {\n            for (const type of typeSource) {\n                visitTypeSources(type, options, allNodes, visitedTypeSources);\n            }\n        }\n        else if (graphql.isSchema(typeSource)) {\n            const documentNode = utils.getDocumentNodeFromSchema(typeSource, options);\n            visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n        }\n        else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {\n            const documentNode = graphql.parse(typeSource, options);\n            visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n        }\n        else if (typeof typeSource === 'object' && graphql.isDefinitionNode(typeSource)) {\n            allNodes.push(typeSource);\n        }\n        else if (utils.isDocumentNode(typeSource)) {\n            visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);\n        }\n        else {\n            throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);\n        }\n    }\n    return allNodes;\n}\nfunction mergeGraphQLTypes(typeSource, config) {\n    var _a, _b, _c;\n    utils.resetComments();\n    const allNodes = visitTypeSources(typeSource, config);\n    const mergedNodes = mergeGraphQLNodes(allNodes, config);\n    if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {\n        // XXX: right now we don't handle multiple schema definitions\n        const schemaDef = mergedNodes[schemaDefSymbol] || {\n            kind: graphql.Kind.SCHEMA_DEFINITION,\n            operationTypes: [],\n        };\n        const operationTypes = schemaDef.operationTypes;\n        for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {\n            const opTypeDefNode = operationTypes.find(operationType => operationType.operation === opTypeDefNodeType);\n            if (!opTypeDefNode) {\n                const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];\n                const existingPossibleRootType = mergedNodes[possibleRootTypeName];\n                if (existingPossibleRootType != null && existingPossibleRootType.name != null) {\n                    operationTypes.push({\n                        kind: graphql.Kind.OPERATION_TYPE_DEFINITION,\n                        type: {\n                            kind: graphql.Kind.NAMED_TYPE,\n                            name: existingPossibleRootType.name,\n                        },\n                        operation: opTypeDefNodeType,\n                    });\n                }\n            }\n        }\n        if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {\n            mergedNodes[schemaDefSymbol] = schemaDef;\n        }\n    }\n    if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {\n        mergedNodes[schemaDefSymbol] = {\n            kind: graphql.Kind.SCHEMA_DEFINITION,\n            operationTypes: [\n                {\n                    kind: graphql.Kind.OPERATION_TYPE_DEFINITION,\n                    operation: 'query',\n                    type: {\n                        kind: graphql.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql.Kind.NAME,\n                            value: 'Query',\n                        },\n                    },\n                },\n            ],\n        };\n    }\n    const mergedNodeDefinitions = Object.values(mergedNodes);\n    if (config === null || config === void 0 ? void 0 : config.sort) {\n        const sortFn = typeof config.sort === 'function' ? config.sort : defaultStringComparator;\n        mergedNodeDefinitions.sort((a, b) => { var _a, _b; return sortFn((_a = a.name) === null || _a === void 0 ? void 0 : _a.value, (_b = b.name) === null || _b === void 0 ? void 0 : _b.value); });\n    }\n    return mergedNodeDefinitions;\n}\n\nfunction travelSchemaPossibleExtensions(schema, hooks) {\n    hooks.onSchema(schema);\n    const typesMap = schema.getTypeMap();\n    for (const [, type] of Object.entries(typesMap)) {\n        const isPredefinedScalar = graphql.isScalarType(type) && graphql.isSpecifiedScalarType(type);\n        const isIntrospection = graphql.isIntrospectionType(type);\n        if (isPredefinedScalar || isIntrospection) {\n            continue;\n        }\n        if (graphql.isObjectType(type)) {\n            hooks.onObjectType(type);\n            const fields = type.getFields();\n            for (const [, field] of Object.entries(fields)) {\n                hooks.onObjectField(type, field);\n                const args = field.args || [];\n                for (const arg of args) {\n                    hooks.onObjectFieldArg(type, field, arg);\n                }\n            }\n        }\n        else if (graphql.isInterfaceType(type)) {\n            hooks.onInterface(type);\n            const fields = type.getFields();\n            for (const [, field] of Object.entries(fields)) {\n                hooks.onInterfaceField(type, field);\n                const args = field.args || [];\n                for (const arg of args) {\n                    hooks.onInterfaceFieldArg(type, field, arg);\n                }\n            }\n        }\n        else if (graphql.isInputObjectType(type)) {\n            hooks.onInputType(type);\n            const fields = type.getFields();\n            for (const [, field] of Object.entries(fields)) {\n                hooks.onInputFieldType(type, field);\n            }\n        }\n        else if (graphql.isUnionType(type)) {\n            hooks.onUnion(type);\n        }\n        else if (graphql.isScalarType(type)) {\n            hooks.onScalar(type);\n        }\n        else if (graphql.isEnumType(type)) {\n            hooks.onEnum(type);\n            for (const value of type.getValues()) {\n                hooks.onEnumValue(type, value);\n            }\n        }\n    }\n}\nfunction mergeExtensions(extensions) {\n    return utils.mergeDeep(extensions);\n}\nfunction applyExtensionObject(obj, extensions) {\n    if (!obj) {\n        return;\n    }\n    obj.extensions = utils.mergeDeep([obj.extensions || {}, extensions || {}]);\n}\nfunction applyExtensions(schema, extensions) {\n    applyExtensionObject(schema, extensions.schemaExtensions);\n    for (const [typeName, data] of Object.entries(extensions.types || {})) {\n        const type = schema.getType(typeName);\n        if (type) {\n            applyExtensionObject(type, data.extensions);\n            if (data.type === 'object' || data.type === 'interface') {\n                for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n                    const field = type.getFields()[fieldName];\n                    if (field) {\n                        applyExtensionObject(field, fieldData.extensions);\n                        for (const [arg, argData] of Object.entries(fieldData.arguments)) {\n                            applyExtensionObject(field.args.find(a => a.name === arg), argData);\n                        }\n                    }\n                }\n            }\n            else if (data.type === 'input') {\n                for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n                    const field = type.getFields()[fieldName];\n                    applyExtensionObject(field, fieldData.extensions);\n                }\n            }\n            else if (data.type === 'enum') {\n                for (const [valueName, valueData] of Object.entries(data.values)) {\n                    const value = type.getValue(valueName);\n                    applyExtensionObject(value, valueData);\n                }\n            }\n        }\n    }\n    return schema;\n}\nfunction extractExtensionsFromSchema(schema) {\n    const result = {\n        schemaExtensions: {},\n        types: {},\n    };\n    travelSchemaPossibleExtensions(schema, {\n        onSchema: schema => (result.schemaExtensions = schema.extensions || {}),\n        onObjectType: type => (result.types[type.name] = { fields: {}, type: 'object', extensions: type.extensions || {} }),\n        onObjectField: (type, field) => (result.types[type.name].fields[field.name] = {\n            arguments: {},\n            extensions: field.extensions || {},\n        }),\n        onObjectFieldArg: (type, field, arg) => (result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {}),\n        onInterface: type => (result.types[type.name] = { fields: {}, type: 'interface', extensions: type.extensions || {} }),\n        onInterfaceField: (type, field) => (result.types[type.name].fields[field.name] = {\n            arguments: {},\n            extensions: field.extensions || {},\n        }),\n        onInterfaceFieldArg: (type, field, arg) => (result.types[type.name].fields[field.name].arguments[arg.name] =\n            arg.extensions || {}),\n        onEnum: type => (result.types[type.name] = { values: {}, type: 'enum', extensions: type.extensions || {} }),\n        onEnumValue: (type, value) => (result.types[type.name].values[value.name] = value.extensions || {}),\n        onScalar: type => (result.types[type.name] = { type: 'scalar', extensions: type.extensions || {} }),\n        onUnion: type => (result.types[type.name] = { type: 'union', extensions: type.extensions || {} }),\n        onInputType: type => (result.types[type.name] = { fields: {}, type: 'input', extensions: type.extensions || {} }),\n        onInputFieldType: (type, field) => (result.types[type.name].fields[field.name] = { extensions: field.extensions || {} }),\n    });\n    return result;\n}\n\nexports.applyExtensions = applyExtensions;\nexports.defaultStringComparator = defaultStringComparator;\nexports.extractExtensionsFromSchema = extractExtensionsFromSchema;\nexports.extractType = extractType;\nexports.isListTypeNode = isListTypeNode;\nexports.isNamedDefinitionNode = isNamedDefinitionNode;\nexports.isNonNullTypeNode = isNonNullTypeNode;\nexports.isSourceTypes = isSourceTypes;\nexports.isStringTypes = isStringTypes;\nexports.isWrappingTypeNode = isWrappingTypeNode;\nexports.mergeArguments = mergeArguments;\nexports.mergeDirective = mergeDirective;\nexports.mergeDirectives = mergeDirectives;\nexports.mergeEnum = mergeEnum;\nexports.mergeEnumValues = mergeEnumValues;\nexports.mergeExtensions = mergeExtensions;\nexports.mergeFields = mergeFields;\nexports.mergeGraphQLNodes = mergeGraphQLNodes;\nexports.mergeGraphQLTypes = mergeGraphQLTypes;\nexports.mergeInputType = mergeInputType;\nexports.mergeInterface = mergeInterface;\nexports.mergeNamedTypeArray = mergeNamedTypeArray;\nexports.mergeResolvers = mergeResolvers;\nexports.mergeScalar = mergeScalar;\nexports.mergeType = mergeType;\nexports.mergeTypeDefs = mergeTypeDefs;\nexports.mergeUnion = mergeUnion;\nexports.printTypeNode = printTypeNode;\nexports.schemaDefSymbol = schemaDefSymbol;\nexports.travelSchemaPossibleExtensions = travelSchemaPossibleExtensions;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}