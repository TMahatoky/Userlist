{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RuleFalse = exports.RuleTrue = exports.RuleNot = exports.RuleRace = exports.RuleChain = exports.RuleAnd = exports.RuleOr = exports.LogicRule = exports.InputRule = exports.Rule = void 0;\n\nconst Yup = require(\"yup\");\n\nconst utils_1 = require(\"./utils\");\n\nconst util_1 = require(\"util\");\n\nclass Rule {\n  constructor(name, func, constructorOptions) {\n    const options = this.normalizeOptions(constructorOptions);\n    this.name = name;\n    this.func = func;\n    this.cache = options.cache;\n    this.fragment = options.fragment;\n  }\n  /**\n   *\n   * @param parent\n   * @param args\n   * @param ctx\n   * @param info\n   *\n   * Resolves rule and writes to cache its result.\n   *\n   */\n\n\n  async resolve(parent, args, ctx, info, options) {\n    try {\n      /* Resolve */\n      const res = await this.executeRule(parent, args, ctx, info, options);\n\n      if (res instanceof Error) {\n        return res;\n      } else if (typeof res === 'string') {\n        return new Error(res);\n      } else if (res === true) {\n        return true;\n      } else {\n        return false;\n      }\n    } catch (err) {\n      if (options.debug) {\n        throw err;\n      } else {\n        return false;\n      }\n    }\n  }\n  /**\n   *\n   * @param rule\n   *\n   * Compares a given rule with the current one\n   * and checks whether their functions are equal.\n   *\n   */\n\n\n  equals(rule) {\n    return this.func === rule.func;\n  }\n  /**\n   *\n   * Extracts fragment from the rule.\n   *\n   */\n\n\n  extractFragment() {\n    return this.fragment;\n  }\n  /**\n   *\n   * @param options\n   *\n   * Sets default values for options.\n   *\n   */\n\n\n  normalizeOptions(options) {\n    return {\n      cache: options.cache !== undefined ? this.normalizeCacheOption(options.cache) : 'no_cache',\n      fragment: options.fragment !== undefined ? options.fragment : undefined\n    };\n  }\n  /**\n   *\n   * @param cache\n   *\n   * This ensures backward capability of shield.\n   *\n   */\n\n\n  normalizeCacheOption(cache) {\n    switch (cache) {\n      case true:\n        {\n          return 'strict';\n        }\n\n      case false:\n        {\n          return 'no_cache';\n        }\n\n      default:\n        {\n          return cache;\n        }\n    }\n  }\n  /**\n   * Executes a rule and writes to cache if needed.\n   *\n   * @param parent\n   * @param args\n   * @param ctx\n   * @param info\n   */\n\n\n  executeRule(parent, args, ctx, info, options) {\n    switch (typeof this.cache) {\n      case 'function':\n        {\n          /* User defined cache function. */\n          const key = `${this.name}-${this.cache(parent, args, ctx, info)}`;\n          return this.writeToCache(key)(parent, args, ctx, info);\n        }\n\n      case 'string':\n        {\n          /* Standard cache option. */\n          switch (this.cache) {\n            case 'strict':\n              {\n                const key = options.hashFunction({\n                  parent,\n                  args\n                });\n                return this.writeToCache(`${this.name}-${key}`)(parent, args, ctx, info);\n              }\n\n            case 'contextual':\n              {\n                return this.writeToCache(this.name)(parent, args, ctx, info);\n              }\n\n            case 'no_cache':\n              {\n                return this.func(parent, args, ctx, info);\n              }\n          }\n        }\n\n      /* istanbul ignore next */\n\n      default:\n        {\n          throw new Error(`Unsupported cache format: ${typeof this.cache}`);\n        }\n    }\n  }\n  /**\n   * Writes or reads result from cache.\n   *\n   * @param key\n   */\n\n\n  writeToCache(key) {\n    return (parent, args, ctx, info) => {\n      if (!ctx._shield.cache[key]) {\n        ctx._shield.cache[key] = this.func(parent, args, ctx, info);\n      }\n\n      return ctx._shield.cache[key];\n    };\n  }\n\n}\n\nexports.Rule = Rule;\n\nclass InputRule extends Rule {\n  constructor(name, schema, options) {\n    const validationFunction = (parent, args, ctx) => schema(Yup, ctx).validate(args, options).then(() => true).catch(err => err);\n\n    super(name, validationFunction, {\n      cache: 'strict',\n      fragment: undefined\n    });\n  }\n\n}\n\nexports.InputRule = InputRule;\n\nclass LogicRule {\n  constructor(rules) {\n    this.rules = rules;\n  }\n  /**\n   * By default logic rule resolves to false.\n   */\n\n\n  async resolve(parent, args, ctx, info, options) {\n    return false;\n  }\n  /**\n   * Evaluates all the rules.\n   */\n\n\n  async evaluate(parent, args, ctx, info, options) {\n    const rules = this.getRules();\n    const tasks = rules.map(rule => rule.resolve(parent, args, ctx, info, options));\n    return Promise.all(tasks);\n  }\n  /**\n   * Returns rules in a logic rule.\n   */\n\n\n  getRules() {\n    return this.rules;\n  }\n  /**\n   * Extracts fragments from the defined rules.\n   */\n\n\n  extractFragments() {\n    const fragments = this.rules.reduce((fragments, rule) => {\n      if (utils_1.isLogicRule(rule)) {\n        return fragments.concat(...rule.extractFragments());\n      }\n\n      const fragment = rule.extractFragment();\n      if (fragment) return fragments.concat(fragment);\n      return fragments;\n    }, []);\n    return fragments;\n  }\n\n}\n\nexports.LogicRule = LogicRule; // Extended Types\n\nclass RuleOr extends LogicRule {\n  constructor(rules) {\n    super(rules);\n  }\n  /**\n   * Makes sure that at least one of them has evaluated to true.\n   */\n\n\n  async resolve(parent, args, ctx, info, options) {\n    const result = await this.evaluate(parent, args, ctx, info, options);\n\n    if (result.every(res => res !== true)) {\n      const customError = result.find(res => res instanceof Error);\n      return customError || false;\n    } else {\n      return true;\n    }\n  }\n\n}\n\nexports.RuleOr = RuleOr;\n\nclass RuleAnd extends LogicRule {\n  constructor(rules) {\n    super(rules);\n  }\n  /**\n   * Makes sure that all of them have resolved to true.\n   */\n\n\n  async resolve(parent, args, ctx, info, options) {\n    const result = await this.evaluate(parent, args, ctx, info, options);\n\n    if (result.some(res => res !== true)) {\n      const customError = result.find(res => res instanceof Error);\n      return customError || false;\n    } else {\n      return true;\n    }\n  }\n\n}\n\nexports.RuleAnd = RuleAnd;\n\nclass RuleChain extends LogicRule {\n  constructor(rules) {\n    super(rules);\n  }\n  /**\n   * Makes sure that all of them have resolved to true.\n   */\n\n\n  async resolve(parent, args, ctx, info, options) {\n    const result = await this.evaluate(parent, args, ctx, info, options);\n\n    if (result.some(res => res !== true)) {\n      const customError = result.find(res => res instanceof Error);\n      return customError || false;\n    } else {\n      return true;\n    }\n  }\n  /**\n   * Evaluates all the rules.\n   */\n\n\n  async evaluate(parent, args, ctx, info, options) {\n    const rules = this.getRules();\n    return iterate(rules);\n\n    async function iterate(_ref) {\n      let [rule, ...otherRules] = _ref;\n      if (util_1.isUndefined(rule)) return [];\n      return rule.resolve(parent, args, ctx, info, options).then(res => {\n        if (res !== true) {\n          return [res];\n        } else {\n          return iterate(otherRules).then(ress => ress.concat(res));\n        }\n      });\n    }\n  }\n\n}\n\nexports.RuleChain = RuleChain;\n\nclass RuleRace extends LogicRule {\n  constructor(rules) {\n    super(rules);\n  }\n  /**\n   * Makes sure that at least one of them resolved to true.\n   */\n\n\n  async resolve(parent, args, ctx, info, options) {\n    const result = await this.evaluate(parent, args, ctx, info, options);\n\n    if (result.some(res => res === true)) {\n      return true;\n    } else {\n      const customError = result.find(res => res instanceof Error);\n      return customError || false;\n    }\n  }\n  /**\n   * Evaluates all the rules.\n   */\n\n\n  async evaluate(parent, args, ctx, info, options) {\n    const rules = this.getRules();\n    return iterate(rules);\n\n    async function iterate(_ref2) {\n      let [rule, ...otherRules] = _ref2;\n      if (util_1.isUndefined(rule)) return [];\n      return rule.resolve(parent, args, ctx, info, options).then(res => {\n        if (res === true) {\n          return [res];\n        } else {\n          return iterate(otherRules).then(ress => ress.concat(res));\n        }\n      });\n    }\n  }\n\n}\n\nexports.RuleRace = RuleRace;\n\nclass RuleNot extends LogicRule {\n  constructor(rule, error) {\n    super([rule]);\n    this.error = error;\n  }\n  /**\n   *\n   * @param parent\n   * @param args\n   * @param ctx\n   * @param info\n   *\n   * Negates the result.\n   *\n   */\n\n\n  async resolve(parent, args, ctx, info, options) {\n    const [res] = await this.evaluate(parent, args, ctx, info, options);\n\n    if (res instanceof Error) {\n      return true;\n    } else if (res !== true) {\n      return true;\n    } else {\n      if (this.error) return this.error;\n      return false;\n    }\n  }\n\n}\n\nexports.RuleNot = RuleNot;\n\nclass RuleTrue extends LogicRule {\n  constructor() {\n    super([]);\n  }\n  /**\n   *\n   * Always true.\n   *\n   */\n\n\n  async resolve() {\n    return true;\n  }\n\n}\n\nexports.RuleTrue = RuleTrue;\n\nclass RuleFalse extends LogicRule {\n  constructor() {\n    super([]);\n  }\n  /**\n   *\n   * Always false.\n   *\n   */\n\n\n  async resolve() {\n    return false;\n  }\n\n}\n\nexports.RuleFalse = RuleFalse;","map":{"version":3,"mappings":"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","names":["Rule","constructor","name","func","constructorOptions","options","normalizeOptions","cache","fragment","resolve","parent","args","ctx","info","res","executeRule","Error","err","debug","equals","rule","extractFragment","undefined","normalizeCacheOption","key","writeToCache","hashFunction","_shield","exports","InputRule","schema","validationFunction","Yup","validate","then","catch","LogicRule","rules","evaluate","getRules","tasks","map","Promise","all","extractFragments","fragments","reduce","utils_1","concat","RuleOr","result","every","customError","find","RuleAnd","some","RuleChain","iterate","otherRules","util_1","ress","RuleRace","RuleNot","error","RuleTrue","RuleFalse"],"sources":["../src/rules.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}