{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst graphql = require('graphql');\n\nconst asArray = fns => Array.isArray(fns) ? fns : fns ? [fns] : [];\n\nconst invalidDocRegex = /\\.[a-z0-9]+$/i;\n\nfunction isDocumentString(str) {\n  if (typeof str !== 'string') {\n    return false;\n  } // XXX: is-valid-path or is-glob treat SDL as a valid path\n  // (`scalar Date` for example)\n  // this why checking the extension is fast enough\n  // and prevent from parsing the string in order to find out\n  // if the string is a SDL\n\n\n  if (invalidDocRegex.test(str)) {\n    return false;\n  }\n\n  try {\n    graphql.parse(str);\n    return true;\n  } catch (e) {}\n\n  return false;\n}\n\nconst invalidPathRegex = /[‘“!%&^<=>`]/;\n\nfunction isValidPath(str) {\n  return typeof str === 'string' && !invalidPathRegex.test(str);\n}\n\nfunction compareStrings(a, b) {\n  if (String(a) < String(b)) {\n    return -1;\n  }\n\n  if (String(a) > String(b)) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction nodeToString(a) {\n  var _a, _b;\n\n  let name;\n\n  if ('alias' in a) {\n    name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;\n  }\n\n  if (name == null && 'name' in a) {\n    name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;\n  }\n\n  if (name == null) {\n    name = a.kind;\n  }\n\n  return name;\n}\n\nfunction compareNodes(a, b, customFn) {\n  const aStr = nodeToString(a);\n  const bStr = nodeToString(b);\n\n  if (typeof customFn === 'function') {\n    return customFn(aStr, bStr);\n  }\n\n  return compareStrings(aStr, bStr);\n}\n\nfunction isSome(input) {\n  return input != null;\n}\n\nfunction assertSome(input) {\n  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Value should be something';\n\n  if (input == null) {\n    throw new Error(message);\n  }\n}\n\nif (typeof AggregateError === 'undefined') {\n  class AggregateErrorClass extends Error {\n    constructor(errors) {\n      let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      super(message);\n      this.errors = errors;\n      this.name = 'AggregateError';\n      Error.captureStackTrace(this, AggregateErrorClass);\n    }\n\n  }\n\n  exports.AggregateError = function (errors, message) {\n    return new AggregateErrorClass(errors, message);\n  };\n} else {\n  exports.AggregateError = AggregateError;\n}\n\nfunction isAggregateError(error) {\n  return 'errors' in error && Array.isArray(error['errors']);\n} // Taken from graphql-js\n\n\nconst MAX_RECURSIVE_DEPTH = 3;\n/**\n * Used to print values in error messages.\n */\n\nfunction inspect(value) {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value, seenValues) {\n  switch (typeof value) {\n    case 'string':\n      return JSON.stringify(value);\n\n    case 'function':\n      return value.name ? `[function ${value.name}]` : '[function]';\n\n    case 'object':\n      return formatObjectValue(value, seenValues);\n\n    default:\n      return String(value);\n  }\n}\n\nfunction formatError(value) {\n  if (value instanceof graphql.GraphQLError) {\n    return value.toString();\n  }\n\n  return `${value.name}: ${value.message};\\n ${value.stack}`;\n}\n\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (value === null) {\n    return 'null';\n  }\n\n  if (value instanceof Error) {\n    if (isAggregateError(value)) {\n      return formatError(value) + '\\n' + formatArray(value.errors, previouslySeenValues);\n    }\n\n    return formatError(value);\n  }\n\n  if (previouslySeenValues.includes(value)) {\n    return '[Circular]';\n  }\n\n  const seenValues = [...previouslySeenValues, value];\n\n  if (isJSONable(value)) {\n    const jsonValue = value.toJSON(); // check for infinite recursion\n\n    if (jsonValue !== value) {\n      return typeof jsonValue === 'string' ? jsonValue : formatValue(jsonValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction isJSONable(value) {\n  return typeof value.toJSON === 'function';\n}\n\nfunction formatObject(object, seenValues) {\n  const entries = Object.entries(object);\n\n  if (entries.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  const properties = entries.map(_ref => {\n    let [key, value] = _ref;\n    return key + ': ' + formatValue(value, seenValues);\n  });\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  const len = array.length;\n  const remaining = array.length;\n  const items = [];\n\n  for (let i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(`... ${remaining} more items`);\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getObjectTag(object) {\n  const tag = Object.prototype.toString.call(object).replace(/^\\[object /, '').replace(/]$/, '');\n\n  if (tag === 'Object' && typeof object.constructor === 'function') {\n    const name = object.constructor.name;\n\n    if (typeof name === 'string' && name !== '') {\n      return name;\n    }\n  }\n\n  return tag;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\n\nfunction getArgumentValues(def, node) {\n  let variableValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  const variableMap = Object.entries(variableValues).reduce((prev, _ref2) => {\n    let [key, value] = _ref2;\n    return { ...prev,\n      [key]: value\n    };\n  }, {});\n  const coercedValues = {};\n  const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];\n  const argNodeMap = argumentNodes.reduce((prev, arg) => ({ ...prev,\n    [arg.name.value]: arg\n  }), {});\n\n  for (const {\n    name,\n    type: argType,\n    defaultValue\n  } of def.args) {\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (defaultValue !== undefined) {\n        coercedValues[name] = defaultValue;\n      } else if (graphql.isNonNullType(argType)) {\n        throw new graphql.GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` + 'was not provided.', node);\n      }\n\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === graphql.Kind.NULL;\n\n    if (valueNode.kind === graphql.Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n\n      if (variableValues == null || variableMap[variableName] == null) {\n        if (defaultValue !== undefined) {\n          coercedValues[name] = defaultValue;\n        } else if (graphql.isNonNullType(argType)) {\n          throw new graphql.GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` + `was provided the variable \"$${variableName}\" which was not provided a runtime value.`, valueNode);\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && graphql.isNonNullType(argType)) {\n      throw new graphql.GraphQLError(`Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` + 'must not be null.', valueNode);\n    }\n\n    const coercedValue = graphql.valueFromAST(valueNode, argType, variableValues);\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new graphql.GraphQLError(`Argument \"${name}\" has invalid value ${graphql.print(valueNode)}.`, valueNode);\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n\nfunction getDirectivesInExtensions(node) {\n  let pathToDirectivesInExtensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['directives'];\n  return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);\n}\n\nfunction _getDirectiveInExtensions(directivesInExtensions, directiveName) {\n  const directiveInExtensions = directivesInExtensions.filter(directiveAnnotation => directiveAnnotation.name === directiveName);\n\n  if (!directiveInExtensions.length) {\n    return undefined;\n  }\n\n  return directiveInExtensions.map(directive => {\n    var _a;\n\n    return (_a = directive.args) !== null && _a !== void 0 ? _a : {};\n  });\n}\n\nfunction getDirectiveInExtensions(node, directiveName) {\n  let pathToDirectivesInExtensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['directives'];\n  const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);\n\n  if (directivesInExtensions === undefined) {\n    return undefined;\n  }\n\n  if (Array.isArray(directivesInExtensions)) {\n    return _getDirectiveInExtensions(directivesInExtensions, directiveName);\n  } // Support condensed format by converting to longer format\n  // The condensed format does not preserve ordering of directives when  repeatable directives are used.\n  // See https://github.com/ardatan/graphql-tools/issues/2534\n\n\n  const reformattedDirectivesInExtensions = [];\n\n  for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {\n    if (Array.isArray(argsOrArrayOfArgs)) {\n      for (const args of argsOrArrayOfArgs) {\n        reformattedDirectivesInExtensions.push({\n          name,\n          args\n        });\n      }\n    } else {\n      reformattedDirectivesInExtensions.push({\n        name,\n        args: argsOrArrayOfArgs\n      });\n    }\n  }\n\n  return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);\n}\n\nfunction getDirectives(schema, node) {\n  let pathToDirectivesInExtensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['directives'];\n  const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);\n\n  if (directivesInExtensions != null && directivesInExtensions.length > 0) {\n    return directivesInExtensions;\n  }\n\n  const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];\n  const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap, schemaDirective) => {\n    schemaDirectiveMap[schemaDirective.name] = schemaDirective;\n    return schemaDirectiveMap;\n  }, {});\n  let astNodes = [];\n\n  if (node.astNode) {\n    astNodes.push(node.astNode);\n  }\n\n  if ('extensionASTNodes' in node && node.extensionASTNodes) {\n    astNodes = [...astNodes, ...node.extensionASTNodes];\n  }\n\n  const result = [];\n\n  for (const astNode of astNodes) {\n    if (astNode.directives) {\n      for (const directiveNode of astNode.directives) {\n        const schemaDirective = schemaDirectiveMap[directiveNode.name.value];\n\n        if (schemaDirective) {\n          result.push({\n            name: directiveNode.name.value,\n            args: getArgumentValues(schemaDirective, directiveNode)\n          });\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getDirective(schema, node, directiveName) {\n  let pathToDirectivesInExtensions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ['directives'];\n  const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);\n\n  if (directiveInExtensions != null) {\n    return directiveInExtensions;\n  }\n\n  const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : undefined;\n\n  if (schemaDirective == null) {\n    return undefined;\n  }\n\n  let astNodes = [];\n\n  if (node.astNode) {\n    astNodes.push(node.astNode);\n  }\n\n  if ('extensionASTNodes' in node && node.extensionASTNodes) {\n    astNodes = [...astNodes, ...node.extensionASTNodes];\n  }\n\n  const result = [];\n\n  for (const astNode of astNodes) {\n    if (astNode.directives) {\n      for (const directiveNode of astNode.directives) {\n        if (directiveNode.name.value === directiveName) {\n          result.push(getArgumentValues(schemaDirective, directiveNode));\n        }\n      }\n    }\n  }\n\n  if (!result.length) {\n    return undefined;\n  }\n\n  return result;\n}\n\nfunction parseDirectiveValue(value) {\n  switch (value.kind) {\n    case graphql.Kind.INT:\n      return parseInt(value.value);\n\n    case graphql.Kind.FLOAT:\n      return parseFloat(value.value);\n\n    case graphql.Kind.BOOLEAN:\n      return Boolean(value.value);\n\n    case graphql.Kind.STRING:\n    case graphql.Kind.ENUM:\n      return value.value;\n\n    case graphql.Kind.LIST:\n      return value.values.map(v => parseDirectiveValue(v));\n\n    case graphql.Kind.OBJECT:\n      return value.fields.reduce((prev, v) => ({ ...prev,\n        [v.name.value]: parseDirectiveValue(v.value)\n      }), {});\n\n    case graphql.Kind.NULL:\n      return null;\n\n    default:\n      return null;\n  }\n}\n\nfunction getFieldsWithDirectives(documentNode) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const result = {};\n  let selected = ['ObjectTypeDefinition', 'ObjectTypeExtension'];\n\n  if (options.includeInputTypes) {\n    selected = [...selected, 'InputObjectTypeDefinition', 'InputObjectTypeExtension'];\n  }\n\n  const allTypes = documentNode.definitions.filter(obj => selected.includes(obj.kind));\n\n  for (const type of allTypes) {\n    const typeName = type.name.value;\n\n    if (type.fields == null) {\n      continue;\n    }\n\n    for (const field of type.fields) {\n      if (field.directives && field.directives.length > 0) {\n        const fieldName = field.name.value;\n        const key = `${typeName}.${fieldName}`;\n        const directives = field.directives.map(d => ({\n          name: d.name.value,\n          args: (d.arguments || []).reduce((prev, arg) => ({ ...prev,\n            [arg.name.value]: parseDirectiveValue(arg.value)\n          }), {})\n        }));\n        result[key] = directives;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getImplementingTypes(interfaceName, schema) {\n  const allTypesMap = schema.getTypeMap();\n  const result = [];\n\n  for (const graphqlTypeName in allTypesMap) {\n    const graphqlType = allTypesMap[graphqlTypeName];\n\n    if (graphql.isObjectType(graphqlType)) {\n      const allInterfaces = graphqlType.getInterfaces();\n\n      if (allInterfaces.find(int => int.name === interfaceName)) {\n        result.push(graphqlType.name);\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction astFromType(type) {\n  if (graphql.isNonNullType(type)) {\n    const innerType = astFromType(type.ofType);\n\n    if (innerType.kind === graphql.Kind.NON_NULL_TYPE) {\n      throw new Error(`Invalid type node ${inspect(type)}. Inner type of non-null type cannot be a non-null type.`);\n    }\n\n    return {\n      kind: graphql.Kind.NON_NULL_TYPE,\n      type: innerType\n    };\n  } else if (graphql.isListType(type)) {\n    return {\n      kind: graphql.Kind.LIST_TYPE,\n      type: astFromType(type.ofType)\n    };\n  }\n\n  return {\n    kind: graphql.Kind.NAMED_TYPE,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: type.name\n    }\n  };\n}\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using the following mapping.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String               |\n * | Number        | Int / Float          |\n * | null          | NullValue            |\n *\n */\n\n\nfunction astFromValueUntyped(value) {\n  // only explicit null, not undefined, NaN\n  if (value === null) {\n    return {\n      kind: graphql.Kind.NULL\n    };\n  } // undefined\n\n\n  if (value === undefined) {\n    return null;\n  } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n  // the value is not an array, convert the value using the list's item type.\n\n\n  if (Array.isArray(value)) {\n    const valuesNodes = [];\n\n    for (const item of value) {\n      const itemNode = astFromValueUntyped(item);\n\n      if (itemNode != null) {\n        valuesNodes.push(itemNode);\n      }\n    }\n\n    return {\n      kind: graphql.Kind.LIST,\n      values: valuesNodes\n    };\n  }\n\n  if (typeof value === 'object') {\n    const fieldNodes = [];\n\n    for (const fieldName in value) {\n      const fieldValue = value[fieldName];\n      const ast = astFromValueUntyped(fieldValue);\n\n      if (ast) {\n        fieldNodes.push({\n          kind: graphql.Kind.OBJECT_FIELD,\n          name: {\n            kind: graphql.Kind.NAME,\n            value: fieldName\n          },\n          value: ast\n        });\n      }\n    }\n\n    return {\n      kind: graphql.Kind.OBJECT,\n      fields: fieldNodes\n    };\n  } // Others serialize based on their corresponding JavaScript scalar types.\n\n\n  if (typeof value === 'boolean') {\n    return {\n      kind: graphql.Kind.BOOLEAN,\n      value\n    };\n  } // JavaScript numbers can be Int or Float values.\n\n\n  if (typeof value === 'number' && isFinite(value)) {\n    const stringNum = String(value);\n    return integerStringRegExp.test(stringNum) ? {\n      kind: graphql.Kind.INT,\n      value: stringNum\n    } : {\n      kind: graphql.Kind.FLOAT,\n      value: stringNum\n    };\n  }\n\n  if (typeof value === 'string') {\n    return {\n      kind: graphql.Kind.STRING,\n      value\n    };\n  }\n\n  throw new TypeError(`Cannot convert value to AST: ${value}.`);\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\n\n\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n\nfunction memoize1(fn) {\n  const memoize1cache = new WeakMap();\n  return function memoized(a1) {\n    const cachedValue = memoize1cache.get(a1);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1);\n      memoize1cache.set(a1, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize2(fn) {\n  const memoize2cache = new WeakMap();\n  return function memoized(a1, a2) {\n    let cache2 = memoize2cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize2cache.set(a1, cache2);\n      const newValue = fn(a1, a2);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache2.get(a2);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize3(fn) {\n  const memoize3Cache = new WeakMap();\n  return function memoized(a1, a2, a3) {\n    let cache2 = memoize3Cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize3Cache.set(a1, cache2);\n      const cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    let cache3 = cache2.get(a2);\n\n    if (!cache3) {\n      cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache3.get(a3);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize4(fn) {\n  const memoize4Cache = new WeakMap();\n  return function memoized(a1, a2, a3, a4) {\n    let cache2 = memoize4Cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize4Cache.set(a1, cache2);\n      const cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    let cache3 = cache2.get(a2);\n\n    if (!cache3) {\n      cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    const cache4 = cache3.get(a3);\n\n    if (!cache4) {\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache4.get(a4);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction memoize5(fn) {\n  const memoize5Cache = new WeakMap();\n  return function memoized(a1, a2, a3, a4, a5) {\n    let cache2 = memoize5Cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize5Cache.set(a1, cache2);\n      const cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const cache5 = new WeakMap();\n      cache4.set(a4, cache5);\n      const newValue = fn(a1, a2, a3, a4, a5);\n      cache5.set(a5, newValue);\n      return newValue;\n    }\n\n    let cache3 = cache2.get(a2);\n\n    if (!cache3) {\n      cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const cache5 = new WeakMap();\n      cache4.set(a4, cache5);\n      const newValue = fn(a1, a2, a3, a4, a5);\n      cache5.set(a5, newValue);\n      return newValue;\n    }\n\n    let cache4 = cache3.get(a3);\n\n    if (!cache4) {\n      cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const cache5 = new WeakMap();\n      cache4.set(a4, cache5);\n      const newValue = fn(a1, a2, a3, a4, a5);\n      cache5.set(a5, newValue);\n      return newValue;\n    }\n\n    let cache5 = cache4.get(a4);\n\n    if (!cache5) {\n      cache5 = new WeakMap();\n      cache4.set(a4, cache5);\n      const newValue = fn(a1, a2, a3, a4, a5);\n      cache5.set(a5, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache5.get(a5);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3, a4, a5);\n      cache5.set(a5, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nconst memoize2of4cache = new WeakMap();\n\nfunction memoize2of4(fn) {\n  return function memoized(a1, a2, a3, a4) {\n    let cache2 = memoize2of4cache.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      memoize2of4cache.set(a1, cache2);\n      const newValue = fn(a1, a2, a3, a4);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache2.get(a2);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3, a4);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  };\n}\n\nfunction getDefinedRootType(schema, operation) {\n  const rootTypeMap = getRootTypeMap(schema);\n  const rootType = rootTypeMap.get(operation);\n\n  if (rootType == null) {\n    throw new Error(`Root type for operation \"${operation}\" not defined by the given schema.`);\n  }\n\n  return rootType;\n}\n\nconst getRootTypeNames = memoize1(function getRootTypeNames(schema) {\n  const rootTypes = getRootTypes(schema);\n  return new Set([...rootTypes].map(type => type.name));\n});\nconst getRootTypes = memoize1(function getRootTypes(schema) {\n  const rootTypeMap = getRootTypeMap(schema);\n  return new Set(rootTypeMap.values());\n});\nconst getRootTypeMap = memoize1(function getRootTypeMap(schema) {\n  const rootTypeMap = new Map();\n  const queryType = schema.getQueryType();\n\n  if (queryType) {\n    rootTypeMap.set('query', queryType);\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType) {\n    rootTypeMap.set('mutation', mutationType);\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    rootTypeMap.set('subscription', subscriptionType);\n  }\n\n  return rootTypeMap;\n});\n\nfunction getDocumentNodeFromSchema(schema) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;\n  const typesMap = schema.getTypeMap();\n  const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);\n  const definitions = schemaNode != null ? [schemaNode] : [];\n  const directives = schema.getDirectives();\n\n  for (const directive of directives) {\n    if (graphql.isSpecifiedDirective(directive)) {\n      continue;\n    }\n\n    definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));\n  }\n\n  for (const typeName in typesMap) {\n    const type = typesMap[typeName];\n    const isPredefinedScalar = graphql.isSpecifiedScalarType(type);\n    const isIntrospection = graphql.isIntrospectionType(type);\n\n    if (isPredefinedScalar || isIntrospection) {\n      continue;\n    }\n\n    if (graphql.isObjectType(type)) {\n      definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));\n    } else if (graphql.isInterfaceType(type)) {\n      definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));\n    } else if (graphql.isUnionType(type)) {\n      definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));\n    } else if (graphql.isInputObjectType(type)) {\n      definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));\n    } else if (graphql.isEnumType(type)) {\n      definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));\n    } else if (graphql.isScalarType(type)) {\n      definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));\n    } else {\n      throw new Error(`Unknown type ${type}.`);\n    }\n  }\n\n  return {\n    kind: graphql.Kind.DOCUMENT,\n    definitions\n  };\n} // this approach uses the default schema printer rather than a custom solution, so may be more backwards compatible\n// currently does not allow customization of printSchema options having to do with comments.\n\n\nfunction printSchemaWithDirectives(schema) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const documentNode = getDocumentNodeFromSchema(schema, options);\n  return graphql.print(documentNode);\n}\n\nfunction astFromSchema(schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  const operationTypeMap = new Map([['query', undefined], ['mutation', undefined], ['subscription', undefined]]);\n  const nodes = [];\n\n  if (schema.astNode != null) {\n    nodes.push(schema.astNode);\n  }\n\n  if (schema.extensionASTNodes != null) {\n    for (const extensionASTNode of schema.extensionASTNodes) {\n      nodes.push(extensionASTNode);\n    }\n  }\n\n  for (const node of nodes) {\n    if (node.operationTypes) {\n      for (const operationTypeDefinitionNode of node.operationTypes) {\n        operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);\n      }\n    }\n  }\n\n  const rootTypeMap = getRootTypeMap(schema);\n\n  for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {\n    const rootType = rootTypeMap.get(operationTypeNode);\n\n    if (rootType != null) {\n      const rootTypeAST = astFromType(rootType);\n\n      if (operationTypeDefinitionNode != null) {\n        operationTypeDefinitionNode.type = rootTypeAST;\n      } else {\n        operationTypeMap.set(operationTypeNode, {\n          kind: graphql.Kind.OPERATION_TYPE_DEFINITION,\n          operation: operationTypeNode,\n          type: rootTypeAST\n        });\n      }\n    }\n  }\n\n  const operationTypes = [...operationTypeMap.values()].filter(isSome);\n  const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);\n\n  if (!operationTypes.length && !directives.length) {\n    return null;\n  }\n\n  const schemaNode = {\n    kind: operationTypes != null ? graphql.Kind.SCHEMA_DEFINITION : graphql.Kind.SCHEMA_EXTENSION,\n    operationTypes,\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: directives\n  }; // This code is so weird because it needs to support GraphQL.js 14\n  // In GraphQL.js 14 there is no `description` value on schemaNode\n\n  schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {\n    kind: graphql.Kind.STRING,\n    value: schema.description,\n    block: true\n  } : undefined;\n  return schemaNode;\n}\n\nfunction astFromDirective(directive, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c, _d;\n\n  return {\n    kind: graphql.Kind.DIRECTIVE_DEFINITION,\n    description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {\n      kind: graphql.Kind.STRING,\n      value: directive.description\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: directive.name\n    },\n    arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n    repeatable: directive.isRepeatable,\n    locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map(location => ({\n      kind: graphql.Kind.NAME,\n      value: location\n    }))) || []\n  };\n}\n\nfunction getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n  let nodes = [];\n\n  if (entity.astNode != null) {\n    nodes.push(entity.astNode);\n  }\n\n  if ('extensionASTNodes' in entity && entity.extensionASTNodes != null) {\n    nodes = nodes.concat(entity.extensionASTNodes);\n  }\n\n  let directives;\n\n  if (directivesInExtensions != null) {\n    directives = makeDirectiveNodes(schema, directivesInExtensions);\n  } else {\n    directives = [];\n\n    for (const node of nodes) {\n      if (node.directives) {\n        directives.push(...node.directives);\n      }\n    }\n  }\n\n  return directives;\n}\n\nfunction getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  let directiveNodesBesidesDeprecated = [];\n  let deprecatedDirectiveNode = null;\n  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n  let directives;\n\n  if (directivesInExtensions != null) {\n    directives = makeDirectiveNodes(schema, directivesInExtensions);\n  } else {\n    directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;\n  }\n\n  if (directives != null) {\n    directiveNodesBesidesDeprecated = directives.filter(directive => directive.name.value !== 'deprecated');\n\n    if (entity.deprecationReason != null) {\n      deprecatedDirectiveNode = (_b = directives.filter(directive => directive.name.value === 'deprecated')) === null || _b === void 0 ? void 0 : _b[0];\n    }\n  }\n\n  if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {\n    deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);\n  }\n\n  return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);\n}\n\nfunction astFromArg(arg, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c;\n\n  return {\n    kind: graphql.Kind.INPUT_VALUE_DEFINITION,\n    description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {\n      kind: graphql.Kind.STRING,\n      value: arg.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: arg.name\n    },\n    type: astFromType(arg.type),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    defaultValue: arg.defaultValue !== undefined ? (_c = graphql.astFromValue(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : undefined : undefined,\n    directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromObjectType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: graphql.Kind.OBJECT_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: graphql.Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: type.name\n    },\n    fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n    interfaces: Object.values(type.getInterfaces()).map(iFace => astFromType(iFace)),\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  const node = {\n    kind: graphql.Kind.INTERFACE_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: graphql.Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: type.name\n    },\n    fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n\n  if ('getInterfaces' in type) {\n    node.interfaces = Object.values(type.getInterfaces()).map(iFace => astFromType(iFace));\n  }\n\n  return node;\n}\n\nfunction astFromUnionType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: graphql.Kind.UNION_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: graphql.Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: type.name\n    },\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    types: type.getTypes().map(type => astFromType(type))\n  };\n}\n\nfunction astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: graphql.Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: type.name\n    },\n    fields: Object.values(type.getFields()).map(field => astFromInputField(field, schema, pathToDirectivesInExtensions)),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromEnumType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: graphql.Kind.ENUM_TYPE_DEFINITION,\n    description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {\n      kind: graphql.Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: type.name\n    },\n    values: Object.values(type.getValues()).map(value => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromScalarType(type, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c;\n\n  const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);\n  const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];\n  const specifiedByValue = type['specifiedByUrl'] || type['specifiedByURL'];\n\n  if (specifiedByValue && !directives.some(directiveNode => directiveNode.name.value === 'specifiedBy')) {\n    const specifiedByArgs = {\n      url: specifiedByValue\n    };\n    directives.push(makeDirectiveNode('specifiedBy', specifiedByArgs));\n  }\n\n  return {\n    kind: graphql.Kind.SCALAR_TYPE_DEFINITION,\n    description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.description ? {\n      kind: graphql.Kind.STRING,\n      value: type.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: type.name\n    },\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: directives\n  };\n}\n\nfunction astFromField(field, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: graphql.Kind.FIELD_DEFINITION,\n    description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {\n      kind: graphql.Kind.STRING,\n      value: field.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: field.name\n    },\n    arguments: field.args.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n    type: astFromType(field.type),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction astFromInputField(field, schema, pathToDirectivesInExtensions) {\n  var _a, _b, _c;\n\n  return {\n    kind: graphql.Kind.INPUT_VALUE_DEFINITION,\n    description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {\n      kind: graphql.Kind.STRING,\n      value: field.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: field.name\n    },\n    type: astFromType(field.type),\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n    defaultValue: (_c = graphql.astFromValue(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : undefined\n  };\n}\n\nfunction astFromEnumValue(value, schema, pathToDirectivesInExtensions) {\n  var _a, _b;\n\n  return {\n    kind: graphql.Kind.ENUM_VALUE_DEFINITION,\n    description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {\n      kind: graphql.Kind.STRING,\n      value: value.description,\n      block: true\n    } : undefined,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: value.name\n    },\n    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n    directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)\n  };\n}\n\nfunction makeDeprecatedDirective(deprecationReason) {\n  return makeDirectiveNode('deprecated', {\n    reason: deprecationReason\n  }, graphql.GraphQLDeprecatedDirective);\n}\n\nfunction makeDirectiveNode(name, args, directive) {\n  const directiveArguments = [];\n\n  if (directive != null) {\n    for (const arg of directive.args) {\n      const argName = arg.name;\n      const argValue = args[argName];\n\n      if (argValue !== undefined) {\n        const value = graphql.astFromValue(argValue, arg.type);\n\n        if (value) {\n          directiveArguments.push({\n            kind: graphql.Kind.ARGUMENT,\n            name: {\n              kind: graphql.Kind.NAME,\n              value: argName\n            },\n            value\n          });\n        }\n      }\n    }\n  } else {\n    for (const argName in args) {\n      const argValue = args[argName];\n      const value = astFromValueUntyped(argValue);\n\n      if (value) {\n        directiveArguments.push({\n          kind: graphql.Kind.ARGUMENT,\n          name: {\n            kind: graphql.Kind.NAME,\n            value: argName\n          },\n          value\n        });\n      }\n    }\n  }\n\n  return {\n    kind: graphql.Kind.DIRECTIVE,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: name\n    },\n    arguments: directiveArguments\n  };\n}\n\nfunction makeDirectiveNodes(schema, directiveValues) {\n  const directiveNodes = [];\n\n  for (const directiveName in directiveValues) {\n    const arrayOrSingleValue = directiveValues[directiveName];\n    const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);\n\n    if (Array.isArray(arrayOrSingleValue)) {\n      for (const value of arrayOrSingleValue) {\n        directiveNodes.push(makeDirectiveNode(directiveName, value, directive));\n      }\n    } else {\n      directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));\n    }\n  }\n\n  return directiveNodes;\n}\n\nasync function validateGraphQlDocuments(schema, documentFiles) {\n  let effectiveRules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : createDefaultRules();\n  const allFragmentMap = new Map();\n  const documentFileObjectsToValidate = [];\n\n  for (const documentFile of documentFiles) {\n    if (documentFile.document) {\n      const definitionsToValidate = [];\n\n      for (const definitionNode of documentFile.document.definitions) {\n        if (definitionNode.kind === graphql.Kind.FRAGMENT_DEFINITION) {\n          allFragmentMap.set(definitionNode.name.value, definitionNode);\n        } else {\n          definitionsToValidate.push(definitionNode);\n        }\n      }\n\n      documentFileObjectsToValidate.push({\n        location: documentFile.location,\n        document: {\n          kind: graphql.Kind.DOCUMENT,\n          definitions: definitionsToValidate\n        }\n      });\n    }\n  }\n\n  const allErrors = [];\n  const allFragmentsDocument = {\n    kind: graphql.Kind.DOCUMENT,\n    definitions: [...allFragmentMap.values()]\n  };\n  await Promise.all(documentFileObjectsToValidate.map(async documentFile => {\n    const documentToValidate = graphql.concatAST([allFragmentsDocument, documentFile.document]);\n    const errors = graphql.validate(schema, documentToValidate, effectiveRules);\n\n    if (errors.length > 0) {\n      allErrors.push({\n        filePath: documentFile.location,\n        errors\n      });\n    }\n  }));\n  return allErrors;\n}\n\nfunction checkValidationErrors(loadDocumentErrors) {\n  if (loadDocumentErrors.length > 0) {\n    const errors = [];\n\n    for (const loadDocumentError of loadDocumentErrors) {\n      for (const graphQLError of loadDocumentError.errors) {\n        const error = new Error();\n        error.name = 'GraphQLDocumentError';\n        error.message = `${error.name}: ${graphQLError.message}`;\n        error.stack = error.message;\n\n        if (graphQLError.locations) {\n          for (const location of graphQLError.locations) {\n            error.stack += `\\n    at ${loadDocumentError.filePath}:${location.line}:${location.column}`;\n          }\n        }\n\n        errors.push(error);\n      }\n    }\n\n    throw new exports.AggregateError(errors, `GraphQL Document Validation failed with ${errors.length} errors;\n  ${errors.map((error, index) => `Error ${index}: ${error.stack}`).join('\\n\\n')}`);\n  }\n}\n\nfunction createDefaultRules() {\n  let ignored = ['NoUnusedFragmentsRule', 'NoUnusedVariablesRule', 'KnownDirectivesRule'];\n\n  if (graphql.versionInfo.major < 15) {\n    ignored = ignored.map(rule => rule.replace(/Rule$/, ''));\n  }\n\n  return graphql.specifiedRules.filter(f => !ignored.includes(f.name));\n}\n\nfunction stripBOM(content) {\n  content = content.toString(); // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n  // because the buffer-to-string conversion in `fs.readFileSync()`\n  // translates it to FEFF, the UTF-16 BOM.\n\n  if (content.charCodeAt(0) === 0xfeff) {\n    content = content.slice(1);\n  }\n\n  return content;\n}\n\nfunction parseBOM(content) {\n  return JSON.parse(stripBOM(content));\n}\n\nfunction parseGraphQLJSON(location, jsonContent, options) {\n  let parsedJson = parseBOM(jsonContent);\n\n  if (parsedJson.data) {\n    parsedJson = parsedJson.data;\n  }\n\n  if (parsedJson.kind === 'Document') {\n    return {\n      location,\n      document: parsedJson\n    };\n  } else if (parsedJson.__schema) {\n    const schema = graphql.buildClientSchema(parsedJson, options);\n    return {\n      location,\n      schema\n    };\n  } else if (typeof parsedJson === 'string') {\n    return {\n      location,\n      rawSDL: parsedJson\n    };\n  }\n\n  throw new Error(`Not valid JSON content`);\n}\n\nconst MAX_LINE_LENGTH = 80;\nlet commentsRegistry = {};\n\nfunction resetComments() {\n  commentsRegistry = {};\n}\n\nfunction collectComment(node) {\n  var _a;\n\n  const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;\n\n  if (entityName == null) {\n    return;\n  }\n\n  pushComment(node, entityName);\n\n  switch (node.kind) {\n    case 'EnumTypeDefinition':\n      if (node.values) {\n        for (const value of node.values) {\n          pushComment(value, entityName, value.name.value);\n        }\n      }\n\n      break;\n\n    case 'ObjectTypeDefinition':\n    case 'InputObjectTypeDefinition':\n    case 'InterfaceTypeDefinition':\n      if (node.fields) {\n        for (const field of node.fields) {\n          pushComment(field, entityName, field.name.value);\n\n          if (isFieldDefinitionNode(field) && field.arguments) {\n            for (const arg of field.arguments) {\n              pushComment(arg, entityName, field.name.value, arg.name.value);\n            }\n          }\n        }\n      }\n\n      break;\n  }\n}\n\nfunction pushComment(node, entity, field, argument) {\n  const comment = getComment(node);\n\n  if (typeof comment !== 'string' || comment.length === 0) {\n    return;\n  }\n\n  const keys = [entity];\n\n  if (field) {\n    keys.push(field);\n\n    if (argument) {\n      keys.push(argument);\n    }\n  }\n\n  const path = keys.join('.');\n\n  if (!commentsRegistry[path]) {\n    commentsRegistry[path] = [];\n  }\n\n  commentsRegistry[path].push(comment);\n}\n\nfunction printComment(comment) {\n  return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\n\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(x => x).join(separator || '') : '';\n}\n\nfunction hasMultilineItems(maybeArray) {\n  var _a;\n\n  return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some(str => str.includes('\\n'))) !== null && _a !== void 0 ? _a : false;\n}\n\nfunction addDescription(cb) {\n  return (node, _key, _parent, path, ancestors) => {\n    var _a;\n\n    const keys = [];\n    const parent = path.reduce((prev, key) => {\n      if (['fields', 'arguments', 'values'].includes(key) && prev.name) {\n        keys.push(prev.name.value);\n      }\n\n      return prev[key];\n    }, ancestors[0]);\n    const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join('.');\n    const items = [];\n\n    if (node.kind.includes('Definition') && commentsRegistry[key]) {\n      items.push(...commentsRegistry[key]);\n    }\n\n    return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], '\\n');\n  };\n}\n\nfunction indent(maybeString) {\n  return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\n\n\nfunction block(array) {\n  return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\n\n\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\n\n\nfunction printBlockString(value) {\n  let isDescription = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n  return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1 ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"` : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\n\nconst printDocASTReducer = {\n  Name: {\n    leave: node => node.value\n  },\n  Variable: {\n    leave: node => '$' + node.name\n  },\n  // Document\n  Document: {\n    leave: node => join(node.definitions, '\\n\\n')\n  },\n  OperationDefinition: {\n    leave: node => {\n      const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n      const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, ' ')], ' '); // the query short form.\n\n      return prefix + ' ' + node.selectionSet;\n    }\n  },\n  VariableDefinition: {\n    leave: _ref3 => {\n      let {\n        variable,\n        type,\n        defaultValue,\n        directives\n      } = _ref3;\n      return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));\n    }\n  },\n  SelectionSet: {\n    leave: _ref4 => {\n      let {\n        selections\n      } = _ref4;\n      return block(selections);\n    }\n  },\n  Field: {\n    leave(_ref5) {\n      let {\n        alias,\n        name,\n        arguments: args,\n        directives,\n        selectionSet\n      } = _ref5;\n      const prefix = wrap('', alias, ': ') + name;\n      let argsLine = prefix + wrap('(', join(args, ', '), ')');\n\n      if (argsLine.length > MAX_LINE_LENGTH) {\n        argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n      }\n\n      return join([argsLine, join(directives, ' '), selectionSet], ' ');\n    }\n\n  },\n  Argument: {\n    leave: _ref6 => {\n      let {\n        name,\n        value\n      } = _ref6;\n      return name + ': ' + value;\n    }\n  },\n  // Fragments\n  FragmentSpread: {\n    leave: _ref7 => {\n      let {\n        name,\n        directives\n      } = _ref7;\n      return '...' + name + wrap(' ', join(directives, ' '));\n    }\n  },\n  InlineFragment: {\n    leave: _ref8 => {\n      let {\n        typeCondition,\n        directives,\n        selectionSet\n      } = _ref8;\n      return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n    }\n  },\n  FragmentDefinition: {\n    leave: _ref9 => {\n      let {\n        name,\n        typeCondition,\n        variableDefinitions,\n        directives,\n        selectionSet\n      } = _ref9;\n      return (// Note: fragment variable definitions are experimental and may be changed\n        // or removed in the future.\n        `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` + `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` + selectionSet\n      );\n    }\n  },\n  // Value\n  IntValue: {\n    leave: _ref10 => {\n      let {\n        value\n      } = _ref10;\n      return value;\n    }\n  },\n  FloatValue: {\n    leave: _ref11 => {\n      let {\n        value\n      } = _ref11;\n      return value;\n    }\n  },\n  StringValue: {\n    leave: _ref12 => {\n      let {\n        value,\n        block: isBlockString\n      } = _ref12;\n\n      if (isBlockString) {\n        return printBlockString(value);\n      }\n\n      return JSON.stringify(value);\n    }\n  },\n  BooleanValue: {\n    leave: _ref13 => {\n      let {\n        value\n      } = _ref13;\n      return value ? 'true' : 'false';\n    }\n  },\n  NullValue: {\n    leave: () => 'null'\n  },\n  EnumValue: {\n    leave: _ref14 => {\n      let {\n        value\n      } = _ref14;\n      return value;\n    }\n  },\n  ListValue: {\n    leave: _ref15 => {\n      let {\n        values\n      } = _ref15;\n      return '[' + join(values, ', ') + ']';\n    }\n  },\n  ObjectValue: {\n    leave: _ref16 => {\n      let {\n        fields\n      } = _ref16;\n      return '{' + join(fields, ', ') + '}';\n    }\n  },\n  ObjectField: {\n    leave: _ref17 => {\n      let {\n        name,\n        value\n      } = _ref17;\n      return name + ': ' + value;\n    }\n  },\n  // Directive\n  Directive: {\n    leave: _ref18 => {\n      let {\n        name,\n        arguments: args\n      } = _ref18;\n      return '@' + name + wrap('(', join(args, ', '), ')');\n    }\n  },\n  // Type\n  NamedType: {\n    leave: _ref19 => {\n      let {\n        name\n      } = _ref19;\n      return name;\n    }\n  },\n  ListType: {\n    leave: _ref20 => {\n      let {\n        type\n      } = _ref20;\n      return '[' + type + ']';\n    }\n  },\n  NonNullType: {\n    leave: _ref21 => {\n      let {\n        type\n      } = _ref21;\n      return type + '!';\n    }\n  },\n  // Type System Definitions\n  SchemaDefinition: {\n    leave: _ref22 => {\n      let {\n        directives,\n        operationTypes\n      } = _ref22;\n      return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n    }\n  },\n  OperationTypeDefinition: {\n    leave: _ref23 => {\n      let {\n        operation,\n        type\n      } = _ref23;\n      return operation + ': ' + type;\n    }\n  },\n  ScalarTypeDefinition: {\n    leave: _ref24 => {\n      let {\n        name,\n        directives\n      } = _ref24;\n      return join(['scalar', name, join(directives, ' ')], ' ');\n    }\n  },\n  ObjectTypeDefinition: {\n    leave: _ref25 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref25;\n      return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  FieldDefinition: {\n    leave: _ref26 => {\n      let {\n        name,\n        arguments: args,\n        type,\n        directives\n      } = _ref26;\n      return name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));\n    }\n  },\n  InputValueDefinition: {\n    leave: _ref27 => {\n      let {\n        name,\n        type,\n        defaultValue,\n        directives\n      } = _ref27;\n      return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n    }\n  },\n  InterfaceTypeDefinition: {\n    leave: _ref28 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref28;\n      return join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  UnionTypeDefinition: {\n    leave: _ref29 => {\n      let {\n        name,\n        directives,\n        types\n      } = _ref29;\n      return join(['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ');\n    }\n  },\n  EnumTypeDefinition: {\n    leave: _ref30 => {\n      let {\n        name,\n        directives,\n        values\n      } = _ref30;\n      return join(['enum', name, join(directives, ' '), block(values)], ' ');\n    }\n  },\n  EnumValueDefinition: {\n    leave: _ref31 => {\n      let {\n        name,\n        directives\n      } = _ref31;\n      return join([name, join(directives, ' ')], ' ');\n    }\n  },\n  InputObjectTypeDefinition: {\n    leave: _ref32 => {\n      let {\n        name,\n        directives,\n        fields\n      } = _ref32;\n      return join(['input', name, join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  DirectiveDefinition: {\n    leave: _ref33 => {\n      let {\n        name,\n        arguments: args,\n        repeatable,\n        locations\n      } = _ref33;\n      return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');\n    }\n  },\n  SchemaExtension: {\n    leave: _ref34 => {\n      let {\n        directives,\n        operationTypes\n      } = _ref34;\n      return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');\n    }\n  },\n  ScalarTypeExtension: {\n    leave: _ref35 => {\n      let {\n        name,\n        directives\n      } = _ref35;\n      return join(['extend scalar', name, join(directives, ' ')], ' ');\n    }\n  },\n  ObjectTypeExtension: {\n    leave: _ref36 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref36;\n      return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  InterfaceTypeExtension: {\n    leave: _ref37 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref37;\n      return join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  UnionTypeExtension: {\n    leave: _ref38 => {\n      let {\n        name,\n        directives,\n        types\n      } = _ref38;\n      return join(['extend union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ');\n    }\n  },\n  EnumTypeExtension: {\n    leave: _ref39 => {\n      let {\n        name,\n        directives,\n        values\n      } = _ref39;\n      return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n    }\n  },\n  InputObjectTypeExtension: {\n    leave: _ref40 => {\n      let {\n        name,\n        directives,\n        fields\n      } = _ref40;\n      return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n    }\n  }\n};\nconst printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({ ...prev,\n  [key]: {\n    leave: addDescription(printDocASTReducer[key].leave)\n  }\n}), {});\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\nfunction printWithComments(ast) {\n  return graphql.visit(ast, printDocASTReducerWithComments);\n}\n\nfunction isFieldDefinitionNode(node) {\n  return node.kind === 'FieldDefinition';\n} // graphql < v13 and > v15 does not export getDescription\n\n\nfunction getDescription(node, options) {\n  if (node.description != null) {\n    return node.description.value;\n  }\n\n  if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {\n    return getComment(node);\n  }\n}\n\nfunction getComment(node) {\n  const rawValue = getLeadingCommentBlock(node);\n\n  if (rawValue !== undefined) {\n    return dedentBlockStringValue(`\\n${rawValue}`);\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  const loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  const comments = [];\n  let token = loc.startToken.prev;\n\n  while (token != null && token.kind === graphql.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    const value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\n\nfunction dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  const lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  const commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (let i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n}\n/**\n * @internal\n */\n\n\nfunction getBlockStringIndentation(lines) {\n  let commonIndent = null;\n\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i];\n    const indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  let i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n\nfunction parseGraphQLSDL(location, rawSDL) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let document;\n\n  try {\n    if (options.commentDescriptions && rawSDL.includes('#')) {\n      document = transformCommentsToDescriptions(rawSDL, options); // If noLocation=true, we need to make sure to print and parse it again, to remove locations,\n      // since `transformCommentsToDescriptions` must have locations set in order to transform the comments\n      // into descriptions.\n\n      if (options.noLocation) {\n        document = graphql.parse(graphql.print(document), options);\n      }\n    } else {\n      document = graphql.parse(new graphql.Source(rawSDL, location), options);\n    }\n  } catch (e) {\n    if (e.message.includes('EOF') && rawSDL.replace(/(\\#[^*]*)/g, '').trim() === '') {\n      document = {\n        kind: graphql.Kind.DOCUMENT,\n        definitions: []\n      };\n    } else {\n      throw e;\n    }\n  }\n\n  return {\n    location,\n    document\n  };\n}\n\nfunction transformCommentsToDescriptions(sourceSdl) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const parsedDoc = graphql.parse(sourceSdl, { ...options,\n    noLocation: false\n  });\n  const modifiedDoc = graphql.visit(parsedDoc, {\n    leave: node => {\n      if (isDescribable(node)) {\n        const rawValue = getLeadingCommentBlock(node);\n\n        if (rawValue !== undefined) {\n          const commentsBlock = dedentBlockStringValue('\\n' + rawValue);\n          const isBlock = commentsBlock.includes('\\n');\n\n          if (!node.description) {\n            return { ...node,\n              description: {\n                kind: graphql.Kind.STRING,\n                value: commentsBlock,\n                block: isBlock\n              }\n            };\n          } else {\n            return { ...node,\n              description: { ...node.description,\n                value: node.description.value + '\\n' + commentsBlock,\n                block: true\n              }\n            };\n          }\n        }\n      }\n    }\n  });\n  return modifiedDoc;\n}\n\nfunction isDescribable(node) {\n  return graphql.isTypeSystemDefinitionNode(node) || node.kind === graphql.Kind.FIELD_DEFINITION || node.kind === graphql.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql.Kind.ENUM_VALUE_DEFINITION;\n}\n\nlet operationVariables = [];\nlet fieldTypeMap = new Map();\n\nfunction addOperationVariable(variable) {\n  operationVariables.push(variable);\n}\n\nfunction resetOperationVariables() {\n  operationVariables = [];\n}\n\nfunction resetFieldMap() {\n  fieldTypeMap = new Map();\n}\n\nfunction buildOperationNodeForField(_ref41) {\n  let {\n    schema,\n    kind,\n    field,\n    models,\n    ignore = [],\n    depthLimit,\n    circularReferenceDepth,\n    argNames,\n    selectedFields = true\n  } = _ref41;\n  resetOperationVariables();\n  resetFieldMap();\n  const rootTypeNames = getRootTypeNames(schema);\n  const operationNode = buildOperationAndCollectVariables({\n    schema,\n    fieldName: field,\n    kind,\n    models: models || [],\n    ignore,\n    depthLimit: depthLimit || Infinity,\n    circularReferenceDepth: circularReferenceDepth || 1,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  }); // attach variables\n\n  operationNode.variableDefinitions = [...operationVariables];\n  resetOperationVariables();\n  resetFieldMap();\n  return operationNode;\n}\n\nfunction buildOperationAndCollectVariables(_ref42) {\n  let {\n    schema,\n    fieldName,\n    kind,\n    models,\n    ignore,\n    depthLimit,\n    circularReferenceDepth,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  } = _ref42;\n  const type = getDefinedRootType(schema, kind);\n  const field = type.getFields()[fieldName];\n  const operationName = `${fieldName}_${kind}`;\n\n  if (field.args) {\n    for (const arg of field.args) {\n      const argName = arg.name;\n\n      if (!argNames || argNames.includes(argName)) {\n        addOperationVariable(resolveVariable(arg, argName));\n      }\n    }\n  }\n\n  return {\n    kind: graphql.Kind.OPERATION_DEFINITION,\n    operation: kind,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: operationName\n    },\n    variableDefinitions: [],\n    selectionSet: {\n      kind: graphql.Kind.SELECTION_SET,\n      selections: [resolveField({\n        type,\n        field,\n        models,\n        firstCall: true,\n        path: [],\n        ancestors: [],\n        ignore,\n        depthLimit,\n        circularReferenceDepth,\n        schema,\n        depth: 0,\n        argNames,\n        selectedFields,\n        rootTypeNames\n      })]\n    }\n  };\n}\n\nfunction resolveSelectionSet(_ref43) {\n  let {\n    parent,\n    type,\n    models,\n    firstCall,\n    path,\n    ancestors,\n    ignore,\n    depthLimit,\n    circularReferenceDepth,\n    schema,\n    depth,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  } = _ref43;\n\n  if (typeof selectedFields === 'boolean' && depth > depthLimit) {\n    return;\n  }\n\n  if (graphql.isUnionType(type)) {\n    const types = type.getTypes();\n    return {\n      kind: graphql.Kind.SELECTION_SET,\n      selections: types.filter(t => !hasCircularRef([...ancestors, t], {\n        depth: circularReferenceDepth\n      })).map(t => {\n        return {\n          kind: graphql.Kind.INLINE_FRAGMENT,\n          typeCondition: {\n            kind: graphql.Kind.NAMED_TYPE,\n            name: {\n              kind: graphql.Kind.NAME,\n              value: t.name\n            }\n          },\n          selectionSet: resolveSelectionSet({\n            parent: type,\n            type: t,\n            models,\n            path,\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields,\n            rootTypeNames\n          })\n        };\n      }).filter(fragmentNode => {\n        var _a, _b;\n\n        return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;\n      })\n    };\n  }\n\n  if (graphql.isInterfaceType(type)) {\n    const types = Object.values(schema.getTypeMap()).filter(t => graphql.isObjectType(t) && t.getInterfaces().includes(type));\n    return {\n      kind: graphql.Kind.SELECTION_SET,\n      selections: types.filter(t => !hasCircularRef([...ancestors, t], {\n        depth: circularReferenceDepth\n      })).map(t => {\n        return {\n          kind: graphql.Kind.INLINE_FRAGMENT,\n          typeCondition: {\n            kind: graphql.Kind.NAMED_TYPE,\n            name: {\n              kind: graphql.Kind.NAME,\n              value: t.name\n            }\n          },\n          selectionSet: resolveSelectionSet({\n            parent: type,\n            type: t,\n            models,\n            path,\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields,\n            rootTypeNames\n          })\n        };\n      }).filter(fragmentNode => {\n        var _a, _b;\n\n        return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;\n      })\n    };\n  }\n\n  if (graphql.isObjectType(type) && !rootTypeNames.has(type.name)) {\n    const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);\n    const isModel = models.includes(type.name);\n\n    if (!firstCall && isModel && !isIgnored) {\n      return {\n        kind: graphql.Kind.SELECTION_SET,\n        selections: [{\n          kind: graphql.Kind.FIELD,\n          name: {\n            kind: graphql.Kind.NAME,\n            value: 'id'\n          }\n        }]\n      };\n    }\n\n    const fields = type.getFields();\n    return {\n      kind: graphql.Kind.SELECTION_SET,\n      selections: Object.keys(fields).filter(fieldName => {\n        return !hasCircularRef([...ancestors, graphql.getNamedType(fields[fieldName].type)], {\n          depth: circularReferenceDepth\n        });\n      }).map(fieldName => {\n        const selectedSubFields = typeof selectedFields === 'object' ? selectedFields[fieldName] : true;\n\n        if (selectedSubFields) {\n          return resolveField({\n            type: type,\n            field: fields[fieldName],\n            models,\n            path: [...path, fieldName],\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields: selectedSubFields,\n            rootTypeNames\n          });\n        }\n\n        return null;\n      }).filter(f => {\n        var _a, _b;\n\n        if (f == null) {\n          return false;\n        } else if ('selectionSet' in f) {\n          return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);\n        }\n\n        return true;\n      })\n    };\n  }\n}\n\nfunction resolveVariable(arg, name) {\n  function resolveVariableType(type) {\n    if (graphql.isListType(type)) {\n      return {\n        kind: graphql.Kind.LIST_TYPE,\n        type: resolveVariableType(type.ofType)\n      };\n    }\n\n    if (graphql.isNonNullType(type)) {\n      return {\n        kind: graphql.Kind.NON_NULL_TYPE,\n        // for v16 compatibility\n        type: resolveVariableType(type.ofType)\n      };\n    }\n\n    return {\n      kind: graphql.Kind.NAMED_TYPE,\n      name: {\n        kind: graphql.Kind.NAME,\n        value: type.name\n      }\n    };\n  }\n\n  return {\n    kind: graphql.Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: graphql.Kind.VARIABLE,\n      name: {\n        kind: graphql.Kind.NAME,\n        value: name || arg.name\n      }\n    },\n    type: resolveVariableType(arg.type)\n  };\n}\n\nfunction getArgumentName(name, path) {\n  return [...path, name].join('_');\n}\n\nfunction resolveField(_ref44) {\n  let {\n    type,\n    field,\n    models,\n    firstCall,\n    path,\n    ancestors,\n    ignore,\n    depthLimit,\n    circularReferenceDepth,\n    schema,\n    depth,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  } = _ref44;\n  const namedType = graphql.getNamedType(field.type);\n  let args = [];\n  let removeField = false;\n\n  if (field.args && field.args.length) {\n    args = field.args.map(arg => {\n      const argumentName = getArgumentName(arg.name, path);\n\n      if (argNames && !argNames.includes(argumentName)) {\n        if (graphql.isNonNullType(arg.type)) {\n          removeField = true;\n        }\n\n        return null;\n      }\n\n      if (!firstCall) {\n        addOperationVariable(resolveVariable(arg, argumentName));\n      }\n\n      return {\n        kind: graphql.Kind.ARGUMENT,\n        name: {\n          kind: graphql.Kind.NAME,\n          value: arg.name\n        },\n        value: {\n          kind: graphql.Kind.VARIABLE,\n          name: {\n            kind: graphql.Kind.NAME,\n            value: getArgumentName(arg.name, path)\n          }\n        }\n      };\n    }).filter(Boolean);\n  }\n\n  if (removeField) {\n    return null;\n  }\n\n  const fieldPath = [...path, field.name];\n  const fieldPathStr = fieldPath.join('.');\n  let fieldName = field.name;\n\n  if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {\n    fieldName += field.type.toString().replace('!', 'NonNull');\n  }\n\n  fieldTypeMap.set(fieldPathStr, field.type.toString());\n\n  if (!graphql.isScalarType(namedType) && !graphql.isEnumType(namedType)) {\n    return {\n      kind: graphql.Kind.FIELD,\n      name: {\n        kind: graphql.Kind.NAME,\n        value: field.name\n      },\n      ...(fieldName !== field.name && {\n        alias: {\n          kind: graphql.Kind.NAME,\n          value: fieldName\n        }\n      }),\n      selectionSet: resolveSelectionSet({\n        parent: type,\n        type: namedType,\n        models,\n        firstCall,\n        path: fieldPath,\n        ancestors: [...ancestors, type],\n        ignore,\n        depthLimit,\n        circularReferenceDepth,\n        schema,\n        depth: depth + 1,\n        argNames,\n        selectedFields,\n        rootTypeNames\n      }) || undefined,\n      arguments: args\n    };\n  }\n\n  return {\n    kind: graphql.Kind.FIELD,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: field.name\n    },\n    ...(fieldName !== field.name && {\n      alias: {\n        kind: graphql.Kind.NAME,\n        value: fieldName\n      }\n    }),\n    arguments: args\n  };\n}\n\nfunction hasCircularRef(types) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    depth: 1\n  };\n  const type = types[types.length - 1];\n\n  if (graphql.isScalarType(type)) {\n    return false;\n  }\n\n  const size = types.filter(t => t.name === type.name).length;\n  return size > config.depth;\n}\n\n(function (MapperKind) {\n  MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\n  MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\n  MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\n  MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\n  MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\n  MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\n  MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\n  MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\n  MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\n  MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\n  MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\n  MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\n  MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\n  MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\n  MapperKind[\"FIELD\"] = \"MapperKind.FIELD\";\n  MapperKind[\"COMPOSITE_FIELD\"] = \"MapperKind.COMPOSITE_FIELD\";\n  MapperKind[\"OBJECT_FIELD\"] = \"MapperKind.OBJECT_FIELD\";\n  MapperKind[\"ROOT_FIELD\"] = \"MapperKind.ROOT_FIELD\";\n  MapperKind[\"QUERY_ROOT_FIELD\"] = \"MapperKind.QUERY_ROOT_FIELD\";\n  MapperKind[\"MUTATION_ROOT_FIELD\"] = \"MapperKind.MUTATION_ROOT_FIELD\";\n  MapperKind[\"SUBSCRIPTION_ROOT_FIELD\"] = \"MapperKind.SUBSCRIPTION_ROOT_FIELD\";\n  MapperKind[\"INTERFACE_FIELD\"] = \"MapperKind.INTERFACE_FIELD\";\n  MapperKind[\"INPUT_OBJECT_FIELD\"] = \"MapperKind.INPUT_OBJECT_FIELD\";\n  MapperKind[\"ARGUMENT\"] = \"MapperKind.ARGUMENT\";\n  MapperKind[\"ENUM_VALUE\"] = \"MapperKind.ENUM_VALUE\";\n})(exports.MapperKind || (exports.MapperKind = {}));\n\nfunction getObjectTypeFromTypeMap(typeMap, type) {\n  if (type) {\n    const maybeObjectType = typeMap[type.name];\n\n    if (graphql.isObjectType(maybeObjectType)) {\n      return maybeObjectType;\n    }\n  }\n}\n\nfunction createNamedStub(name, type) {\n  let constructor;\n\n  if (type === 'object') {\n    constructor = graphql.GraphQLObjectType;\n  } else if (type === 'interface') {\n    constructor = graphql.GraphQLInterfaceType;\n  } else {\n    constructor = graphql.GraphQLInputObjectType;\n  }\n\n  return new constructor({\n    name,\n    fields: {\n      _fake: {\n        type: graphql.GraphQLString\n      }\n    }\n  });\n}\n\nfunction createStub(node, type) {\n  switch (node.kind) {\n    case graphql.Kind.LIST_TYPE:\n      return new graphql.GraphQLList(createStub(node.type, type));\n\n    case graphql.Kind.NON_NULL_TYPE:\n      return new graphql.GraphQLNonNull(createStub(node.type, type));\n\n    default:\n      if (type === 'output') {\n        return createNamedStub(node.name.value, 'object');\n      }\n\n      return createNamedStub(node.name.value, 'input');\n  }\n}\n\nfunction isNamedStub(type) {\n  if ('getFields' in type) {\n    const fields = type.getFields(); // eslint-disable-next-line no-unreachable-loop\n\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      return field.name === '_fake';\n    }\n  }\n\n  return false;\n}\n\nfunction getBuiltInForStub(type) {\n  switch (type.name) {\n    case graphql.GraphQLInt.name:\n      return graphql.GraphQLInt;\n\n    case graphql.GraphQLFloat.name:\n      return graphql.GraphQLFloat;\n\n    case graphql.GraphQLString.name:\n      return graphql.GraphQLString;\n\n    case graphql.GraphQLBoolean.name:\n      return graphql.GraphQLBoolean;\n\n    case graphql.GraphQLID.name:\n      return graphql.GraphQLID;\n\n    default:\n      return type;\n  }\n}\n\nfunction rewireTypes(originalTypeMap, directives) {\n  const referenceTypeMap = Object.create(null);\n\n  for (const typeName in originalTypeMap) {\n    referenceTypeMap[typeName] = originalTypeMap[typeName];\n  }\n\n  const newTypeMap = Object.create(null);\n\n  for (const typeName in referenceTypeMap) {\n    const namedType = referenceTypeMap[typeName];\n\n    if (namedType == null || typeName.startsWith('__')) {\n      continue;\n    }\n\n    const newName = namedType.name;\n\n    if (newName.startsWith('__')) {\n      continue;\n    }\n\n    if (newTypeMap[newName] != null) {\n      throw new Error(`Duplicate schema type name ${newName}`);\n    }\n\n    newTypeMap[newName] = namedType;\n  }\n\n  for (const typeName in newTypeMap) {\n    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n  }\n\n  const newDirectives = directives.map(directive => rewireDirective(directive));\n  return {\n    typeMap: newTypeMap,\n    directives: newDirectives\n  };\n\n  function rewireDirective(directive) {\n    if (graphql.isSpecifiedDirective(directive)) {\n      return directive;\n    }\n\n    const directiveConfig = directive.toConfig();\n    directiveConfig.args = rewireArgs(directiveConfig.args);\n    return new graphql.GraphQLDirective(directiveConfig);\n  }\n\n  function rewireArgs(args) {\n    const rewiredArgs = {};\n\n    for (const argName in args) {\n      const arg = args[argName];\n      const rewiredArgType = rewireType(arg.type);\n\n      if (rewiredArgType != null) {\n        arg.type = rewiredArgType;\n        rewiredArgs[argName] = arg;\n      }\n    }\n\n    return rewiredArgs;\n  }\n\n  function rewireNamedType(type) {\n    if (graphql.isObjectType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        fields: () => rewireFields(config.fields),\n        interfaces: () => rewireNamedTypes(config.interfaces)\n      };\n      return new graphql.GraphQLObjectType(newConfig);\n    } else if (graphql.isInterfaceType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        fields: () => rewireFields(config.fields)\n      };\n\n      if ('interfaces' in newConfig) {\n        newConfig.interfaces = () => rewireNamedTypes(config.interfaces);\n      }\n\n      return new graphql.GraphQLInterfaceType(newConfig);\n    } else if (graphql.isUnionType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        types: () => rewireNamedTypes(config.types)\n      };\n      return new graphql.GraphQLUnionType(newConfig);\n    } else if (graphql.isInputObjectType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        fields: () => rewireInputFields(config.fields)\n      };\n      return new graphql.GraphQLInputObjectType(newConfig);\n    } else if (graphql.isEnumType(type)) {\n      const enumConfig = type.toConfig();\n      return new graphql.GraphQLEnumType(enumConfig);\n    } else if (graphql.isScalarType(type)) {\n      if (graphql.isSpecifiedScalarType(type)) {\n        return type;\n      }\n\n      const scalarConfig = type.toConfig();\n      return new graphql.GraphQLScalarType(scalarConfig);\n    }\n\n    throw new Error(`Unexpected schema type: ${type}`);\n  }\n\n  function rewireFields(fields) {\n    const rewiredFields = {};\n\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n\n      if (rewiredFieldType != null && field.args) {\n        field.type = rewiredFieldType;\n        field.args = rewireArgs(field.args);\n        rewiredFields[fieldName] = field;\n      }\n    }\n\n    return rewiredFields;\n  }\n\n  function rewireInputFields(fields) {\n    const rewiredFields = {};\n\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n\n      if (rewiredFieldType != null) {\n        field.type = rewiredFieldType;\n        rewiredFields[fieldName] = field;\n      }\n    }\n\n    return rewiredFields;\n  }\n\n  function rewireNamedTypes(namedTypes) {\n    const rewiredTypes = [];\n\n    for (const namedType of namedTypes) {\n      const rewiredType = rewireType(namedType);\n\n      if (rewiredType != null) {\n        rewiredTypes.push(rewiredType);\n      }\n    }\n\n    return rewiredTypes;\n  }\n\n  function rewireType(type) {\n    if (graphql.isListType(type)) {\n      const rewiredType = rewireType(type.ofType);\n      return rewiredType != null ? new graphql.GraphQLList(rewiredType) : null;\n    } else if (graphql.isNonNullType(type)) {\n      const rewiredType = rewireType(type.ofType);\n      return rewiredType != null ? new graphql.GraphQLNonNull(rewiredType) : null;\n    } else if (graphql.isNamedType(type)) {\n      let rewiredType = referenceTypeMap[type.name];\n\n      if (rewiredType === undefined) {\n        rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);\n        newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;\n      }\n\n      return rewiredType != null ? newTypeMap[rewiredType.name] : null;\n    }\n\n    return null;\n  }\n}\n\nfunction transformInputValue(type, value) {\n  let inputLeafValueTransformer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let inputObjectValueTransformer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  if (value == null) {\n    return value;\n  }\n\n  const nullableType = graphql.getNullableType(type);\n\n  if (graphql.isLeafType(nullableType)) {\n    return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;\n  } else if (graphql.isListType(nullableType)) {\n    return value.map(listMember => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));\n  } else if (graphql.isInputObjectType(nullableType)) {\n    const fields = nullableType.getFields();\n    const newValue = {};\n\n    for (const key in value) {\n      const field = fields[key];\n\n      if (field != null) {\n        newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);\n      }\n    }\n\n    return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;\n  } // unreachable, no other possible return value\n\n}\n\nfunction serializeInputValue(type, value) {\n  return transformInputValue(type, value, (t, v) => {\n    try {\n      return t.serialize(v);\n    } catch (_a) {\n      return v;\n    }\n  });\n}\n\nfunction parseInputValue(type, value) {\n  return transformInputValue(type, value, (t, v) => {\n    try {\n      return t.parseValue(v);\n    } catch (_a) {\n      return v;\n    }\n  });\n}\n\nfunction parseInputValueLiteral(type, value) {\n  return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));\n}\n\nfunction mapSchema(schema) {\n  let schemaMapper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, type => graphql.isLeafType(type)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, type => !graphql.isLeafType(type)), schema, schemaMapper), schema, schemaMapper);\n  const originalDirectives = schema.getDirectives();\n  const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n  const {\n    typeMap,\n    directives\n  } = rewireTypes(newTypeMap, newDirectives);\n  return new graphql.GraphQLSchema({ ...schema.toConfig(),\n    query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),\n    mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),\n    subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),\n    types: Object.values(typeMap),\n    directives\n  });\n}\n\nfunction mapTypes(originalTypeMap, schema, schemaMapper) {\n  let testFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => true;\n  const newTypeMap = {};\n\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n\n      if (originalType == null || !testFn(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n\n      if (typeMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const maybeNewType = typeMapper(originalType, schema);\n\n      if (maybeNewType === undefined) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      newTypeMap[typeName] = maybeNewType;\n    }\n  }\n\n  return newTypeMap;\n}\n\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n  const enumValueMapper = getEnumValueMapper(schemaMapper);\n\n  if (!enumValueMapper) {\n    return originalTypeMap;\n  }\n\n  return mapTypes(originalTypeMap, schema, {\n    [exports.MapperKind.ENUM_TYPE]: type => {\n      const config = type.toConfig();\n      const originalEnumValueConfigMap = config.values;\n      const newEnumValueConfigMap = {};\n\n      for (const externalValue in originalEnumValueConfigMap) {\n        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n\n        if (mappedEnumValue === undefined) {\n          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n        } else if (Array.isArray(mappedEnumValue)) {\n          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;\n          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n        } else if (mappedEnumValue !== null) {\n          newEnumValueConfigMap[externalValue] = mappedEnumValue;\n        }\n      }\n\n      return correctASTNodes(new graphql.GraphQLEnumType({ ...config,\n        values: newEnumValueConfigMap\n      }));\n    }\n  }, type => graphql.isEnumType(type));\n}\n\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n  const newTypeMap = mapArguments(originalTypeMap, schema, {\n    [exports.MapperKind.ARGUMENT]: argumentConfig => {\n      if (argumentConfig.defaultValue === undefined) {\n        return argumentConfig;\n      }\n\n      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n\n      if (maybeNewType != null) {\n        return { ...argumentConfig,\n          defaultValue: fn(maybeNewType, argumentConfig.defaultValue)\n        };\n      }\n    }\n  });\n  return mapFields(newTypeMap, schema, {\n    [exports.MapperKind.INPUT_OBJECT_FIELD]: inputFieldConfig => {\n      if (inputFieldConfig.defaultValue === undefined) {\n        return inputFieldConfig;\n      }\n\n      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n\n      if (maybeNewType != null) {\n        return { ...inputFieldConfig,\n          defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)\n        };\n      }\n    }\n  });\n}\n\nfunction getNewType(newTypeMap, type) {\n  if (graphql.isListType(type)) {\n    const newType = getNewType(newTypeMap, type.ofType);\n    return newType != null ? new graphql.GraphQLList(newType) : null;\n  } else if (graphql.isNonNullType(type)) {\n    const newType = getNewType(newTypeMap, type.ofType);\n    return newType != null ? new graphql.GraphQLNonNull(newType) : null;\n  } else if (graphql.isNamedType(type)) {\n    const newType = newTypeMap[type.name];\n    return newType != null ? newType : null;\n  }\n\n  return null;\n}\n\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n  const newTypeMap = {};\n\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n\n      if (!graphql.isObjectType(originalType) && !graphql.isInterfaceType(originalType) && !graphql.isInputObjectType(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n\n      if (fieldMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const config = originalType.toConfig();\n      const originalFieldConfigMap = config.fields;\n      const newFieldConfigMap = {};\n\n      for (const fieldName in originalFieldConfigMap) {\n        const originalFieldConfig = originalFieldConfigMap[fieldName];\n        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n\n        if (mappedField === undefined) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n        } else if (Array.isArray(mappedField)) {\n          const [newFieldName, newFieldConfig] = mappedField;\n\n          if (newFieldConfig.astNode != null) {\n            newFieldConfig.astNode = { ...newFieldConfig.astNode,\n              name: { ...newFieldConfig.astNode.name,\n                value: newFieldName\n              }\n            };\n          }\n\n          newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n        } else if (mappedField !== null) {\n          newFieldConfigMap[fieldName] = mappedField;\n        }\n      }\n\n      if (graphql.isObjectType(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      } else if (graphql.isInterfaceType(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLInterfaceType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      } else {\n        newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLInputObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  }\n\n  return newTypeMap;\n}\n\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n  const newTypeMap = {};\n\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n\n      if (!graphql.isObjectType(originalType) && !graphql.isInterfaceType(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const argumentMapper = getArgumentMapper(schemaMapper);\n\n      if (argumentMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n\n      const config = originalType.toConfig();\n      const originalFieldConfigMap = config.fields;\n      const newFieldConfigMap = {};\n\n      for (const fieldName in originalFieldConfigMap) {\n        const originalFieldConfig = originalFieldConfigMap[fieldName];\n        const originalArgumentConfigMap = originalFieldConfig.args;\n\n        if (originalArgumentConfigMap == null) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          continue;\n        }\n\n        const argumentNames = Object.keys(originalArgumentConfigMap);\n\n        if (!argumentNames.length) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          continue;\n        }\n\n        const newArgumentConfigMap = {};\n\n        for (const argumentName of argumentNames) {\n          const originalArgumentConfig = originalArgumentConfigMap[argumentName];\n          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n\n          if (mappedArgument === undefined) {\n            newArgumentConfigMap[argumentName] = originalArgumentConfig;\n          } else if (Array.isArray(mappedArgument)) {\n            const [newArgumentName, newArgumentConfig] = mappedArgument;\n            newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n          } else if (mappedArgument !== null) {\n            newArgumentConfigMap[argumentName] = mappedArgument;\n          }\n        }\n\n        newFieldConfigMap[fieldName] = { ...originalFieldConfig,\n          args: newArgumentConfigMap\n        };\n      }\n\n      if (graphql.isObjectType(originalType)) {\n        newTypeMap[typeName] = new graphql.GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        });\n      } else if (graphql.isInterfaceType(originalType)) {\n        newTypeMap[typeName] = new graphql.GraphQLInterfaceType({ ...config,\n          fields: newFieldConfigMap\n        });\n      } else {\n        newTypeMap[typeName] = new graphql.GraphQLInputObjectType({ ...config,\n          fields: newFieldConfigMap\n        });\n      }\n    }\n  }\n\n  return newTypeMap;\n}\n\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n  const directiveMapper = getDirectiveMapper(schemaMapper);\n\n  if (directiveMapper == null) {\n    return originalDirectives.slice();\n  }\n\n  const newDirectives = [];\n\n  for (const directive of originalDirectives) {\n    const mappedDirective = directiveMapper(directive, schema);\n\n    if (mappedDirective === undefined) {\n      newDirectives.push(directive);\n    } else if (mappedDirective !== null) {\n      newDirectives.push(mappedDirective);\n    }\n  }\n\n  return newDirectives;\n}\n\nfunction getTypeSpecifiers(schema, typeName) {\n  var _a, _b, _c;\n\n  const type = schema.getType(typeName);\n  const specifiers = [exports.MapperKind.TYPE];\n\n  if (graphql.isObjectType(type)) {\n    specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.OBJECT_TYPE);\n\n    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n      specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.QUERY);\n    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n      specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.MUTATION);\n    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n      specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.SUBSCRIPTION);\n    }\n  } else if (graphql.isInputObjectType(type)) {\n    specifiers.push(exports.MapperKind.INPUT_OBJECT_TYPE);\n  } else if (graphql.isInterfaceType(type)) {\n    specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.ABSTRACT_TYPE, exports.MapperKind.INTERFACE_TYPE);\n  } else if (graphql.isUnionType(type)) {\n    specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.ABSTRACT_TYPE, exports.MapperKind.UNION_TYPE);\n  } else if (graphql.isEnumType(type)) {\n    specifiers.push(exports.MapperKind.ENUM_TYPE);\n  } else if (graphql.isScalarType(type)) {\n    specifiers.push(exports.MapperKind.SCALAR_TYPE);\n  }\n\n  return specifiers;\n}\n\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n  const specifiers = getTypeSpecifiers(schema, typeName);\n  let typeMapper;\n  const stack = [...specifiers];\n\n  while (!typeMapper && stack.length > 0) {\n    // It is safe to use the ! operator here as we check the length.\n    const next = stack.pop();\n    typeMapper = schemaMapper[next];\n  }\n\n  return typeMapper != null ? typeMapper : null;\n}\n\nfunction getFieldSpecifiers(schema, typeName) {\n  var _a, _b, _c;\n\n  const type = schema.getType(typeName);\n  const specifiers = [exports.MapperKind.FIELD];\n\n  if (graphql.isObjectType(type)) {\n    specifiers.push(exports.MapperKind.COMPOSITE_FIELD, exports.MapperKind.OBJECT_FIELD);\n\n    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n      specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.QUERY_ROOT_FIELD);\n    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n      specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.MUTATION_ROOT_FIELD);\n    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n      specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.SUBSCRIPTION_ROOT_FIELD);\n    }\n  } else if (graphql.isInterfaceType(type)) {\n    specifiers.push(exports.MapperKind.COMPOSITE_FIELD, exports.MapperKind.INTERFACE_FIELD);\n  } else if (graphql.isInputObjectType(type)) {\n    specifiers.push(exports.MapperKind.INPUT_OBJECT_FIELD);\n  }\n\n  return specifiers;\n}\n\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n  const specifiers = getFieldSpecifiers(schema, typeName);\n  let fieldMapper;\n  const stack = [...specifiers];\n\n  while (!fieldMapper && stack.length > 0) {\n    // It is safe to use the ! operator here as we check the length.\n    const next = stack.pop(); // TODO: fix this as unknown cast\n\n    fieldMapper = schemaMapper[next];\n  }\n\n  return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;\n}\n\nfunction getArgumentMapper(schemaMapper) {\n  const argumentMapper = schemaMapper[exports.MapperKind.ARGUMENT];\n  return argumentMapper != null ? argumentMapper : null;\n}\n\nfunction getDirectiveMapper(schemaMapper) {\n  const directiveMapper = schemaMapper[exports.MapperKind.DIRECTIVE];\n  return directiveMapper != null ? directiveMapper : null;\n}\n\nfunction getEnumValueMapper(schemaMapper) {\n  const enumValueMapper = schemaMapper[exports.MapperKind.ENUM_VALUE];\n  return enumValueMapper != null ? enumValueMapper : null;\n}\n\nfunction correctASTNodes(type) {\n  if (graphql.isObjectType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const fields = [];\n\n      for (const fieldName in config.fields) {\n        const fieldConfig = config.fields[fieldName];\n\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n\n      config.astNode = { ...config.astNode,\n        kind: graphql.Kind.OBJECT_TYPE_DEFINITION,\n        fields\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        kind: graphql.Kind.OBJECT_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n\n    return new graphql.GraphQLObjectType(config);\n  } else if (graphql.isInterfaceType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const fields = [];\n\n      for (const fieldName in config.fields) {\n        const fieldConfig = config.fields[fieldName];\n\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n\n      config.astNode = { ...config.astNode,\n        kind: graphql.Kind.INTERFACE_TYPE_DEFINITION,\n        fields\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        kind: graphql.Kind.INTERFACE_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n\n    return new graphql.GraphQLInterfaceType(config);\n  } else if (graphql.isInputObjectType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const fields = [];\n\n      for (const fieldName in config.fields) {\n        const fieldConfig = config.fields[fieldName];\n\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n\n      config.astNode = { ...config.astNode,\n        kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        fields\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        kind: graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n\n    return new graphql.GraphQLInputObjectType(config);\n  } else if (graphql.isEnumType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const values = [];\n\n      for (const enumKey in config.values) {\n        const enumValueConfig = config.values[enumKey];\n\n        if (enumValueConfig.astNode != null) {\n          values.push(enumValueConfig.astNode);\n        }\n      }\n\n      config.astNode = { ...config.astNode,\n        values\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        values: undefined\n      }));\n    }\n\n    return new graphql.GraphQLEnumType(config);\n  } else {\n    return type;\n  }\n}\n\nfunction filterSchema(_ref45) {\n  let {\n    schema,\n    typeFilter = () => true,\n    fieldFilter = undefined,\n    rootFieldFilter = undefined,\n    objectFieldFilter = undefined,\n    interfaceFieldFilter = undefined,\n    inputObjectFieldFilter = undefined,\n    argumentFilter = undefined\n  } = _ref45;\n  const filteredSchema = mapSchema(schema, {\n    [exports.MapperKind.QUERY]: type => filterRootFields(type, 'Query', rootFieldFilter, argumentFilter),\n    [exports.MapperKind.MUTATION]: type => filterRootFields(type, 'Mutation', rootFieldFilter, argumentFilter),\n    [exports.MapperKind.SUBSCRIPTION]: type => filterRootFields(type, 'Subscription', rootFieldFilter, argumentFilter),\n    [exports.MapperKind.OBJECT_TYPE]: type => typeFilter(type.name, type) ? filterElementFields(graphql.GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter) : null,\n    [exports.MapperKind.INTERFACE_TYPE]: type => typeFilter(type.name, type) ? filterElementFields(graphql.GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter) : null,\n    [exports.MapperKind.INPUT_OBJECT_TYPE]: type => typeFilter(type.name, type) ? filterElementFields(graphql.GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter) : null,\n    [exports.MapperKind.UNION_TYPE]: type => typeFilter(type.name, type) ? undefined : null,\n    [exports.MapperKind.ENUM_TYPE]: type => typeFilter(type.name, type) ? undefined : null,\n    [exports.MapperKind.SCALAR_TYPE]: type => typeFilter(type.name, type) ? undefined : null\n  });\n  return filteredSchema;\n}\n\nfunction filterRootFields(type, operation, rootFieldFilter, argumentFilter) {\n  if (rootFieldFilter || argumentFilter) {\n    const config = type.toConfig();\n\n    for (const fieldName in config.fields) {\n      const field = config.fields[fieldName];\n\n      if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {\n        delete config.fields[fieldName];\n      } else if (argumentFilter && field.args) {\n        for (const argName in field.args) {\n          if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {\n            delete field.args[argName];\n          }\n        }\n      }\n    }\n\n    return new graphql.GraphQLObjectType(config);\n  }\n\n  return type;\n}\n\nfunction filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {\n  if (fieldFilter || argumentFilter) {\n    const config = type.toConfig();\n\n    for (const fieldName in config.fields) {\n      const field = config.fields[fieldName];\n\n      if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {\n        delete config.fields[fieldName];\n      } else if (argumentFilter && 'args' in field) {\n        for (const argName in field.args) {\n          if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {\n            delete field.args[argName];\n          }\n        }\n      }\n    }\n\n    return new ElementConstructor(config);\n  }\n} // Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n//\n// healSchema and its callers (visitSchema/visitSchemaDirectives) all modify the schema in place.\n// Therefore, private variables (such as the stored implementation map and the proper root types)\n// are not updated.\n//\n// If this causes issues, the schema could be more aggressively healed as follows:\n//\n// healSchema(schema);\n// const config = schema.toConfig()\n// const healedSchema = new GraphQLSchema({\n//   ...config,\n//   query: schema.getType('<desired new root query type name>'),\n//   mutation: schema.getType('<desired new root mutation type name>'),\n//   subscription: schema.getType('<desired new root subscription type name>'),\n// });\n//\n// One can then also -- if necessary --  assign the correct private variables to the initial schema\n// as follows:\n// Object.assign(schema, healedSchema);\n//\n// These steps are not taken automatically to preserve backwards compatibility with graphql-tools v4.\n// See https://github.com/ardatan/graphql-tools/issues/1462\n//\n// They were briefly taken in v5, but can now be phased out as they were only required when other\n// areas of the codebase were using healSchema and visitSchema more extensively.\n//\n\n\nfunction healSchema(schema) {\n  healTypes(schema.getTypeMap(), schema.getDirectives());\n  return schema;\n}\n\nfunction healTypes(originalTypeMap, directives) {\n  const actualNamedTypeMap = Object.create(null); // If any of the .name properties of the GraphQLNamedType objects in\n  // schema.getTypeMap() have changed, the keys of the type map need to\n  // be updated accordingly.\n\n  for (const typeName in originalTypeMap) {\n    const namedType = originalTypeMap[typeName];\n\n    if (namedType == null || typeName.startsWith('__')) {\n      continue;\n    }\n\n    const actualName = namedType.name;\n\n    if (actualName.startsWith('__')) {\n      continue;\n    }\n\n    if (actualName in actualNamedTypeMap) {\n      throw new Error(`Duplicate schema type name ${actualName}`);\n    }\n\n    actualNamedTypeMap[actualName] = namedType; // Note: we are deliberately leaving namedType in the schema by its\n    // original name (which might be different from actualName), so that\n    // references by that name can be healed.\n  } // Now add back every named type by its actual name.\n\n\n  for (const typeName in actualNamedTypeMap) {\n    const namedType = actualNamedTypeMap[typeName];\n    originalTypeMap[typeName] = namedType;\n  } // Directive declaration argument types can refer to named types.\n\n\n  for (const decl of directives) {\n    decl.args = decl.args.filter(arg => {\n      arg.type = healType(arg.type);\n      return arg.type !== null;\n    });\n  }\n\n  for (const typeName in originalTypeMap) {\n    const namedType = originalTypeMap[typeName]; // Heal all named types, except for dangling references, kept only to redirect.\n\n    if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\n      if (namedType != null) {\n        healNamedType(namedType);\n      }\n    }\n  }\n\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\n      delete originalTypeMap[typeName];\n    }\n  }\n\n  function healNamedType(type) {\n    if (graphql.isObjectType(type)) {\n      healFields(type);\n      healInterfaces(type);\n      return;\n    } else if (graphql.isInterfaceType(type)) {\n      healFields(type);\n\n      if ('getInterfaces' in type) {\n        healInterfaces(type);\n      }\n\n      return;\n    } else if (graphql.isUnionType(type)) {\n      healUnderlyingTypes(type);\n      return;\n    } else if (graphql.isInputObjectType(type)) {\n      healInputFields(type);\n      return;\n    } else if (graphql.isLeafType(type)) {\n      return;\n    }\n\n    throw new Error(`Unexpected schema type: ${type}`);\n  }\n\n  function healFields(type) {\n    const fieldMap = type.getFields();\n\n    for (const [key, field] of Object.entries(fieldMap)) {\n      field.args.map(arg => {\n        arg.type = healType(arg.type);\n        return arg.type === null ? null : arg;\n      }).filter(Boolean);\n      field.type = healType(field.type);\n\n      if (field.type === null) {\n        delete fieldMap[key];\n      }\n    }\n  }\n\n  function healInterfaces(type) {\n    if ('getInterfaces' in type) {\n      const interfaces = type.getInterfaces();\n      interfaces.push(...interfaces.splice(0).map(iface => healType(iface)).filter(Boolean));\n    }\n  }\n\n  function healInputFields(type) {\n    const fieldMap = type.getFields();\n\n    for (const [key, field] of Object.entries(fieldMap)) {\n      field.type = healType(field.type);\n\n      if (field.type === null) {\n        delete fieldMap[key];\n      }\n    }\n  }\n\n  function healUnderlyingTypes(type) {\n    const types = type.getTypes();\n    types.push(...types.splice(0).map(t => healType(t)).filter(Boolean));\n  }\n\n  function healType(type) {\n    // Unwrap the two known wrapper types\n    if (graphql.isListType(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new graphql.GraphQLList(healedType) : null;\n    } else if (graphql.isNonNullType(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new graphql.GraphQLNonNull(healedType) : null;\n    } else if (graphql.isNamedType(type)) {\n      // If a type annotation on a field or an argument or a union member is\n      // any `GraphQLNamedType` with a `name`, then it must end up identical\n      // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n      // of truth for all named schema types.\n      // Note that new types can still be simply added by adding a field, as\n      // the official type will be undefined, not null.\n      const officialType = originalTypeMap[type.name];\n\n      if (officialType && type !== officialType) {\n        return officialType;\n      }\n    }\n\n    return type;\n  }\n}\n\nfunction getResolversFromSchema(schema) {\n  var _a, _b;\n\n  const resolvers = Object.create(null);\n  const typeMap = schema.getTypeMap();\n\n  for (const typeName in typeMap) {\n    if (!typeName.startsWith('__')) {\n      const type = typeMap[typeName];\n\n      if (graphql.isScalarType(type)) {\n        if (!graphql.isSpecifiedScalarType(type)) {\n          const config = type.toConfig();\n          delete config.astNode; // avoid AST duplication elsewhere\n\n          resolvers[typeName] = new graphql.GraphQLScalarType(config);\n        }\n      } else if (graphql.isEnumType(type)) {\n        resolvers[typeName] = {};\n        const values = type.getValues();\n\n        for (const value of values) {\n          resolvers[typeName][value.name] = value.value;\n        }\n      } else if (graphql.isInterfaceType(type)) {\n        if (type.resolveType != null) {\n          resolvers[typeName] = {\n            __resolveType: type.resolveType\n          };\n        }\n      } else if (graphql.isUnionType(type)) {\n        if (type.resolveType != null) {\n          resolvers[typeName] = {\n            __resolveType: type.resolveType\n          };\n        }\n      } else if (graphql.isObjectType(type)) {\n        resolvers[typeName] = {};\n\n        if (type.isTypeOf != null) {\n          resolvers[typeName].__isTypeOf = type.isTypeOf;\n        }\n\n        const fields = type.getFields();\n\n        for (const fieldName in fields) {\n          const field = fields[fieldName];\n\n          if (field.subscribe != null) {\n            resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};\n            resolvers[typeName][fieldName].subscribe = field.subscribe;\n          }\n\n          if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== 'defaultFieldResolver' && ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) !== 'defaultMergedResolver') {\n            resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};\n            resolvers[typeName][fieldName].resolve = field.resolve;\n          }\n        }\n      }\n    }\n  }\n\n  return resolvers;\n}\n\nfunction forEachField(schema, fn) {\n  const typeMap = schema.getTypeMap();\n\n  for (const typeName in typeMap) {\n    const type = typeMap[typeName]; // TODO: maybe have an option to include these?\n\n    if (!graphql.getNamedType(type).name.startsWith('__') && graphql.isObjectType(type)) {\n      const fields = type.getFields();\n\n      for (const fieldName in fields) {\n        const field = fields[fieldName];\n        fn(field, typeName, fieldName);\n      }\n    }\n  }\n}\n\nfunction forEachDefaultValue(schema, fn) {\n  const typeMap = schema.getTypeMap();\n\n  for (const typeName in typeMap) {\n    const type = typeMap[typeName];\n\n    if (!graphql.getNamedType(type).name.startsWith('__')) {\n      if (graphql.isObjectType(type)) {\n        const fields = type.getFields();\n\n        for (const fieldName in fields) {\n          const field = fields[fieldName];\n\n          for (const arg of field.args) {\n            arg.defaultValue = fn(arg.type, arg.defaultValue);\n          }\n        }\n      } else if (graphql.isInputObjectType(type)) {\n        const fields = type.getFields();\n\n        for (const fieldName in fields) {\n          const field = fields[fieldName];\n          field.defaultValue = fn(field.type, field.defaultValue);\n        }\n      }\n    }\n  }\n} // addTypes uses toConfig to create a new schema with a new or replaced\n\n\nfunction addTypes(schema, newTypesOrDirectives) {\n  const config = schema.toConfig();\n  const originalTypeMap = {};\n\n  for (const type of config.types) {\n    originalTypeMap[type.name] = type;\n  }\n\n  const originalDirectiveMap = {};\n\n  for (const directive of config.directives) {\n    originalDirectiveMap[directive.name] = directive;\n  }\n\n  for (const newTypeOrDirective of newTypesOrDirectives) {\n    if (graphql.isNamedType(newTypeOrDirective)) {\n      originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;\n    } else if (graphql.isDirective(newTypeOrDirective)) {\n      originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;\n    }\n  }\n\n  const {\n    typeMap,\n    directives\n  } = rewireTypes(originalTypeMap, Object.values(originalDirectiveMap));\n  return new graphql.GraphQLSchema({ ...config,\n    query: getObjectTypeFromTypeMap(typeMap, schema.getQueryType()),\n    mutation: getObjectTypeFromTypeMap(typeMap, schema.getMutationType()),\n    subscription: getObjectTypeFromTypeMap(typeMap, schema.getSubscriptionType()),\n    types: Object.values(typeMap),\n    directives\n  });\n}\n/**\n * Prunes the provided schema, removing unused and empty types\n * @param schema The schema to prune\n * @param options Additional options for removing unused types from the schema\n */\n\n\nfunction pruneSchema(schema) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    skipEmptyCompositeTypePruning,\n    skipEmptyUnionPruning,\n    skipPruning,\n    skipUnimplementedInterfacesPruning,\n    skipUnusedTypesPruning\n  } = options;\n  let prunedTypes = []; // Pruned types during mapping\n\n  let prunedSchema = schema;\n\n  do {\n    let visited = visitSchema(prunedSchema); // Custom pruning  was defined, so we need to pre-emptively revisit the schema accounting for this\n\n    if (skipPruning) {\n      const revisit = [];\n\n      for (const typeName in prunedSchema.getTypeMap()) {\n        if (typeName.startsWith('__')) {\n          continue;\n        }\n\n        const type = prunedSchema.getType(typeName); // if we want to skip pruning for this type, add it to the list of types to revisit\n\n        if (type && skipPruning(type)) {\n          revisit.push(typeName);\n        }\n      }\n\n      visited = visitQueue(revisit, prunedSchema, visited); // visit again\n    }\n\n    prunedTypes = [];\n    prunedSchema = mapSchema(prunedSchema, {\n      [exports.MapperKind.TYPE]: type => {\n        if (!visited.has(type.name) && !graphql.isSpecifiedScalarType(type)) {\n          if (graphql.isUnionType(type) || graphql.isInputObjectType(type) || graphql.isInterfaceType(type) || graphql.isObjectType(type) || graphql.isScalarType(type)) {\n            // skipUnusedTypesPruning: skip pruning unused types\n            if (skipUnusedTypesPruning) {\n              return type;\n            } // skipEmptyUnionPruning: skip pruning empty unions\n\n\n            if (graphql.isUnionType(type) && skipEmptyUnionPruning && !Object.keys(type.getTypes()).length) {\n              return type;\n            }\n\n            if (graphql.isInputObjectType(type) || graphql.isInterfaceType(type) || graphql.isObjectType(type)) {\n              // skipEmptyCompositeTypePruning: skip pruning object types or interfaces with no fields\n              if (skipEmptyCompositeTypePruning && !Object.keys(type.getFields()).length) {\n                return type;\n              }\n            } // skipUnimplementedInterfacesPruning: skip pruning interfaces that are not implemented by any other types\n\n\n            if (graphql.isInterfaceType(type) && skipUnimplementedInterfacesPruning) {\n              return type;\n            }\n          }\n\n          prunedTypes.push(type.name);\n          visited.delete(type.name);\n          return null;\n        }\n\n        return type;\n      }\n    });\n  } while (prunedTypes.length); // Might have empty types and need to prune again\n\n\n  return prunedSchema;\n}\n\nfunction visitSchema(schema) {\n  const queue = []; // queue of nodes to visit\n  // Grab the root types and start there\n\n  for (const type of getRootTypes(schema)) {\n    queue.push(type.name);\n  }\n\n  return visitQueue(queue, schema);\n}\n\nfunction visitQueue(queue, schema) {\n  let visited = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n\n  // Navigate all types starting with pre-queued types (root types)\n  while (queue.length) {\n    const typeName = queue.pop(); // Skip types we already visited\n\n    if (visited.has(typeName)) {\n      continue;\n    }\n\n    const type = schema.getType(typeName);\n\n    if (type) {\n      // Get types for union\n      if (graphql.isUnionType(type)) {\n        queue.push(...type.getTypes().map(type => type.name));\n      } // If the type has files visit those field types\n\n\n      if ('getFields' in type) {\n        const fields = type.getFields();\n        const entries = Object.entries(fields);\n\n        if (!entries.length) {\n          continue;\n        }\n\n        for (const [, field] of entries) {\n          if (graphql.isObjectType(type)) {\n            for (const arg of field.args) {\n              queue.push(graphql.getNamedType(arg.type).name); // Visit arg types\n            }\n          }\n\n          queue.push(graphql.getNamedType(field.type).name);\n        }\n      } // Visit interfaces this type is implementing if they haven't been visited yet\n\n\n      if ('getInterfaces' in type) {\n        queue.push(...type.getInterfaces().map(iface => iface.name));\n      }\n\n      visited.add(typeName); // Mark as visited (and therefore it is used and should be kept)\n    }\n  }\n\n  return visited;\n}\n\nfunction mergeDeep(sources) {\n  let respectPrototype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const target = sources[0] || {};\n  const output = {};\n\n  if (respectPrototype) {\n    Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));\n  }\n\n  for (const source of sources) {\n    if (isObject(target) && isObject(source)) {\n      if (respectPrototype) {\n        const outputPrototype = Object.getPrototypeOf(output);\n        const sourcePrototype = Object.getPrototypeOf(source);\n\n        if (sourcePrototype) {\n          for (const key of Object.getOwnPropertyNames(sourcePrototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);\n\n            if (isSome(descriptor)) {\n              Object.defineProperty(outputPrototype, key, descriptor);\n            }\n          }\n        }\n      }\n\n      for (const key in source) {\n        if (isObject(source[key])) {\n          if (!(key in output)) {\n            Object.assign(output, {\n              [key]: source[key]\n            });\n          } else {\n            output[key] = mergeDeep([output[key], source[key]], respectPrototype);\n          }\n        } else {\n          Object.assign(output, {\n            [key]: source[key]\n          });\n        }\n      }\n    }\n  }\n\n  return output;\n}\n\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n\nfunction parseSelectionSet(selectionSet, options) {\n  const query = graphql.parse(selectionSet, options).definitions[0];\n  return query.selectionSet;\n}\n/**\n * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just\n * resolves aliases.\n * @param info The info argument to the resolver.\n */\n\n\nfunction getResponseKeyFromInfo(info) {\n  return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;\n}\n\nfunction appendObjectFields(schema, typeName, additionalFields) {\n  if (schema.getType(typeName) == null) {\n    return addTypes(schema, [new graphql.GraphQLObjectType({\n      name: typeName,\n      fields: additionalFields\n    })]);\n  }\n\n  return mapSchema(schema, {\n    [exports.MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n        const newFieldConfigMap = {};\n\n        for (const fieldName in originalFieldConfigMap) {\n          newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];\n        }\n\n        for (const fieldName in additionalFields) {\n          newFieldConfigMap[fieldName] = additionalFields[fieldName];\n        }\n\n        return correctASTNodes(new graphql.GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  });\n}\n\nfunction removeObjectFields(schema, typeName, testFn) {\n  const removedFields = {};\n  const newSchema = mapSchema(schema, {\n    [exports.MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n        const newFieldConfigMap = {};\n\n        for (const fieldName in originalFieldConfigMap) {\n          const originalFieldConfig = originalFieldConfigMap[fieldName];\n\n          if (testFn(fieldName, originalFieldConfig)) {\n            removedFields[fieldName] = originalFieldConfig;\n          } else {\n            newFieldConfigMap[fieldName] = originalFieldConfig;\n          }\n        }\n\n        return correctASTNodes(new graphql.GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  });\n  return [newSchema, removedFields];\n}\n\nfunction selectObjectFields(schema, typeName, testFn) {\n  const selectedFields = {};\n  mapSchema(schema, {\n    [exports.MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n\n        for (const fieldName in originalFieldConfigMap) {\n          const originalFieldConfig = originalFieldConfigMap[fieldName];\n\n          if (testFn(fieldName, originalFieldConfig)) {\n            selectedFields[fieldName] = originalFieldConfig;\n          }\n        }\n      }\n\n      return undefined;\n    }\n  });\n  return selectedFields;\n}\n\nfunction modifyObjectFields(schema, typeName, testFn, newFields) {\n  const removedFields = {};\n  const newSchema = mapSchema(schema, {\n    [exports.MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n        const newFieldConfigMap = {};\n\n        for (const fieldName in originalFieldConfigMap) {\n          const originalFieldConfig = originalFieldConfigMap[fieldName];\n\n          if (testFn(fieldName, originalFieldConfig)) {\n            removedFields[fieldName] = originalFieldConfig;\n          } else {\n            newFieldConfigMap[fieldName] = originalFieldConfig;\n          }\n        }\n\n        for (const fieldName in newFields) {\n          const fieldConfig = newFields[fieldName];\n          newFieldConfigMap[fieldName] = fieldConfig;\n        }\n\n        return correctASTNodes(new graphql.GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  });\n  return [newSchema, removedFields];\n}\n\nfunction renameType(type, newTypeName) {\n  if (graphql.isObjectType(type)) {\n    return new graphql.GraphQLObjectType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (graphql.isInterfaceType(type)) {\n    return new graphql.GraphQLInterfaceType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (graphql.isUnionType(type)) {\n    return new graphql.GraphQLUnionType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (graphql.isInputObjectType(type)) {\n    return new graphql.GraphQLInputObjectType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (graphql.isEnumType(type)) {\n    return new graphql.GraphQLEnumType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (graphql.isScalarType(type)) {\n    return new graphql.GraphQLScalarType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  }\n\n  throw new Error(`Unknown type ${type}.`);\n}\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\n\n\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\n  let $return;\n  let abruptClose;\n\n  if (typeof iterator.return === 'function') {\n    $return = iterator.return;\n\n    abruptClose = error => {\n      const rethrow = () => Promise.reject(error);\n\n      return $return.call(iterator).then(rethrow, rethrow);\n    };\n  }\n\n  function mapResult(result) {\n    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n  }\n\n  let mapReject;\n\n  if (rejectCallback) {\n    // Capture rejectCallback to ensure it cannot be null.\n    const reject = rejectCallback;\n\n    mapReject = error => asyncMapValue(error, reject).then(iteratorResult, abruptClose);\n  }\n\n  return {\n    next() {\n      return iterator.next().then(mapResult, mapReject);\n    },\n\n    return() {\n      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n\n    throw(error) {\n      if (typeof iterator.throw === 'function') {\n        return iterator.throw(error).then(mapResult, mapReject);\n      }\n\n      return Promise.reject(error).catch(abruptClose);\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n}\n\nfunction asyncMapValue(value, callback) {\n  return new Promise(resolve => resolve(callback(value)));\n}\n\nfunction iteratorResult(value) {\n  return {\n    value,\n    done: false\n  };\n}\n\nfunction updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {\n  argumentNodes[argName] = {\n    kind: graphql.Kind.ARGUMENT,\n    name: {\n      kind: graphql.Kind.NAME,\n      value: argName\n    },\n    value: {\n      kind: graphql.Kind.VARIABLE,\n      name: {\n        kind: graphql.Kind.NAME,\n        value: varName\n      }\n    }\n  };\n  variableDefinitionsMap[varName] = {\n    kind: graphql.Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: graphql.Kind.VARIABLE,\n      name: {\n        kind: graphql.Kind.NAME,\n        value: varName\n      }\n    },\n    type: astFromType(type)\n  };\n\n  if (value !== undefined) {\n    variableValues[varName] = value;\n    return;\n  } // including the variable in the map with value of `undefined`\n  // will actually be translated by graphql-js into `null`\n  // see https://github.com/graphql/graphql-js/issues/2533\n\n\n  if (varName in variableValues) {\n    delete variableValues[varName];\n  }\n}\n\nfunction createVariableNameGenerator(variableDefinitionMap) {\n  let varCounter = 0;\n  return argName => {\n    let varName;\n\n    do {\n      varName = `_v${(varCounter++).toString()}_${argName}`;\n    } while (varName in variableDefinitionMap);\n\n    return varName;\n  };\n}\n\nfunction implementsAbstractType(schema, typeA, typeB) {\n  if (typeB == null || typeA == null) {\n    return false;\n  } else if (typeA === typeB) {\n    return true;\n  } else if (graphql.isCompositeType(typeA) && graphql.isCompositeType(typeB)) {\n    return graphql.doTypesOverlap(schema, typeA, typeB);\n  }\n\n  return false;\n}\n\nfunction relocatedError(originalError, path) {\n  return new graphql.GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path === null ? undefined : path === undefined ? originalError.path : path, originalError.originalError, originalError.extensions);\n}\n\nfunction observableToAsyncIterable(observable) {\n  const pullQueue = [];\n  const pushQueue = [];\n  let listening = true;\n\n  const pushValue = value => {\n    if (pullQueue.length !== 0) {\n      // It is safe to use the ! operator here as we check the length.\n      pullQueue.shift()({\n        value,\n        done: false\n      });\n    } else {\n      pushQueue.push({\n        value,\n        done: false\n      });\n    }\n  };\n\n  const pushError = error => {\n    if (pullQueue.length !== 0) {\n      // It is safe to use the ! operator here as we check the length.\n      pullQueue.shift()({\n        value: {\n          errors: [error]\n        },\n        done: false\n      });\n    } else {\n      pushQueue.push({\n        value: {\n          errors: [error]\n        },\n        done: false\n      });\n    }\n  };\n\n  const pushDone = () => {\n    if (pullQueue.length !== 0) {\n      // It is safe to use the ! operator here as we check the length.\n      pullQueue.shift()({\n        done: true\n      });\n    } else {\n      pushQueue.push({\n        done: true\n      });\n    }\n  };\n\n  const pullValue = () => new Promise(resolve => {\n    if (pushQueue.length !== 0) {\n      const element = pushQueue.shift(); // either {value: {errors: [...]}} or {value: ...}\n\n      resolve(element);\n    } else {\n      pullQueue.push(resolve);\n    }\n  });\n\n  const subscription = observable.subscribe({\n    next(value) {\n      pushValue(value);\n    },\n\n    error(err) {\n      pushError(err);\n    },\n\n    complete() {\n      pushDone();\n    }\n\n  });\n\n  const emptyQueue = () => {\n    if (listening) {\n      listening = false;\n      subscription.unsubscribe();\n\n      for (const resolve of pullQueue) {\n        resolve({\n          value: undefined,\n          done: true\n        });\n      }\n\n      pullQueue.length = 0;\n      pushQueue.length = 0;\n    }\n  };\n\n  return {\n    next() {\n      // return is a defined method, so it is safe to call it.\n      return listening ? pullValue() : this.return();\n    },\n\n    return() {\n      emptyQueue();\n      return Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n\n    throw(error) {\n      emptyQueue();\n      return Promise.reject(error);\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n}\n\nfunction getOperationASTFromDocument(documentNode, operationName) {\n  const doc = graphql.getOperationAST(documentNode, operationName);\n\n  if (!doc) {\n    throw new Error(`Cannot infer operation ${operationName || ''}`);\n  }\n\n  return doc;\n}\n\nconst getOperationASTFromRequest = memoize1(function getOperationASTFromRequest(request) {\n  return getOperationASTFromDocument(request.document, request.operationName);\n}); // Taken from GraphQL-JS v16 for backwards compat\n\nfunction collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case graphql.Kind.FIELD:\n        {\n          if (!shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n\n          const name = getFieldEntryKey(selection);\n          const fieldList = fields.get(name);\n\n          if (fieldList !== undefined) {\n            fieldList.push(selection);\n          } else {\n            fields.set(name, [selection]);\n          }\n\n          break;\n        }\n\n      case graphql.Kind.INLINE_FRAGMENT:\n        {\n          if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n            continue;\n          }\n\n          collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n\n      case graphql.Kind.FRAGMENT_SPREAD:\n        {\n          const fragName = selection.name.value;\n\n          if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n\n          visitedFragmentNames.add(fragName);\n          const fragment = fragments[fragName];\n\n          if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n            continue;\n          }\n\n          collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n    }\n  }\n\n  return fields;\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = graphql.getDirectiveValues(graphql.GraphQLSkipDirective, node, variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip['if']) === true) {\n    return false;\n  }\n\n  const include = graphql.getDirectiveValues(graphql.GraphQLIncludeDirective, node, variableValues);\n\n  if ((include === null || include === void 0 ? void 0 : include['if']) === false) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = graphql.typeFromAST(schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (graphql.isAbstractType(conditionalType)) {\n    const possibleTypes = schema.getPossibleTypes(conditionalType);\n    return possibleTypes.includes(type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n\nconst collectSubFields = memoize5(function collectSubFields(schema, fragments, variableValues, type, fieldNodes) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n\n  for (const fieldNode of fieldNodes) {\n    if (fieldNode.selectionSet) {\n      collectFields(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\n    }\n  }\n\n  return subFieldNodes;\n});\n\nfunction visitData(data, enter, leave) {\n  if (Array.isArray(data)) {\n    return data.map(value => visitData(value, enter, leave));\n  } else if (typeof data === 'object') {\n    const newData = enter != null ? enter(data) : data;\n\n    if (newData != null) {\n      for (const key in newData) {\n        const value = newData[key];\n        Object.defineProperty(newData, key, {\n          value: visitData(value, enter, leave)\n        });\n      }\n    }\n\n    return leave != null ? leave(newData) : newData;\n  }\n\n  return data;\n}\n\nfunction visitErrors(errors, visitor) {\n  return errors.map(error => visitor(error));\n}\n\nfunction visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {\n  const fragments = request.document.definitions.reduce((acc, def) => {\n    if (def.kind === graphql.Kind.FRAGMENT_DEFINITION) {\n      acc[def.name.value] = def;\n    }\n\n    return acc;\n  }, {});\n  const variableValues = request.variables || {};\n  const errorInfo = {\n    segmentInfoMap: new Map(),\n    unpathedErrors: new Set()\n  };\n  const data = result.data;\n  const errors = result.errors;\n  const visitingErrors = errors != null && errorVisitorMap != null;\n  const operationDocumentNode = getOperationASTFromRequest(request);\n\n  if (data != null && operationDocumentNode != null) {\n    result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : undefined, errorInfo);\n  }\n\n  if (errors != null && errorVisitorMap) {\n    result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);\n  }\n\n  return result;\n}\n\nfunction visitErrorsByType(errors, errorVisitorMap, errorInfo) {\n  const segmentInfoMap = errorInfo.segmentInfoMap;\n  const unpathedErrors = errorInfo.unpathedErrors;\n  const unpathedErrorVisitor = errorVisitorMap['__unpathed'];\n  return errors.map(originalError => {\n    const pathSegmentsInfo = segmentInfoMap.get(originalError);\n    const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {\n      const typeName = segmentInfo.type.name;\n      const typeVisitorMap = errorVisitorMap[typeName];\n\n      if (typeVisitorMap == null) {\n        return acc;\n      }\n\n      const errorVisitor = typeVisitorMap[segmentInfo.fieldName];\n      return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);\n    }, originalError);\n\n    if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {\n      return unpathedErrorVisitor(newError);\n    }\n\n    return newError;\n  });\n}\n\nfunction visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {\n  const operationRootType = graphql.getOperationRootType(schema, operation);\n  const collectedFields = collectFields(schema, fragments, variableValues, operationRootType, operation.selectionSet, new Map(), new Set());\n  return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);\n}\n\nfunction visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n  var _a;\n\n  const fieldMap = type.getFields();\n  const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];\n  const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;\n  const newObject = enterObject != null ? enterObject(object) : object;\n  let sortedErrors;\n  let errorMap = null;\n\n  if (errors != null) {\n    sortedErrors = sortErrorsByPathSegment(errors, pathIndex);\n    errorMap = sortedErrors.errorMap;\n\n    for (const error of sortedErrors.unpathedErrors) {\n      errorInfo.unpathedErrors.add(error);\n    }\n  }\n\n  for (const [responseKey, subFieldNodes] of fieldNodeMap) {\n    const fieldName = subFieldNodes[0].name.value;\n    const fieldType = fieldName === '__typename' ? graphql.TypeNameMetaFieldDef.type : (_a = fieldMap[fieldName]) === null || _a === void 0 ? void 0 : _a.type;\n    const newPathIndex = pathIndex + 1;\n    let fieldErrors;\n\n    if (errorMap) {\n      fieldErrors = errorMap[responseKey];\n\n      if (fieldErrors != null) {\n        delete errorMap[responseKey];\n      }\n\n      addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);\n    }\n\n    const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);\n    updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);\n  }\n\n  const oldTypename = newObject.__typename;\n\n  if (oldTypename != null) {\n    updateObject(newObject, '__typename', oldTypename, typeVisitorMap, '__typename');\n  }\n\n  if (errorMap) {\n    for (const errorsKey in errorMap) {\n      const errors = errorMap[errorsKey];\n\n      for (const error of errors) {\n        errorInfo.unpathedErrors.add(error);\n      }\n    }\n  }\n\n  const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;\n  return leaveObject != null ? leaveObject(newObject) : newObject;\n}\n\nfunction updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {\n  if (typeVisitorMap == null) {\n    object[responseKey] = newValue;\n    return;\n  }\n\n  const fieldVisitor = typeVisitorMap[fieldName];\n\n  if (fieldVisitor == null) {\n    object[responseKey] = newValue;\n    return;\n  }\n\n  const visitedValue = fieldVisitor(newValue);\n\n  if (visitedValue === undefined) {\n    delete object[responseKey];\n    return;\n  }\n\n  object[responseKey] = visitedValue;\n}\n\nfunction visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n  return list.map(listMember => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));\n}\n\nfunction visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex) {\n  let errors = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];\n  let errorInfo = arguments.length > 9 ? arguments[9] : undefined;\n\n  if (value == null) {\n    return value;\n  }\n\n  const nullableType = graphql.getNullableType(returnType);\n\n  if (graphql.isListType(nullableType)) {\n    return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n  } else if (graphql.isAbstractType(nullableType)) {\n    const finalType = schema.getType(value.__typename);\n    const collectedFields = collectSubFields(schema, fragments, variableValues, finalType, fieldNodes);\n    return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n  } else if (graphql.isObjectType(nullableType)) {\n    const collectedFields = collectSubFields(schema, fragments, variableValues, nullableType, fieldNodes);\n    return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n  }\n\n  const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];\n\n  if (typeVisitorMap == null) {\n    return value;\n  }\n\n  const visitedValue = typeVisitorMap(value);\n  return visitedValue === undefined ? value : visitedValue;\n}\n\nfunction sortErrorsByPathSegment(errors, pathIndex) {\n  var _a;\n\n  const errorMap = Object.create(null);\n  const unpathedErrors = new Set();\n\n  for (const error of errors) {\n    const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];\n\n    if (pathSegment == null) {\n      unpathedErrors.add(error);\n      continue;\n    }\n\n    if (pathSegment in errorMap) {\n      errorMap[pathSegment].push(error);\n    } else {\n      errorMap[pathSegment] = [error];\n    }\n  }\n\n  return {\n    errorMap,\n    unpathedErrors\n  };\n}\n\nfunction addPathSegmentInfo(type, fieldName, pathIndex) {\n  let errors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let errorInfo = arguments.length > 4 ? arguments[4] : undefined;\n\n  for (const error of errors) {\n    const segmentInfo = {\n      type,\n      fieldName,\n      pathIndex\n    };\n    const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);\n\n    if (pathSegmentsInfo == null) {\n      errorInfo.segmentInfoMap.set(error, [segmentInfo]);\n    } else {\n      pathSegmentsInfo.push(segmentInfo);\n    }\n  }\n}\n\nfunction valueMatchesCriteria(value, criteria) {\n  if (value == null) {\n    return value === criteria;\n  } else if (Array.isArray(value)) {\n    return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));\n  } else if (typeof value === 'object') {\n    return typeof criteria === 'object' && criteria && Object.keys(criteria).every(propertyName => valueMatchesCriteria(value[propertyName], criteria[propertyName]));\n  } else if (criteria instanceof RegExp) {\n    return criteria.test(value);\n  }\n\n  return value === criteria;\n}\n\nfunction isAsyncIterable(value) {\n  return typeof value === 'object' && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === 'function';\n}\n\nfunction isDocumentNode(object) {\n  return object && typeof object === 'object' && 'kind' in object && object.kind === graphql.Kind.DOCUMENT;\n}\n\nasync function defaultAsyncIteratorReturn(value) {\n  return {\n    value,\n    done: true\n  };\n}\n\nconst proxyMethodFactory = memoize2(function proxyMethodFactory(target, targetMethod) {\n  return function proxyMethod() {\n    for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return Reflect.apply(targetMethod, target, args);\n  };\n});\n\nfunction getAsyncIteratorWithCancel(asyncIterator, onCancel) {\n  return new Proxy(asyncIterator, {\n    has(asyncIterator, prop) {\n      if (prop === 'return') {\n        return true;\n      }\n\n      return Reflect.has(asyncIterator, prop);\n    },\n\n    get(asyncIterator, prop, receiver) {\n      const existingPropValue = Reflect.get(asyncIterator, prop, receiver);\n\n      if (prop === 'return') {\n        const existingReturn = existingPropValue || defaultAsyncIteratorReturn;\n        return async function returnWithCancel(value) {\n          const returnValue = await onCancel(value);\n          return Reflect.apply(existingReturn, asyncIterator, [returnValue]);\n        };\n      } else if (typeof existingPropValue === 'function') {\n        return proxyMethodFactory(asyncIterator, existingPropValue);\n      }\n\n      return existingPropValue;\n    }\n\n  });\n}\n\nfunction getAsyncIterableWithCancel(asyncIterable, onCancel) {\n  return new Proxy(asyncIterable, {\n    get(asyncIterable, prop, receiver) {\n      const existingPropValue = Reflect.get(asyncIterable, prop, receiver);\n\n      if (Symbol.asyncIterator === prop) {\n        return function asyncIteratorFactory() {\n          const asyncIterator = Reflect.apply(existingPropValue, asyncIterable, []);\n          return getAsyncIteratorWithCancel(asyncIterator, onCancel);\n        };\n      } else if (typeof existingPropValue === 'function') {\n        return proxyMethodFactory(asyncIterable, existingPropValue);\n      }\n\n      return existingPropValue;\n    }\n\n  });\n}\n\nfunction buildFixedSchema(schema, options) {\n  const document = getDocumentNodeFromSchema(schema);\n  return graphql.buildASTSchema(document, { ...(options || {})\n  });\n}\n\nfunction fixSchemaAst(schema, options) {\n  // eslint-disable-next-line no-undef-init\n  let schemaWithValidAst = undefined;\n\n  if (!schema.astNode || !schema.extensionASTNodes) {\n    schemaWithValidAst = buildFixedSchema(schema, options);\n  }\n\n  if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {\n    schema.astNode = schemaWithValidAst.astNode;\n  }\n\n  if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {\n    schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;\n  }\n\n  return schema;\n}\n\nexports.addTypes = addTypes;\nexports.appendObjectFields = appendObjectFields;\nexports.asArray = asArray;\nexports.assertSome = assertSome;\nexports.astFromArg = astFromArg;\nexports.astFromDirective = astFromDirective;\nexports.astFromEnumType = astFromEnumType;\nexports.astFromEnumValue = astFromEnumValue;\nexports.astFromField = astFromField;\nexports.astFromInputField = astFromInputField;\nexports.astFromInputObjectType = astFromInputObjectType;\nexports.astFromInterfaceType = astFromInterfaceType;\nexports.astFromObjectType = astFromObjectType;\nexports.astFromScalarType = astFromScalarType;\nexports.astFromSchema = astFromSchema;\nexports.astFromUnionType = astFromUnionType;\nexports.astFromValueUntyped = astFromValueUntyped;\nexports.buildOperationNodeForField = buildOperationNodeForField;\nexports.checkValidationErrors = checkValidationErrors;\nexports.collectComment = collectComment;\nexports.collectFields = collectFields;\nexports.collectSubFields = collectSubFields;\nexports.compareNodes = compareNodes;\nexports.compareStrings = compareStrings;\nexports.correctASTNodes = correctASTNodes;\nexports.createDefaultRules = createDefaultRules;\nexports.createNamedStub = createNamedStub;\nexports.createStub = createStub;\nexports.createVariableNameGenerator = createVariableNameGenerator;\nexports.dedentBlockStringValue = dedentBlockStringValue;\nexports.filterSchema = filterSchema;\nexports.fixSchemaAst = fixSchemaAst;\nexports.forEachDefaultValue = forEachDefaultValue;\nexports.forEachField = forEachField;\nexports.getArgumentValues = getArgumentValues;\nexports.getAsyncIterableWithCancel = getAsyncIterableWithCancel;\nexports.getAsyncIteratorWithCancel = getAsyncIteratorWithCancel;\nexports.getBlockStringIndentation = getBlockStringIndentation;\nexports.getBuiltInForStub = getBuiltInForStub;\nexports.getComment = getComment;\nexports.getDefinedRootType = getDefinedRootType;\nexports.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;\nexports.getDescription = getDescription;\nexports.getDirective = getDirective;\nexports.getDirectiveInExtensions = getDirectiveInExtensions;\nexports.getDirectiveNodes = getDirectiveNodes;\nexports.getDirectives = getDirectives;\nexports.getDirectivesInExtensions = getDirectivesInExtensions;\nexports.getDocumentNodeFromSchema = getDocumentNodeFromSchema;\nexports.getFieldsWithDirectives = getFieldsWithDirectives;\nexports.getImplementingTypes = getImplementingTypes;\nexports.getLeadingCommentBlock = getLeadingCommentBlock;\nexports.getOperationASTFromDocument = getOperationASTFromDocument;\nexports.getOperationASTFromRequest = getOperationASTFromRequest;\nexports.getResolversFromSchema = getResolversFromSchema;\nexports.getResponseKeyFromInfo = getResponseKeyFromInfo;\nexports.getRootTypeMap = getRootTypeMap;\nexports.getRootTypeNames = getRootTypeNames;\nexports.getRootTypes = getRootTypes;\nexports.healSchema = healSchema;\nexports.healTypes = healTypes;\nexports.implementsAbstractType = implementsAbstractType;\nexports.inspect = inspect;\nexports.isAggregateError = isAggregateError;\nexports.isAsyncIterable = isAsyncIterable;\nexports.isDescribable = isDescribable;\nexports.isDocumentNode = isDocumentNode;\nexports.isDocumentString = isDocumentString;\nexports.isNamedStub = isNamedStub;\nexports.isSome = isSome;\nexports.isValidPath = isValidPath;\nexports.makeDeprecatedDirective = makeDeprecatedDirective;\nexports.makeDirectiveNode = makeDirectiveNode;\nexports.makeDirectiveNodes = makeDirectiveNodes;\nexports.mapAsyncIterator = mapAsyncIterator;\nexports.mapSchema = mapSchema;\nexports.memoize1 = memoize1;\nexports.memoize2 = memoize2;\nexports.memoize2of4 = memoize2of4;\nexports.memoize3 = memoize3;\nexports.memoize4 = memoize4;\nexports.memoize5 = memoize5;\nexports.mergeDeep = mergeDeep;\nexports.modifyObjectFields = modifyObjectFields;\nexports.nodeToString = nodeToString;\nexports.observableToAsyncIterable = observableToAsyncIterable;\nexports.parseGraphQLJSON = parseGraphQLJSON;\nexports.parseGraphQLSDL = parseGraphQLSDL;\nexports.parseInputValue = parseInputValue;\nexports.parseInputValueLiteral = parseInputValueLiteral;\nexports.parseSelectionSet = parseSelectionSet;\nexports.printComment = printComment;\nexports.printSchemaWithDirectives = printSchemaWithDirectives;\nexports.printWithComments = printWithComments;\nexports.pruneSchema = pruneSchema;\nexports.pushComment = pushComment;\nexports.relocatedError = relocatedError;\nexports.removeObjectFields = removeObjectFields;\nexports.renameType = renameType;\nexports.resetComments = resetComments;\nexports.rewireTypes = rewireTypes;\nexports.selectObjectFields = selectObjectFields;\nexports.serializeInputValue = serializeInputValue;\nexports.transformCommentsToDescriptions = transformCommentsToDescriptions;\nexports.transformInputValue = transformInputValue;\nexports.updateArgument = updateArgument;\nexports.validateGraphQlDocuments = validateGraphQlDocuments;\nexports.valueMatchesCriteria = valueMatchesCriteria;\nexports.visitData = visitData;\nexports.visitErrors = visitErrors;\nexports.visitResult = visitResult;\nexports.withCancel = getAsyncIterableWithCancel;","map":{"version":3,"names":["Object","defineProperty","exports","value","graphql","require","asArray","fns","Array","isArray","invalidDocRegex","isDocumentString","str","test","parse","e","invalidPathRegex","isValidPath","compareStrings","a","b","String","nodeToString","_a","_b","name","alias","kind","compareNodes","customFn","aStr","bStr","isSome","input","assertSome","message","Error","AggregateError","AggregateErrorClass","constructor","errors","captureStackTrace","isAggregateError","error","MAX_RECURSIVE_DEPTH","inspect","formatValue","seenValues","JSON","stringify","formatObjectValue","formatError","GraphQLError","toString","stack","previouslySeenValues","formatArray","includes","isJSONable","jsonValue","toJSON","formatObject","object","entries","length","getObjectTag","properties","map","key","join","array","len","remaining","items","i","push","tag","prototype","call","replace","getArgumentValues","def","node","variableValues","variableMap","reduce","prev","coercedValues","argumentNodes","arguments","argNodeMap","arg","type","argType","defaultValue","args","argumentNode","undefined","isNonNullType","valueNode","isNull","Kind","NULL","VARIABLE","variableName","coercedValue","valueFromAST","print","getDirectivesInExtensions","pathToDirectivesInExtensions","acc","pathSegment","extensions","_getDirectiveInExtensions","directivesInExtensions","directiveName","directiveInExtensions","filter","directiveAnnotation","directive","getDirectiveInExtensions","reformattedDirectivesInExtensions","argsOrArrayOfArgs","getDirectives","schema","schemaDirectives","schemaDirectiveMap","schemaDirective","astNodes","astNode","extensionASTNodes","result","directives","directiveNode","getDirective","parseDirectiveValue","INT","parseInt","FLOAT","parseFloat","BOOLEAN","Boolean","STRING","ENUM","LIST","values","v","OBJECT","fields","getFieldsWithDirectives","documentNode","options","selected","includeInputTypes","allTypes","definitions","obj","typeName","field","fieldName","d","getImplementingTypes","interfaceName","allTypesMap","getTypeMap","graphqlTypeName","graphqlType","isObjectType","allInterfaces","getInterfaces","find","int","astFromType","innerType","ofType","NON_NULL_TYPE","isListType","LIST_TYPE","NAMED_TYPE","NAME","astFromValueUntyped","valuesNodes","item","itemNode","fieldNodes","fieldValue","ast","OBJECT_FIELD","isFinite","stringNum","integerStringRegExp","TypeError","memoize1","fn","memoize1cache","WeakMap","memoized","a1","cachedValue","get","newValue","set","memoize2","memoize2cache","a2","cache2","memoize3","memoize3Cache","a3","cache3","memoize4","memoize4Cache","a4","cache4","memoize5","memoize5Cache","a5","cache5","memoize2of4cache","memoize2of4","getDefinedRootType","operation","rootTypeMap","getRootTypeMap","rootType","getRootTypeNames","rootTypes","getRootTypes","Set","Map","queryType","getQueryType","mutationType","getMutationType","subscriptionType","getSubscriptionType","getDocumentNodeFromSchema","typesMap","schemaNode","astFromSchema","isSpecifiedDirective","astFromDirective","isPredefinedScalar","isSpecifiedScalarType","isIntrospection","isIntrospectionType","astFromObjectType","isInterfaceType","astFromInterfaceType","isUnionType","astFromUnionType","isInputObjectType","astFromInputObjectType","isEnumType","astFromEnumType","isScalarType","astFromScalarType","DOCUMENT","printSchemaWithDirectives","operationTypeMap","nodes","extensionASTNode","operationTypes","operationTypeDefinitionNode","operationTypeNode","rootTypeAST","OPERATION_TYPE_DEFINITION","getDirectiveNodes","SCHEMA_DEFINITION","SCHEMA_EXTENSION","description","block","_c","_d","DIRECTIVE_DEFINITION","astFromArg","repeatable","isRepeatable","locations","location","entity","concat","makeDirectiveNodes","getDeprecatableDirectiveNodes","directiveNodesBesidesDeprecated","deprecatedDirectiveNode","deprecationReason","makeDeprecatedDirective","INPUT_VALUE_DEFINITION","astFromValue","OBJECT_TYPE_DEFINITION","getFields","astFromField","interfaces","iFace","INTERFACE_TYPE_DEFINITION","UNION_TYPE_DEFINITION","types","getTypes","INPUT_OBJECT_TYPE_DEFINITION","astFromInputField","ENUM_TYPE_DEFINITION","getValues","astFromEnumValue","specifiedByValue","some","specifiedByArgs","url","makeDirectiveNode","SCALAR_TYPE_DEFINITION","FIELD_DEFINITION","ENUM_VALUE_DEFINITION","reason","GraphQLDeprecatedDirective","directiveArguments","argName","argValue","ARGUMENT","DIRECTIVE","directiveValues","directiveNodes","arrayOrSingleValue","validateGraphQlDocuments","documentFiles","effectiveRules","createDefaultRules","allFragmentMap","documentFileObjectsToValidate","documentFile","document","definitionsToValidate","definitionNode","FRAGMENT_DEFINITION","allErrors","allFragmentsDocument","Promise","all","documentToValidate","concatAST","validate","filePath","checkValidationErrors","loadDocumentErrors","loadDocumentError","graphQLError","line","column","index","ignored","versionInfo","major","rule","specifiedRules","f","stripBOM","content","charCodeAt","slice","parseBOM","parseGraphQLJSON","jsonContent","parsedJson","data","__schema","buildClientSchema","rawSDL","MAX_LINE_LENGTH","commentsRegistry","resetComments","collectComment","entityName","pushComment","isFieldDefinitionNode","argument","comment","getComment","keys","path","printComment","maybeArray","separator","x","hasMultilineItems","addDescription","cb","_key","_parent","ancestors","parent","indent","maybeString","wrap","start","end","printBlockString","isDescription","escaped","indexOf","printDocASTReducer","Name","leave","Variable","Document","OperationDefinition","varDefs","variableDefinitions","prefix","selectionSet","VariableDefinition","variable","SelectionSet","selections","Field","argsLine","Argument","FragmentSpread","InlineFragment","typeCondition","FragmentDefinition","IntValue","FloatValue","StringValue","isBlockString","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","DirectiveDefinition","SchemaExtension","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","printDocASTReducerWithComments","printWithComments","visit","getDescription","commentDescriptions","rawValue","getLeadingCommentBlock","dedentBlockStringValue","loc","comments","token","startToken","TokenKind","COMMENT","next","reverse","rawString","lines","split","commonIndent","getBlockStringIndentation","isBlank","shift","pop","leadingWhitespace","parseGraphQLSDL","transformCommentsToDescriptions","noLocation","Source","trim","sourceSdl","parsedDoc","modifiedDoc","isDescribable","commentsBlock","isBlock","isTypeSystemDefinitionNode","operationVariables","fieldTypeMap","addOperationVariable","resetOperationVariables","resetFieldMap","buildOperationNodeForField","models","ignore","depthLimit","circularReferenceDepth","argNames","selectedFields","rootTypeNames","operationNode","buildOperationAndCollectVariables","Infinity","operationName","resolveVariable","OPERATION_DEFINITION","SELECTION_SET","resolveField","firstCall","depth","resolveSelectionSet","t","hasCircularRef","INLINE_FRAGMENT","fragmentNode","has","isIgnored","isModel","FIELD","getNamedType","selectedSubFields","resolveVariableType","VARIABLE_DEFINITION","getArgumentName","namedType","removeField","argumentName","fieldPath","fieldPathStr","config","size","MapperKind","getObjectTypeFromTypeMap","typeMap","maybeObjectType","createNamedStub","GraphQLObjectType","GraphQLInterfaceType","GraphQLInputObjectType","_fake","GraphQLString","createStub","GraphQLList","GraphQLNonNull","isNamedStub","getBuiltInForStub","GraphQLInt","GraphQLFloat","GraphQLBoolean","GraphQLID","rewireTypes","originalTypeMap","referenceTypeMap","create","newTypeMap","startsWith","newName","rewireNamedType","newDirectives","rewireDirective","directiveConfig","toConfig","rewireArgs","GraphQLDirective","rewiredArgs","rewiredArgType","rewireType","newConfig","rewireFields","rewireNamedTypes","GraphQLUnionType","rewireInputFields","enumConfig","GraphQLEnumType","scalarConfig","GraphQLScalarType","rewiredFields","rewiredFieldType","namedTypes","rewiredTypes","rewiredType","isNamedType","transformInputValue","inputLeafValueTransformer","inputObjectValueTransformer","nullableType","getNullableType","isLeafType","listMember","serializeInputValue","serialize","parseInputValue","parseValue","parseInputValueLiteral","parseLiteral","mapSchema","schemaMapper","mapArguments","mapFields","mapTypes","mapDefaultValues","mapEnumValues","originalDirectives","mapDirectives","GraphQLSchema","query","mutation","subscription","testFn","originalType","typeMapper","getTypeMapper","maybeNewType","enumValueMapper","getEnumValueMapper","ENUM_TYPE","originalEnumValueConfigMap","newEnumValueConfigMap","externalValue","originalEnumValueConfig","mappedEnumValue","newExternalValue","newEnumValueConfig","correctASTNodes","argumentConfig","getNewType","INPUT_OBJECT_FIELD","inputFieldConfig","newType","fieldMapper","getFieldMapper","originalFieldConfigMap","newFieldConfigMap","originalFieldConfig","mappedField","newFieldName","newFieldConfig","argumentMapper","getArgumentMapper","originalArgumentConfigMap","argumentNames","newArgumentConfigMap","originalArgumentConfig","mappedArgument","newArgumentName","newArgumentConfig","directiveMapper","getDirectiveMapper","mappedDirective","getTypeSpecifiers","getType","specifiers","TYPE","COMPOSITE_TYPE","OBJECT_TYPE","ROOT_OBJECT","QUERY","MUTATION","SUBSCRIPTION","INPUT_OBJECT_TYPE","ABSTRACT_TYPE","INTERFACE_TYPE","UNION_TYPE","SCALAR_TYPE","getFieldSpecifiers","COMPOSITE_FIELD","ROOT_FIELD","QUERY_ROOT_FIELD","MUTATION_ROOT_FIELD","SUBSCRIPTION_ROOT_FIELD","INTERFACE_FIELD","ENUM_VALUE","fieldConfig","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","enumKey","enumValueConfig","filterSchema","typeFilter","fieldFilter","rootFieldFilter","objectFieldFilter","interfaceFieldFilter","inputObjectFieldFilter","argumentFilter","filteredSchema","filterRootFields","filterElementFields","ElementConstructor","healSchema","healTypes","actualNamedTypeMap","actualName","decl","healType","healNamedType","healFields","healInterfaces","healUnderlyingTypes","healInputFields","fieldMap","splice","iface","healedType","officialType","getResolversFromSchema","resolvers","resolveType","__resolveType","isTypeOf","__isTypeOf","subscribe","resolve","forEachField","forEachDefaultValue","addTypes","newTypesOrDirectives","originalDirectiveMap","newTypeOrDirective","isDirective","pruneSchema","skipEmptyCompositeTypePruning","skipEmptyUnionPruning","skipPruning","skipUnimplementedInterfacesPruning","skipUnusedTypesPruning","prunedTypes","prunedSchema","visited","visitSchema","revisit","visitQueue","delete","queue","add","mergeDeep","sources","respectPrototype","target","output","setPrototypeOf","getPrototypeOf","source","isObject","outputPrototype","sourcePrototype","getOwnPropertyNames","descriptor","getOwnPropertyDescriptor","assign","parseSelectionSet","getResponseKeyFromInfo","info","appendObjectFields","additionalFields","removeObjectFields","removedFields","newSchema","selectObjectFields","modifyObjectFields","newFields","renameType","newTypeName","mapAsyncIterator","iterator","callback","rejectCallback","$return","abruptClose","return","rethrow","reject","then","mapResult","done","asyncMapValue","iteratorResult","mapReject","throw","catch","Symbol","asyncIterator","updateArgument","variableDefinitionsMap","varName","createVariableNameGenerator","variableDefinitionMap","varCounter","implementsAbstractType","typeA","typeB","isCompositeType","doTypesOverlap","relocatedError","originalError","positions","observableToAsyncIterable","observable","pullQueue","pushQueue","listening","pushValue","pushError","pushDone","pullValue","element","err","complete","emptyQueue","unsubscribe","getOperationASTFromDocument","doc","getOperationAST","getOperationASTFromRequest","request","collectFields","fragments","runtimeType","visitedFragmentNames","selection","shouldIncludeNode","getFieldEntryKey","fieldList","doesFragmentConditionMatch","FRAGMENT_SPREAD","fragName","fragment","skip","getDirectiveValues","GraphQLSkipDirective","include","GraphQLIncludeDirective","typeConditionNode","conditionalType","typeFromAST","isAbstractType","possibleTypes","getPossibleTypes","collectSubFields","subFieldNodes","fieldNode","visitData","enter","newData","visitErrors","visitor","visitResult","resultVisitorMap","errorVisitorMap","variables","errorInfo","segmentInfoMap","unpathedErrors","visitingErrors","operationDocumentNode","visitRoot","visitErrorsByType","unpathedErrorVisitor","pathSegmentsInfo","newError","reduceRight","segmentInfo","typeVisitorMap","errorVisitor","pathIndex","root","operationRootType","getOperationRootType","collectedFields","visitObjectValue","fieldNodeMap","enterObject","__enter","newObject","sortedErrors","errorMap","sortErrorsByPathSegment","responseKey","fieldType","TypeNameMetaFieldDef","newPathIndex","fieldErrors","addPathSegmentInfo","visitFieldValue","updateObject","oldTypename","__typename","errorsKey","leaveObject","__leave","fieldVisitor","visitedValue","visitListValue","list","returnType","finalType","valueMatchesCriteria","criteria","every","val","propertyName","RegExp","isAsyncIterable","isDocumentNode","defaultAsyncIteratorReturn","proxyMethodFactory","targetMethod","proxyMethod","Reflect","apply","getAsyncIteratorWithCancel","onCancel","Proxy","prop","receiver","existingPropValue","existingReturn","returnWithCancel","returnValue","getAsyncIterableWithCancel","asyncIterable","asyncIteratorFactory","buildFixedSchema","buildASTSchema","fixSchemaAst","schemaWithValidAst","withCancel"],"sources":["C:/Users/User/node_modules/@graphql-tools/utils/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst graphql = require('graphql');\n\nconst asArray = (fns) => (Array.isArray(fns) ? fns : fns ? [fns] : []);\nconst invalidDocRegex = /\\.[a-z0-9]+$/i;\nfunction isDocumentString(str) {\n    if (typeof str !== 'string') {\n        return false;\n    }\n    // XXX: is-valid-path or is-glob treat SDL as a valid path\n    // (`scalar Date` for example)\n    // this why checking the extension is fast enough\n    // and prevent from parsing the string in order to find out\n    // if the string is a SDL\n    if (invalidDocRegex.test(str)) {\n        return false;\n    }\n    try {\n        graphql.parse(str);\n        return true;\n    }\n    catch (e) { }\n    return false;\n}\nconst invalidPathRegex = /[‘“!%&^<=>`]/;\nfunction isValidPath(str) {\n    return typeof str === 'string' && !invalidPathRegex.test(str);\n}\nfunction compareStrings(a, b) {\n    if (String(a) < String(b)) {\n        return -1;\n    }\n    if (String(a) > String(b)) {\n        return 1;\n    }\n    return 0;\n}\nfunction nodeToString(a) {\n    var _a, _b;\n    let name;\n    if ('alias' in a) {\n        name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    if (name == null && 'name' in a) {\n        name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;\n    }\n    if (name == null) {\n        name = a.kind;\n    }\n    return name;\n}\nfunction compareNodes(a, b, customFn) {\n    const aStr = nodeToString(a);\n    const bStr = nodeToString(b);\n    if (typeof customFn === 'function') {\n        return customFn(aStr, bStr);\n    }\n    return compareStrings(aStr, bStr);\n}\nfunction isSome(input) {\n    return input != null;\n}\nfunction assertSome(input, message = 'Value should be something') {\n    if (input == null) {\n        throw new Error(message);\n    }\n}\n\nif (typeof AggregateError === 'undefined') {\n    class AggregateErrorClass extends Error {\n        constructor(errors, message = '') {\n            super(message);\n            this.errors = errors;\n            this.name = 'AggregateError';\n            Error.captureStackTrace(this, AggregateErrorClass);\n        }\n    }\n    exports.AggregateError = function (errors, message) {\n        return new AggregateErrorClass(errors, message);\n    };\n}\nelse {\n    exports.AggregateError = AggregateError;\n}\nfunction isAggregateError(error) {\n    return 'errors' in error && Array.isArray(error['errors']);\n}\n\n// Taken from graphql-js\nconst MAX_RECURSIVE_DEPTH = 3;\n/**\n * Used to print values in error messages.\n */\nfunction inspect(value) {\n    return formatValue(value, []);\n}\nfunction formatValue(value, seenValues) {\n    switch (typeof value) {\n        case 'string':\n            return JSON.stringify(value);\n        case 'function':\n            return value.name ? `[function ${value.name}]` : '[function]';\n        case 'object':\n            return formatObjectValue(value, seenValues);\n        default:\n            return String(value);\n    }\n}\nfunction formatError(value) {\n    if (value instanceof graphql.GraphQLError) {\n        return value.toString();\n    }\n    return `${value.name}: ${value.message};\\n ${value.stack}`;\n}\nfunction formatObjectValue(value, previouslySeenValues) {\n    if (value === null) {\n        return 'null';\n    }\n    if (value instanceof Error) {\n        if (isAggregateError(value)) {\n            return formatError(value) + '\\n' + formatArray(value.errors, previouslySeenValues);\n        }\n        return formatError(value);\n    }\n    if (previouslySeenValues.includes(value)) {\n        return '[Circular]';\n    }\n    const seenValues = [...previouslySeenValues, value];\n    if (isJSONable(value)) {\n        const jsonValue = value.toJSON();\n        // check for infinite recursion\n        if (jsonValue !== value) {\n            return typeof jsonValue === 'string' ? jsonValue : formatValue(jsonValue, seenValues);\n        }\n    }\n    else if (Array.isArray(value)) {\n        return formatArray(value, seenValues);\n    }\n    return formatObject(value, seenValues);\n}\nfunction isJSONable(value) {\n    return typeof value.toJSON === 'function';\n}\nfunction formatObject(object, seenValues) {\n    const entries = Object.entries(object);\n    if (entries.length === 0) {\n        return '{}';\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return '[' + getObjectTag(object) + ']';\n    }\n    const properties = entries.map(([key, value]) => key + ': ' + formatValue(value, seenValues));\n    return '{ ' + properties.join(', ') + ' }';\n}\nfunction formatArray(array, seenValues) {\n    if (array.length === 0) {\n        return '[]';\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return '[Array]';\n    }\n    const len = array.length;\n    const remaining = array.length;\n    const items = [];\n    for (let i = 0; i < len; ++i) {\n        items.push(formatValue(array[i], seenValues));\n    }\n    if (remaining === 1) {\n        items.push('... 1 more item');\n    }\n    else if (remaining > 1) {\n        items.push(`... ${remaining} more items`);\n    }\n    return '[' + items.join(', ') + ']';\n}\nfunction getObjectTag(object) {\n    const tag = Object.prototype.toString\n        .call(object)\n        .replace(/^\\[object /, '')\n        .replace(/]$/, '');\n    if (tag === 'Object' && typeof object.constructor === 'function') {\n        const name = object.constructor.name;\n        if (typeof name === 'string' && name !== '') {\n            return name;\n        }\n    }\n    return tag;\n}\n\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nfunction getArgumentValues(def, node, variableValues = {}) {\n    var _a;\n    const variableMap = Object.entries(variableValues).reduce((prev, [key, value]) => ({\n        ...prev,\n        [key]: value,\n    }), {});\n    const coercedValues = {};\n    const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];\n    const argNodeMap = argumentNodes.reduce((prev, arg) => ({\n        ...prev,\n        [arg.name.value]: arg,\n    }), {});\n    for (const { name, type: argType, defaultValue } of def.args) {\n        const argumentNode = argNodeMap[name];\n        if (!argumentNode) {\n            if (defaultValue !== undefined) {\n                coercedValues[name] = defaultValue;\n            }\n            else if (graphql.isNonNullType(argType)) {\n                throw new graphql.GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` + 'was not provided.', node);\n            }\n            continue;\n        }\n        const valueNode = argumentNode.value;\n        let isNull = valueNode.kind === graphql.Kind.NULL;\n        if (valueNode.kind === graphql.Kind.VARIABLE) {\n            const variableName = valueNode.name.value;\n            if (variableValues == null || variableMap[variableName] == null) {\n                if (defaultValue !== undefined) {\n                    coercedValues[name] = defaultValue;\n                }\n                else if (graphql.isNonNullType(argType)) {\n                    throw new graphql.GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n                        `was provided the variable \"$${variableName}\" which was not provided a runtime value.`, valueNode);\n                }\n                continue;\n            }\n            isNull = variableValues[variableName] == null;\n        }\n        if (isNull && graphql.isNonNullType(argType)) {\n            throw new graphql.GraphQLError(`Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` + 'must not be null.', valueNode);\n        }\n        const coercedValue = graphql.valueFromAST(valueNode, argType, variableValues);\n        if (coercedValue === undefined) {\n            // Note: ValuesOfCorrectTypeRule validation should catch this before\n            // execution. This is a runtime check to ensure execution does not\n            // continue with an invalid argument value.\n            throw new graphql.GraphQLError(`Argument \"${name}\" has invalid value ${graphql.print(valueNode)}.`, valueNode);\n        }\n        coercedValues[name] = coercedValue;\n    }\n    return coercedValues;\n}\n\nfunction getDirectivesInExtensions(node, pathToDirectivesInExtensions = ['directives']) {\n    return pathToDirectivesInExtensions.reduce((acc, pathSegment) => (acc == null ? acc : acc[pathSegment]), node === null || node === void 0 ? void 0 : node.extensions);\n}\nfunction _getDirectiveInExtensions(directivesInExtensions, directiveName) {\n    const directiveInExtensions = directivesInExtensions.filter(directiveAnnotation => directiveAnnotation.name === directiveName);\n    if (!directiveInExtensions.length) {\n        return undefined;\n    }\n    return directiveInExtensions.map(directive => { var _a; return (_a = directive.args) !== null && _a !== void 0 ? _a : {}; });\n}\nfunction getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ['directives']) {\n    const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => (acc == null ? acc : acc[pathSegment]), node === null || node === void 0 ? void 0 : node.extensions);\n    if (directivesInExtensions === undefined) {\n        return undefined;\n    }\n    if (Array.isArray(directivesInExtensions)) {\n        return _getDirectiveInExtensions(directivesInExtensions, directiveName);\n    }\n    // Support condensed format by converting to longer format\n    // The condensed format does not preserve ordering of directives when  repeatable directives are used.\n    // See https://github.com/ardatan/graphql-tools/issues/2534\n    const reformattedDirectivesInExtensions = [];\n    for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {\n        if (Array.isArray(argsOrArrayOfArgs)) {\n            for (const args of argsOrArrayOfArgs) {\n                reformattedDirectivesInExtensions.push({ name, args });\n            }\n        }\n        else {\n            reformattedDirectivesInExtensions.push({ name, args: argsOrArrayOfArgs });\n        }\n    }\n    return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);\n}\nfunction getDirectives(schema, node, pathToDirectivesInExtensions = ['directives']) {\n    const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);\n    if (directivesInExtensions != null && directivesInExtensions.length > 0) {\n        return directivesInExtensions;\n    }\n    const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];\n    const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap, schemaDirective) => {\n        schemaDirectiveMap[schemaDirective.name] = schemaDirective;\n        return schemaDirectiveMap;\n    }, {});\n    let astNodes = [];\n    if (node.astNode) {\n        astNodes.push(node.astNode);\n    }\n    if ('extensionASTNodes' in node && node.extensionASTNodes) {\n        astNodes = [...astNodes, ...node.extensionASTNodes];\n    }\n    const result = [];\n    for (const astNode of astNodes) {\n        if (astNode.directives) {\n            for (const directiveNode of astNode.directives) {\n                const schemaDirective = schemaDirectiveMap[directiveNode.name.value];\n                if (schemaDirective) {\n                    result.push({ name: directiveNode.name.value, args: getArgumentValues(schemaDirective, directiveNode) });\n                }\n            }\n        }\n    }\n    return result;\n}\nfunction getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ['directives']) {\n    const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);\n    if (directiveInExtensions != null) {\n        return directiveInExtensions;\n    }\n    const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : undefined;\n    if (schemaDirective == null) {\n        return undefined;\n    }\n    let astNodes = [];\n    if (node.astNode) {\n        astNodes.push(node.astNode);\n    }\n    if ('extensionASTNodes' in node && node.extensionASTNodes) {\n        astNodes = [...astNodes, ...node.extensionASTNodes];\n    }\n    const result = [];\n    for (const astNode of astNodes) {\n        if (astNode.directives) {\n            for (const directiveNode of astNode.directives) {\n                if (directiveNode.name.value === directiveName) {\n                    result.push(getArgumentValues(schemaDirective, directiveNode));\n                }\n            }\n        }\n    }\n    if (!result.length) {\n        return undefined;\n    }\n    return result;\n}\n\nfunction parseDirectiveValue(value) {\n    switch (value.kind) {\n        case graphql.Kind.INT:\n            return parseInt(value.value);\n        case graphql.Kind.FLOAT:\n            return parseFloat(value.value);\n        case graphql.Kind.BOOLEAN:\n            return Boolean(value.value);\n        case graphql.Kind.STRING:\n        case graphql.Kind.ENUM:\n            return value.value;\n        case graphql.Kind.LIST:\n            return value.values.map(v => parseDirectiveValue(v));\n        case graphql.Kind.OBJECT:\n            return value.fields.reduce((prev, v) => ({ ...prev, [v.name.value]: parseDirectiveValue(v.value) }), {});\n        case graphql.Kind.NULL:\n            return null;\n        default:\n            return null;\n    }\n}\nfunction getFieldsWithDirectives(documentNode, options = {}) {\n    const result = {};\n    let selected = ['ObjectTypeDefinition', 'ObjectTypeExtension'];\n    if (options.includeInputTypes) {\n        selected = [...selected, 'InputObjectTypeDefinition', 'InputObjectTypeExtension'];\n    }\n    const allTypes = documentNode.definitions.filter(obj => selected.includes(obj.kind));\n    for (const type of allTypes) {\n        const typeName = type.name.value;\n        if (type.fields == null) {\n            continue;\n        }\n        for (const field of type.fields) {\n            if (field.directives && field.directives.length > 0) {\n                const fieldName = field.name.value;\n                const key = `${typeName}.${fieldName}`;\n                const directives = field.directives.map(d => ({\n                    name: d.name.value,\n                    args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: parseDirectiveValue(arg.value) }), {}),\n                }));\n                result[key] = directives;\n            }\n        }\n    }\n    return result;\n}\n\nfunction getImplementingTypes(interfaceName, schema) {\n    const allTypesMap = schema.getTypeMap();\n    const result = [];\n    for (const graphqlTypeName in allTypesMap) {\n        const graphqlType = allTypesMap[graphqlTypeName];\n        if (graphql.isObjectType(graphqlType)) {\n            const allInterfaces = graphqlType.getInterfaces();\n            if (allInterfaces.find(int => int.name === interfaceName)) {\n                result.push(graphqlType.name);\n            }\n        }\n    }\n    return result;\n}\n\nfunction astFromType(type) {\n    if (graphql.isNonNullType(type)) {\n        const innerType = astFromType(type.ofType);\n        if (innerType.kind === graphql.Kind.NON_NULL_TYPE) {\n            throw new Error(`Invalid type node ${inspect(type)}. Inner type of non-null type cannot be a non-null type.`);\n        }\n        return {\n            kind: graphql.Kind.NON_NULL_TYPE,\n            type: innerType,\n        };\n    }\n    else if (graphql.isListType(type)) {\n        return {\n            kind: graphql.Kind.LIST_TYPE,\n            type: astFromType(type.ofType),\n        };\n    }\n    return {\n        kind: graphql.Kind.NAMED_TYPE,\n        name: {\n            kind: graphql.Kind.NAME,\n            value: type.name,\n        },\n    };\n}\n\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using the following mapping.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String               |\n * | Number        | Int / Float          |\n * | null          | NullValue            |\n *\n */\nfunction astFromValueUntyped(value) {\n    // only explicit null, not undefined, NaN\n    if (value === null) {\n        return { kind: graphql.Kind.NULL };\n    }\n    // undefined\n    if (value === undefined) {\n        return null;\n    }\n    // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n    // the value is not an array, convert the value using the list's item type.\n    if (Array.isArray(value)) {\n        const valuesNodes = [];\n        for (const item of value) {\n            const itemNode = astFromValueUntyped(item);\n            if (itemNode != null) {\n                valuesNodes.push(itemNode);\n            }\n        }\n        return { kind: graphql.Kind.LIST, values: valuesNodes };\n    }\n    if (typeof value === 'object') {\n        const fieldNodes = [];\n        for (const fieldName in value) {\n            const fieldValue = value[fieldName];\n            const ast = astFromValueUntyped(fieldValue);\n            if (ast) {\n                fieldNodes.push({\n                    kind: graphql.Kind.OBJECT_FIELD,\n                    name: { kind: graphql.Kind.NAME, value: fieldName },\n                    value: ast,\n                });\n            }\n        }\n        return { kind: graphql.Kind.OBJECT, fields: fieldNodes };\n    }\n    // Others serialize based on their corresponding JavaScript scalar types.\n    if (typeof value === 'boolean') {\n        return { kind: graphql.Kind.BOOLEAN, value };\n    }\n    // JavaScript numbers can be Int or Float values.\n    if (typeof value === 'number' && isFinite(value)) {\n        const stringNum = String(value);\n        return integerStringRegExp.test(stringNum)\n            ? { kind: graphql.Kind.INT, value: stringNum }\n            : { kind: graphql.Kind.FLOAT, value: stringNum };\n    }\n    if (typeof value === 'string') {\n        return { kind: graphql.Kind.STRING, value };\n    }\n    throw new TypeError(`Cannot convert value to AST: ${value}.`);\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n\nfunction memoize1(fn) {\n    const memoize1cache = new WeakMap();\n    return function memoized(a1) {\n        const cachedValue = memoize1cache.get(a1);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1);\n            memoize1cache.set(a1, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nfunction memoize2(fn) {\n    const memoize2cache = new WeakMap();\n    return function memoized(a1, a2) {\n        let cache2 = memoize2cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize2cache.set(a1, cache2);\n            const newValue = fn(a1, a2);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        const cachedValue = cache2.get(a2);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nfunction memoize3(fn) {\n    const memoize3Cache = new WeakMap();\n    return function memoized(a1, a2, a3) {\n        let cache2 = memoize3Cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize3Cache.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        const cachedValue = cache3.get(a3);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nfunction memoize4(fn) {\n    const memoize4Cache = new WeakMap();\n    return function memoized(a1, a2, a3, a4) {\n        let cache2 = memoize4Cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize4Cache.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        const cache4 = cache3.get(a3);\n        if (!cache4) {\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        const cachedValue = cache4.get(a4);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nfunction memoize5(fn) {\n    const memoize5Cache = new WeakMap();\n    return function memoized(a1, a2, a3, a4, a5) {\n        let cache2 = memoize5Cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize5Cache.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        let cache4 = cache3.get(a3);\n        if (!cache4) {\n            cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        let cache5 = cache4.get(a4);\n        if (!cache5) {\n            cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        const cachedValue = cache5.get(a5);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nconst memoize2of4cache = new WeakMap();\nfunction memoize2of4(fn) {\n    return function memoized(a1, a2, a3, a4) {\n        let cache2 = memoize2of4cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize2of4cache.set(a1, cache2);\n            const newValue = fn(a1, a2, a3, a4);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        const cachedValue = cache2.get(a2);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\n\nfunction getDefinedRootType(schema, operation) {\n    const rootTypeMap = getRootTypeMap(schema);\n    const rootType = rootTypeMap.get(operation);\n    if (rootType == null) {\n        throw new Error(`Root type for operation \"${operation}\" not defined by the given schema.`);\n    }\n    return rootType;\n}\nconst getRootTypeNames = memoize1(function getRootTypeNames(schema) {\n    const rootTypes = getRootTypes(schema);\n    return new Set([...rootTypes].map(type => type.name));\n});\nconst getRootTypes = memoize1(function getRootTypes(schema) {\n    const rootTypeMap = getRootTypeMap(schema);\n    return new Set(rootTypeMap.values());\n});\nconst getRootTypeMap = memoize1(function getRootTypeMap(schema) {\n    const rootTypeMap = new Map();\n    const queryType = schema.getQueryType();\n    if (queryType) {\n        rootTypeMap.set('query', queryType);\n    }\n    const mutationType = schema.getMutationType();\n    if (mutationType) {\n        rootTypeMap.set('mutation', mutationType);\n    }\n    const subscriptionType = schema.getSubscriptionType();\n    if (subscriptionType) {\n        rootTypeMap.set('subscription', subscriptionType);\n    }\n    return rootTypeMap;\n});\n\nfunction getDocumentNodeFromSchema(schema, options = {}) {\n    const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;\n    const typesMap = schema.getTypeMap();\n    const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);\n    const definitions = schemaNode != null ? [schemaNode] : [];\n    const directives = schema.getDirectives();\n    for (const directive of directives) {\n        if (graphql.isSpecifiedDirective(directive)) {\n            continue;\n        }\n        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));\n    }\n    for (const typeName in typesMap) {\n        const type = typesMap[typeName];\n        const isPredefinedScalar = graphql.isSpecifiedScalarType(type);\n        const isIntrospection = graphql.isIntrospectionType(type);\n        if (isPredefinedScalar || isIntrospection) {\n            continue;\n        }\n        if (graphql.isObjectType(type)) {\n            definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (graphql.isInterfaceType(type)) {\n            definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (graphql.isUnionType(type)) {\n            definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (graphql.isInputObjectType(type)) {\n            definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (graphql.isEnumType(type)) {\n            definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (graphql.isScalarType(type)) {\n            definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));\n        }\n        else {\n            throw new Error(`Unknown type ${type}.`);\n        }\n    }\n    return {\n        kind: graphql.Kind.DOCUMENT,\n        definitions,\n    };\n}\n// this approach uses the default schema printer rather than a custom solution, so may be more backwards compatible\n// currently does not allow customization of printSchema options having to do with comments.\nfunction printSchemaWithDirectives(schema, options = {}) {\n    const documentNode = getDocumentNodeFromSchema(schema, options);\n    return graphql.print(documentNode);\n}\nfunction astFromSchema(schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    const operationTypeMap = new Map([\n        ['query', undefined],\n        ['mutation', undefined],\n        ['subscription', undefined],\n    ]);\n    const nodes = [];\n    if (schema.astNode != null) {\n        nodes.push(schema.astNode);\n    }\n    if (schema.extensionASTNodes != null) {\n        for (const extensionASTNode of schema.extensionASTNodes) {\n            nodes.push(extensionASTNode);\n        }\n    }\n    for (const node of nodes) {\n        if (node.operationTypes) {\n            for (const operationTypeDefinitionNode of node.operationTypes) {\n                operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);\n            }\n        }\n    }\n    const rootTypeMap = getRootTypeMap(schema);\n    for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {\n        const rootType = rootTypeMap.get(operationTypeNode);\n        if (rootType != null) {\n            const rootTypeAST = astFromType(rootType);\n            if (operationTypeDefinitionNode != null) {\n                operationTypeDefinitionNode.type = rootTypeAST;\n            }\n            else {\n                operationTypeMap.set(operationTypeNode, {\n                    kind: graphql.Kind.OPERATION_TYPE_DEFINITION,\n                    operation: operationTypeNode,\n                    type: rootTypeAST,\n                });\n            }\n        }\n    }\n    const operationTypes = [...operationTypeMap.values()].filter(isSome);\n    const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);\n    if (!operationTypes.length && !directives.length) {\n        return null;\n    }\n    const schemaNode = {\n        kind: operationTypes != null ? graphql.Kind.SCHEMA_DEFINITION : graphql.Kind.SCHEMA_EXTENSION,\n        operationTypes,\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: directives,\n    };\n    // This code is so weird because it needs to support GraphQL.js 14\n    // In GraphQL.js 14 there is no `description` value on schemaNode\n    schemaNode.description =\n        ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null)\n            ? {\n                kind: graphql.Kind.STRING,\n                value: schema.description,\n                block: true,\n            }\n            : undefined;\n    return schemaNode;\n}\nfunction astFromDirective(directive, schema, pathToDirectivesInExtensions) {\n    var _a, _b, _c, _d;\n    return {\n        kind: graphql.Kind.DIRECTIVE_DEFINITION,\n        description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (directive.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: directive.description,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: directive.name,\n        },\n        arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n        repeatable: directive.isRepeatable,\n        locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map(location => ({\n            kind: graphql.Kind.NAME,\n            value: location,\n        }))) || [],\n    };\n}\nfunction getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n    const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n    let nodes = [];\n    if (entity.astNode != null) {\n        nodes.push(entity.astNode);\n    }\n    if ('extensionASTNodes' in entity && entity.extensionASTNodes != null) {\n        nodes = nodes.concat(entity.extensionASTNodes);\n    }\n    let directives;\n    if (directivesInExtensions != null) {\n        directives = makeDirectiveNodes(schema, directivesInExtensions);\n    }\n    else {\n        directives = [];\n        for (const node of nodes) {\n            if (node.directives) {\n                directives.push(...node.directives);\n            }\n        }\n    }\n    return directives;\n}\nfunction getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    let directiveNodesBesidesDeprecated = [];\n    let deprecatedDirectiveNode = null;\n    const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n    let directives;\n    if (directivesInExtensions != null) {\n        directives = makeDirectiveNodes(schema, directivesInExtensions);\n    }\n    else {\n        directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;\n    }\n    if (directives != null) {\n        directiveNodesBesidesDeprecated = directives.filter(directive => directive.name.value !== 'deprecated');\n        if (entity.deprecationReason != null) {\n            deprecatedDirectiveNode = (_b = directives.filter(directive => directive.name.value === 'deprecated')) === null || _b === void 0 ? void 0 : _b[0];\n        }\n    }\n    if (entity.deprecationReason != null &&\n        deprecatedDirectiveNode == null) {\n        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);\n    }\n    return deprecatedDirectiveNode == null\n        ? directiveNodesBesidesDeprecated\n        : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);\n}\nfunction astFromArg(arg, schema, pathToDirectivesInExtensions) {\n    var _a, _b, _c;\n    return {\n        kind: graphql.Kind.INPUT_VALUE_DEFINITION,\n        description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (arg.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: arg.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: arg.name,\n        },\n        type: astFromType(arg.type),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        defaultValue: arg.defaultValue !== undefined ? (_c = graphql.astFromValue(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : undefined : undefined,\n        directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction astFromObjectType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: graphql.Kind.OBJECT_TYPE_DEFINITION,\n        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (type.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n        interfaces: Object.values(type.getInterfaces()).map(iFace => astFromType(iFace)),\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    const node = {\n        kind: graphql.Kind.INTERFACE_TYPE_DEFINITION,\n        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (type.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n    if ('getInterfaces' in type) {\n        node.interfaces = Object.values(type.getInterfaces()).map(iFace => astFromType(iFace));\n    }\n    return node;\n}\nfunction astFromUnionType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: graphql.Kind.UNION_TYPE_DEFINITION,\n        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (type.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: type.name,\n        },\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n        types: type.getTypes().map(type => astFromType(type)),\n    };\n}\nfunction astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (type.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(field => astFromInputField(field, schema, pathToDirectivesInExtensions)),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction astFromEnumType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: graphql.Kind.ENUM_TYPE_DEFINITION,\n        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (type.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: type.name,\n        },\n        values: Object.values(type.getValues()).map(value => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction astFromScalarType(type, schema, pathToDirectivesInExtensions) {\n    var _a, _b, _c;\n    const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);\n    const directives = directivesInExtensions\n        ? makeDirectiveNodes(schema, directivesInExtensions)\n        : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];\n    const specifiedByValue = (type['specifiedByUrl'] || type['specifiedByURL']);\n    if (specifiedByValue && !directives.some(directiveNode => directiveNode.name.value === 'specifiedBy')) {\n        const specifiedByArgs = {\n            url: specifiedByValue,\n        };\n        directives.push(makeDirectiveNode('specifiedBy', specifiedByArgs));\n    }\n    return {\n        kind: graphql.Kind.SCALAR_TYPE_DEFINITION,\n        description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : (type.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: type.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: type.name,\n        },\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: directives,\n    };\n}\nfunction astFromField(field, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: graphql.Kind.FIELD_DEFINITION,\n        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (field.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: field.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: field.name,\n        },\n        arguments: field.args.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n        type: astFromType(field.type),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction astFromInputField(field, schema, pathToDirectivesInExtensions) {\n    var _a, _b, _c;\n    return {\n        kind: graphql.Kind.INPUT_VALUE_DEFINITION,\n        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (field.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: field.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: field.name,\n        },\n        type: astFromType(field.type),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n        defaultValue: (_c = graphql.astFromValue(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : undefined,\n    };\n}\nfunction astFromEnumValue(value, schema, pathToDirectivesInExtensions) {\n    var _a, _b;\n    return {\n        kind: graphql.Kind.ENUM_VALUE_DEFINITION,\n        description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : (value.description\n            ? {\n                kind: graphql.Kind.STRING,\n                value: value.description,\n                block: true,\n            }\n            : undefined),\n        name: {\n            kind: graphql.Kind.NAME,\n            value: value.name,\n        },\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions),\n    };\n}\nfunction makeDeprecatedDirective(deprecationReason) {\n    return makeDirectiveNode('deprecated', { reason: deprecationReason }, graphql.GraphQLDeprecatedDirective);\n}\nfunction makeDirectiveNode(name, args, directive) {\n    const directiveArguments = [];\n    if (directive != null) {\n        for (const arg of directive.args) {\n            const argName = arg.name;\n            const argValue = args[argName];\n            if (argValue !== undefined) {\n                const value = graphql.astFromValue(argValue, arg.type);\n                if (value) {\n                    directiveArguments.push({\n                        kind: graphql.Kind.ARGUMENT,\n                        name: {\n                            kind: graphql.Kind.NAME,\n                            value: argName,\n                        },\n                        value,\n                    });\n                }\n            }\n        }\n    }\n    else {\n        for (const argName in args) {\n            const argValue = args[argName];\n            const value = astFromValueUntyped(argValue);\n            if (value) {\n                directiveArguments.push({\n                    kind: graphql.Kind.ARGUMENT,\n                    name: {\n                        kind: graphql.Kind.NAME,\n                        value: argName,\n                    },\n                    value,\n                });\n            }\n        }\n    }\n    return {\n        kind: graphql.Kind.DIRECTIVE,\n        name: {\n            kind: graphql.Kind.NAME,\n            value: name,\n        },\n        arguments: directiveArguments,\n    };\n}\nfunction makeDirectiveNodes(schema, directiveValues) {\n    const directiveNodes = [];\n    for (const directiveName in directiveValues) {\n        const arrayOrSingleValue = directiveValues[directiveName];\n        const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);\n        if (Array.isArray(arrayOrSingleValue)) {\n            for (const value of arrayOrSingleValue) {\n                directiveNodes.push(makeDirectiveNode(directiveName, value, directive));\n            }\n        }\n        else {\n            directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));\n        }\n    }\n    return directiveNodes;\n}\n\nasync function validateGraphQlDocuments(schema, documentFiles, effectiveRules = createDefaultRules()) {\n    const allFragmentMap = new Map();\n    const documentFileObjectsToValidate = [];\n    for (const documentFile of documentFiles) {\n        if (documentFile.document) {\n            const definitionsToValidate = [];\n            for (const definitionNode of documentFile.document.definitions) {\n                if (definitionNode.kind === graphql.Kind.FRAGMENT_DEFINITION) {\n                    allFragmentMap.set(definitionNode.name.value, definitionNode);\n                }\n                else {\n                    definitionsToValidate.push(definitionNode);\n                }\n            }\n            documentFileObjectsToValidate.push({\n                location: documentFile.location,\n                document: {\n                    kind: graphql.Kind.DOCUMENT,\n                    definitions: definitionsToValidate,\n                },\n            });\n        }\n    }\n    const allErrors = [];\n    const allFragmentsDocument = {\n        kind: graphql.Kind.DOCUMENT,\n        definitions: [...allFragmentMap.values()],\n    };\n    await Promise.all(documentFileObjectsToValidate.map(async (documentFile) => {\n        const documentToValidate = graphql.concatAST([allFragmentsDocument, documentFile.document]);\n        const errors = graphql.validate(schema, documentToValidate, effectiveRules);\n        if (errors.length > 0) {\n            allErrors.push({\n                filePath: documentFile.location,\n                errors,\n            });\n        }\n    }));\n    return allErrors;\n}\nfunction checkValidationErrors(loadDocumentErrors) {\n    if (loadDocumentErrors.length > 0) {\n        const errors = [];\n        for (const loadDocumentError of loadDocumentErrors) {\n            for (const graphQLError of loadDocumentError.errors) {\n                const error = new Error();\n                error.name = 'GraphQLDocumentError';\n                error.message = `${error.name}: ${graphQLError.message}`;\n                error.stack = error.message;\n                if (graphQLError.locations) {\n                    for (const location of graphQLError.locations) {\n                        error.stack += `\\n    at ${loadDocumentError.filePath}:${location.line}:${location.column}`;\n                    }\n                }\n                errors.push(error);\n            }\n        }\n        throw new exports.AggregateError(errors, `GraphQL Document Validation failed with ${errors.length} errors;\n  ${errors.map((error, index) => `Error ${index}: ${error.stack}`).join('\\n\\n')}`);\n    }\n}\nfunction createDefaultRules() {\n    let ignored = ['NoUnusedFragmentsRule', 'NoUnusedVariablesRule', 'KnownDirectivesRule'];\n    if (graphql.versionInfo.major < 15) {\n        ignored = ignored.map(rule => rule.replace(/Rule$/, ''));\n    }\n    return graphql.specifiedRules.filter((f) => !ignored.includes(f.name));\n}\n\nfunction stripBOM(content) {\n    content = content.toString();\n    // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n    // because the buffer-to-string conversion in `fs.readFileSync()`\n    // translates it to FEFF, the UTF-16 BOM.\n    if (content.charCodeAt(0) === 0xfeff) {\n        content = content.slice(1);\n    }\n    return content;\n}\nfunction parseBOM(content) {\n    return JSON.parse(stripBOM(content));\n}\nfunction parseGraphQLJSON(location, jsonContent, options) {\n    let parsedJson = parseBOM(jsonContent);\n    if (parsedJson.data) {\n        parsedJson = parsedJson.data;\n    }\n    if (parsedJson.kind === 'Document') {\n        return {\n            location,\n            document: parsedJson,\n        };\n    }\n    else if (parsedJson.__schema) {\n        const schema = graphql.buildClientSchema(parsedJson, options);\n        return {\n            location,\n            schema,\n        };\n    }\n    else if (typeof parsedJson === 'string') {\n        return {\n            location,\n            rawSDL: parsedJson,\n        };\n    }\n    throw new Error(`Not valid JSON content`);\n}\n\nconst MAX_LINE_LENGTH = 80;\nlet commentsRegistry = {};\nfunction resetComments() {\n    commentsRegistry = {};\n}\nfunction collectComment(node) {\n    var _a;\n    const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;\n    if (entityName == null) {\n        return;\n    }\n    pushComment(node, entityName);\n    switch (node.kind) {\n        case 'EnumTypeDefinition':\n            if (node.values) {\n                for (const value of node.values) {\n                    pushComment(value, entityName, value.name.value);\n                }\n            }\n            break;\n        case 'ObjectTypeDefinition':\n        case 'InputObjectTypeDefinition':\n        case 'InterfaceTypeDefinition':\n            if (node.fields) {\n                for (const field of node.fields) {\n                    pushComment(field, entityName, field.name.value);\n                    if (isFieldDefinitionNode(field) && field.arguments) {\n                        for (const arg of field.arguments) {\n                            pushComment(arg, entityName, field.name.value, arg.name.value);\n                        }\n                    }\n                }\n            }\n            break;\n    }\n}\nfunction pushComment(node, entity, field, argument) {\n    const comment = getComment(node);\n    if (typeof comment !== 'string' || comment.length === 0) {\n        return;\n    }\n    const keys = [entity];\n    if (field) {\n        keys.push(field);\n        if (argument) {\n            keys.push(argument);\n        }\n    }\n    const path = keys.join('.');\n    if (!commentsRegistry[path]) {\n        commentsRegistry[path] = [];\n    }\n    commentsRegistry[path].push(comment);\n}\nfunction printComment(comment) {\n    return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n    return maybeArray ? maybeArray.filter(x => x).join(separator || '') : '';\n}\nfunction hasMultilineItems(maybeArray) {\n    var _a;\n    return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some(str => str.includes('\\n'))) !== null && _a !== void 0 ? _a : false;\n}\nfunction addDescription(cb) {\n    return (node, _key, _parent, path, ancestors) => {\n        var _a;\n        const keys = [];\n        const parent = path.reduce((prev, key) => {\n            if (['fields', 'arguments', 'values'].includes(key) && prev.name) {\n                keys.push(prev.name.value);\n            }\n            return prev[key];\n        }, ancestors[0]);\n        const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join('.');\n        const items = [];\n        if (node.kind.includes('Definition') && commentsRegistry[key]) {\n            items.push(...commentsRegistry[key]);\n        }\n        return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], '\\n');\n    };\n}\nfunction indent(maybeString) {\n    return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\nfunction block(array) {\n    return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n    return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\nfunction printBlockString(value, isDescription = false) {\n    const escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n    return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1\n        ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"`\n        : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\nconst printDocASTReducer = {\n    Name: { leave: node => node.value },\n    Variable: { leave: node => '$' + node.name },\n    // Document\n    Document: {\n        leave: node => join(node.definitions, '\\n\\n'),\n    },\n    OperationDefinition: {\n        leave: node => {\n            const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n            const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, ' ')], ' ');\n            // the query short form.\n            return prefix + ' ' + node.selectionSet;\n        },\n    },\n    VariableDefinition: {\n        leave: ({ variable, type, defaultValue, directives }) => variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' ')),\n    },\n    SelectionSet: { leave: ({ selections }) => block(selections) },\n    Field: {\n        leave({ alias, name, arguments: args, directives, selectionSet }) {\n            const prefix = wrap('', alias, ': ') + name;\n            let argsLine = prefix + wrap('(', join(args, ', '), ')');\n            if (argsLine.length > MAX_LINE_LENGTH) {\n                argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n            }\n            return join([argsLine, join(directives, ' '), selectionSet], ' ');\n        },\n    },\n    Argument: { leave: ({ name, value }) => name + ': ' + value },\n    // Fragments\n    FragmentSpread: {\n        leave: ({ name, directives }) => '...' + name + wrap(' ', join(directives, ' ')),\n    },\n    InlineFragment: {\n        leave: ({ typeCondition, directives, selectionSet }) => join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' '),\n    },\n    FragmentDefinition: {\n        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => \n        // Note: fragment variable definitions are experimental and may be changed\n        // or removed in the future.\n        `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` +\n            `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` +\n            selectionSet,\n    },\n    // Value\n    IntValue: { leave: ({ value }) => value },\n    FloatValue: { leave: ({ value }) => value },\n    StringValue: {\n        leave: ({ value, block: isBlockString }) => {\n            if (isBlockString) {\n                return printBlockString(value);\n            }\n            return JSON.stringify(value);\n        },\n    },\n    BooleanValue: { leave: ({ value }) => (value ? 'true' : 'false') },\n    NullValue: { leave: () => 'null' },\n    EnumValue: { leave: ({ value }) => value },\n    ListValue: { leave: ({ values }) => '[' + join(values, ', ') + ']' },\n    ObjectValue: { leave: ({ fields }) => '{' + join(fields, ', ') + '}' },\n    ObjectField: { leave: ({ name, value }) => name + ': ' + value },\n    // Directive\n    Directive: {\n        leave: ({ name, arguments: args }) => '@' + name + wrap('(', join(args, ', '), ')'),\n    },\n    // Type\n    NamedType: { leave: ({ name }) => name },\n    ListType: { leave: ({ type }) => '[' + type + ']' },\n    NonNullType: { leave: ({ type }) => type + '!' },\n    // Type System Definitions\n    SchemaDefinition: {\n        leave: ({ directives, operationTypes }) => join(['schema', join(directives, ' '), block(operationTypes)], ' '),\n    },\n    OperationTypeDefinition: {\n        leave: ({ operation, type }) => operation + ': ' + type,\n    },\n    ScalarTypeDefinition: {\n        leave: ({ name, directives }) => join(['scalar', name, join(directives, ' ')], ' '),\n    },\n    ObjectTypeDefinition: {\n        leave: ({ name, interfaces, directives, fields }) => join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    FieldDefinition: {\n        leave: ({ name, arguments: args, type, directives }) => name +\n            (hasMultilineItems(args)\n                ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n                : wrap('(', join(args, ', '), ')')) +\n            ': ' +\n            type +\n            wrap(' ', join(directives, ' ')),\n    },\n    InputValueDefinition: {\n        leave: ({ name, type, defaultValue, directives }) => join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' '),\n    },\n    InterfaceTypeDefinition: {\n        leave: ({ name, interfaces, directives, fields }) => join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    UnionTypeDefinition: {\n        leave: ({ name, directives, types }) => join(['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' '),\n    },\n    EnumTypeDefinition: {\n        leave: ({ name, directives, values }) => join(['enum', name, join(directives, ' '), block(values)], ' '),\n    },\n    EnumValueDefinition: {\n        leave: ({ name, directives }) => join([name, join(directives, ' ')], ' '),\n    },\n    InputObjectTypeDefinition: {\n        leave: ({ name, directives, fields }) => join(['input', name, join(directives, ' '), block(fields)], ' '),\n    },\n    DirectiveDefinition: {\n        leave: ({ name, arguments: args, repeatable, locations }) => 'directive @' +\n            name +\n            (hasMultilineItems(args)\n                ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n                : wrap('(', join(args, ', '), ')')) +\n            (repeatable ? ' repeatable' : '') +\n            ' on ' +\n            join(locations, ' | '),\n    },\n    SchemaExtension: {\n        leave: ({ directives, operationTypes }) => join(['extend schema', join(directives, ' '), block(operationTypes)], ' '),\n    },\n    ScalarTypeExtension: {\n        leave: ({ name, directives }) => join(['extend scalar', name, join(directives, ' ')], ' '),\n    },\n    ObjectTypeExtension: {\n        leave: ({ name, interfaces, directives, fields }) => join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    InterfaceTypeExtension: {\n        leave: ({ name, interfaces, directives, fields }) => join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    UnionTypeExtension: {\n        leave: ({ name, directives, types }) => join(['extend union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' '),\n    },\n    EnumTypeExtension: {\n        leave: ({ name, directives, values }) => join(['extend enum', name, join(directives, ' '), block(values)], ' '),\n    },\n    InputObjectTypeExtension: {\n        leave: ({ name, directives, fields }) => join(['extend input', name, join(directives, ' '), block(fields)], ' '),\n    },\n};\nconst printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({\n    ...prev,\n    [key]: {\n        leave: addDescription(printDocASTReducer[key].leave),\n    },\n}), {});\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nfunction printWithComments(ast) {\n    return graphql.visit(ast, printDocASTReducerWithComments);\n}\nfunction isFieldDefinitionNode(node) {\n    return node.kind === 'FieldDefinition';\n}\n// graphql < v13 and > v15 does not export getDescription\nfunction getDescription(node, options) {\n    if (node.description != null) {\n        return node.description.value;\n    }\n    if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {\n        return getComment(node);\n    }\n}\nfunction getComment(node) {\n    const rawValue = getLeadingCommentBlock(node);\n    if (rawValue !== undefined) {\n        return dedentBlockStringValue(`\\n${rawValue}`);\n    }\n}\nfunction getLeadingCommentBlock(node) {\n    const loc = node.loc;\n    if (!loc) {\n        return;\n    }\n    const comments = [];\n    let token = loc.startToken.prev;\n    while (token != null &&\n        token.kind === graphql.TokenKind.COMMENT &&\n        token.next != null &&\n        token.prev != null &&\n        token.line + 1 === token.next.line &&\n        token.line !== token.prev.line) {\n        const value = String(token.value);\n        comments.push(value);\n        token = token.prev;\n    }\n    return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\nfunction dedentBlockStringValue(rawString) {\n    // Expand a block string's raw value into independent lines.\n    const lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n    // Remove common indentation from all lines but first.\n    const commonIndent = getBlockStringIndentation(lines);\n    if (commonIndent !== 0) {\n        for (let i = 1; i < lines.length; i++) {\n            lines[i] = lines[i].slice(commonIndent);\n        }\n    }\n    // Remove leading and trailing blank lines.\n    while (lines.length > 0 && isBlank(lines[0])) {\n        lines.shift();\n    }\n    while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n        lines.pop();\n    }\n    // Return a string of the lines joined with U+000A.\n    return lines.join('\\n');\n}\n/**\n * @internal\n */\nfunction getBlockStringIndentation(lines) {\n    let commonIndent = null;\n    for (let i = 1; i < lines.length; i++) {\n        const line = lines[i];\n        const indent = leadingWhitespace(line);\n        if (indent === line.length) {\n            continue; // skip empty lines\n        }\n        if (commonIndent === null || indent < commonIndent) {\n            commonIndent = indent;\n            if (commonIndent === 0) {\n                break;\n            }\n        }\n    }\n    return commonIndent === null ? 0 : commonIndent;\n}\nfunction leadingWhitespace(str) {\n    let i = 0;\n    while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n        i++;\n    }\n    return i;\n}\nfunction isBlank(str) {\n    return leadingWhitespace(str) === str.length;\n}\n\nfunction parseGraphQLSDL(location, rawSDL, options = {}) {\n    let document;\n    try {\n        if (options.commentDescriptions && rawSDL.includes('#')) {\n            document = transformCommentsToDescriptions(rawSDL, options);\n            // If noLocation=true, we need to make sure to print and parse it again, to remove locations,\n            // since `transformCommentsToDescriptions` must have locations set in order to transform the comments\n            // into descriptions.\n            if (options.noLocation) {\n                document = graphql.parse(graphql.print(document), options);\n            }\n        }\n        else {\n            document = graphql.parse(new graphql.Source(rawSDL, location), options);\n        }\n    }\n    catch (e) {\n        if (e.message.includes('EOF') && rawSDL.replace(/(\\#[^*]*)/g, '').trim() === '') {\n            document = {\n                kind: graphql.Kind.DOCUMENT,\n                definitions: [],\n            };\n        }\n        else {\n            throw e;\n        }\n    }\n    return {\n        location,\n        document,\n    };\n}\nfunction transformCommentsToDescriptions(sourceSdl, options = {}) {\n    const parsedDoc = graphql.parse(sourceSdl, {\n        ...options,\n        noLocation: false,\n    });\n    const modifiedDoc = graphql.visit(parsedDoc, {\n        leave: (node) => {\n            if (isDescribable(node)) {\n                const rawValue = getLeadingCommentBlock(node);\n                if (rawValue !== undefined) {\n                    const commentsBlock = dedentBlockStringValue('\\n' + rawValue);\n                    const isBlock = commentsBlock.includes('\\n');\n                    if (!node.description) {\n                        return {\n                            ...node,\n                            description: {\n                                kind: graphql.Kind.STRING,\n                                value: commentsBlock,\n                                block: isBlock,\n                            },\n                        };\n                    }\n                    else {\n                        return {\n                            ...node,\n                            description: {\n                                ...node.description,\n                                value: node.description.value + '\\n' + commentsBlock,\n                                block: true,\n                            },\n                        };\n                    }\n                }\n            }\n        },\n    });\n    return modifiedDoc;\n}\nfunction isDescribable(node) {\n    return (graphql.isTypeSystemDefinitionNode(node) ||\n        node.kind === graphql.Kind.FIELD_DEFINITION ||\n        node.kind === graphql.Kind.INPUT_VALUE_DEFINITION ||\n        node.kind === graphql.Kind.ENUM_VALUE_DEFINITION);\n}\n\nlet operationVariables = [];\nlet fieldTypeMap = new Map();\nfunction addOperationVariable(variable) {\n    operationVariables.push(variable);\n}\nfunction resetOperationVariables() {\n    operationVariables = [];\n}\nfunction resetFieldMap() {\n    fieldTypeMap = new Map();\n}\nfunction buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true, }) {\n    resetOperationVariables();\n    resetFieldMap();\n    const rootTypeNames = getRootTypeNames(schema);\n    const operationNode = buildOperationAndCollectVariables({\n        schema,\n        fieldName: field,\n        kind,\n        models: models || [],\n        ignore,\n        depthLimit: depthLimit || Infinity,\n        circularReferenceDepth: circularReferenceDepth || 1,\n        argNames,\n        selectedFields,\n        rootTypeNames,\n    });\n    // attach variables\n    operationNode.variableDefinitions = [...operationVariables];\n    resetOperationVariables();\n    resetFieldMap();\n    return operationNode;\n}\nfunction buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames, }) {\n    const type = getDefinedRootType(schema, kind);\n    const field = type.getFields()[fieldName];\n    const operationName = `${fieldName}_${kind}`;\n    if (field.args) {\n        for (const arg of field.args) {\n            const argName = arg.name;\n            if (!argNames || argNames.includes(argName)) {\n                addOperationVariable(resolveVariable(arg, argName));\n            }\n        }\n    }\n    return {\n        kind: graphql.Kind.OPERATION_DEFINITION,\n        operation: kind,\n        name: {\n            kind: graphql.Kind.NAME,\n            value: operationName,\n        },\n        variableDefinitions: [],\n        selectionSet: {\n            kind: graphql.Kind.SELECTION_SET,\n            selections: [\n                resolveField({\n                    type,\n                    field,\n                    models,\n                    firstCall: true,\n                    path: [],\n                    ancestors: [],\n                    ignore,\n                    depthLimit,\n                    circularReferenceDepth,\n                    schema,\n                    depth: 0,\n                    argNames,\n                    selectedFields,\n                    rootTypeNames,\n                }),\n            ],\n        },\n    };\n}\nfunction resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames, }) {\n    if (typeof selectedFields === 'boolean' && depth > depthLimit) {\n        return;\n    }\n    if (graphql.isUnionType(type)) {\n        const types = type.getTypes();\n        return {\n            kind: graphql.Kind.SELECTION_SET,\n            selections: types\n                .filter(t => !hasCircularRef([...ancestors, t], {\n                depth: circularReferenceDepth,\n            }))\n                .map(t => {\n                return {\n                    kind: graphql.Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: graphql.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql.Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models,\n                        path,\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields,\n                        rootTypeNames,\n                    }),\n                };\n            })\n                .filter(fragmentNode => { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if (graphql.isInterfaceType(type)) {\n        const types = Object.values(schema.getTypeMap()).filter((t) => graphql.isObjectType(t) && t.getInterfaces().includes(type));\n        return {\n            kind: graphql.Kind.SELECTION_SET,\n            selections: types\n                .filter(t => !hasCircularRef([...ancestors, t], {\n                depth: circularReferenceDepth,\n            }))\n                .map(t => {\n                return {\n                    kind: graphql.Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: graphql.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql.Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models,\n                        path,\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields,\n                        rootTypeNames,\n                    }),\n                };\n            })\n                .filter(fragmentNode => { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if (graphql.isObjectType(type) && !rootTypeNames.has(type.name)) {\n        const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);\n        const isModel = models.includes(type.name);\n        if (!firstCall && isModel && !isIgnored) {\n            return {\n                kind: graphql.Kind.SELECTION_SET,\n                selections: [\n                    {\n                        kind: graphql.Kind.FIELD,\n                        name: {\n                            kind: graphql.Kind.NAME,\n                            value: 'id',\n                        },\n                    },\n                ],\n            };\n        }\n        const fields = type.getFields();\n        return {\n            kind: graphql.Kind.SELECTION_SET,\n            selections: Object.keys(fields)\n                .filter(fieldName => {\n                return !hasCircularRef([...ancestors, graphql.getNamedType(fields[fieldName].type)], {\n                    depth: circularReferenceDepth,\n                });\n            })\n                .map(fieldName => {\n                const selectedSubFields = typeof selectedFields === 'object' ? selectedFields[fieldName] : true;\n                if (selectedSubFields) {\n                    return resolveField({\n                        type: type,\n                        field: fields[fieldName],\n                        models,\n                        path: [...path, fieldName],\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields: selectedSubFields,\n                        rootTypeNames,\n                    });\n                }\n                return null;\n            })\n                .filter((f) => {\n                var _a, _b;\n                if (f == null) {\n                    return false;\n                }\n                else if ('selectionSet' in f) {\n                    return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);\n                }\n                return true;\n            }),\n        };\n    }\n}\nfunction resolveVariable(arg, name) {\n    function resolveVariableType(type) {\n        if (graphql.isListType(type)) {\n            return {\n                kind: graphql.Kind.LIST_TYPE,\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        if (graphql.isNonNullType(type)) {\n            return {\n                kind: graphql.Kind.NON_NULL_TYPE,\n                // for v16 compatibility\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        return {\n            kind: graphql.Kind.NAMED_TYPE,\n            name: {\n                kind: graphql.Kind.NAME,\n                value: type.name,\n            },\n        };\n    }\n    return {\n        kind: graphql.Kind.VARIABLE_DEFINITION,\n        variable: {\n            kind: graphql.Kind.VARIABLE,\n            name: {\n                kind: graphql.Kind.NAME,\n                value: name || arg.name,\n            },\n        },\n        type: resolveVariableType(arg.type),\n    };\n}\nfunction getArgumentName(name, path) {\n    return [...path, name].join('_');\n}\nfunction resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames, }) {\n    const namedType = graphql.getNamedType(field.type);\n    let args = [];\n    let removeField = false;\n    if (field.args && field.args.length) {\n        args = field.args\n            .map(arg => {\n            const argumentName = getArgumentName(arg.name, path);\n            if (argNames && !argNames.includes(argumentName)) {\n                if (graphql.isNonNullType(arg.type)) {\n                    removeField = true;\n                }\n                return null;\n            }\n            if (!firstCall) {\n                addOperationVariable(resolveVariable(arg, argumentName));\n            }\n            return {\n                kind: graphql.Kind.ARGUMENT,\n                name: {\n                    kind: graphql.Kind.NAME,\n                    value: arg.name,\n                },\n                value: {\n                    kind: graphql.Kind.VARIABLE,\n                    name: {\n                        kind: graphql.Kind.NAME,\n                        value: getArgumentName(arg.name, path),\n                    },\n                },\n            };\n        })\n            .filter(Boolean);\n    }\n    if (removeField) {\n        return null;\n    }\n    const fieldPath = [...path, field.name];\n    const fieldPathStr = fieldPath.join('.');\n    let fieldName = field.name;\n    if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {\n        fieldName += field.type.toString().replace('!', 'NonNull');\n    }\n    fieldTypeMap.set(fieldPathStr, field.type.toString());\n    if (!graphql.isScalarType(namedType) && !graphql.isEnumType(namedType)) {\n        return {\n            kind: graphql.Kind.FIELD,\n            name: {\n                kind: graphql.Kind.NAME,\n                value: field.name,\n            },\n            ...(fieldName !== field.name && { alias: { kind: graphql.Kind.NAME, value: fieldName } }),\n            selectionSet: resolveSelectionSet({\n                parent: type,\n                type: namedType,\n                models,\n                firstCall,\n                path: fieldPath,\n                ancestors: [...ancestors, type],\n                ignore,\n                depthLimit,\n                circularReferenceDepth,\n                schema,\n                depth: depth + 1,\n                argNames,\n                selectedFields,\n                rootTypeNames,\n            }) || undefined,\n            arguments: args,\n        };\n    }\n    return {\n        kind: graphql.Kind.FIELD,\n        name: {\n            kind: graphql.Kind.NAME,\n            value: field.name,\n        },\n        ...(fieldName !== field.name && { alias: { kind: graphql.Kind.NAME, value: fieldName } }),\n        arguments: args,\n    };\n}\nfunction hasCircularRef(types, config = {\n    depth: 1,\n}) {\n    const type = types[types.length - 1];\n    if (graphql.isScalarType(type)) {\n        return false;\n    }\n    const size = types.filter(t => t.name === type.name).length;\n    return size > config.depth;\n}\n\n(function (MapperKind) {\n    MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\n    MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\n    MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\n    MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\n    MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\n    MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\n    MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\n    MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\n    MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\n    MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\n    MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\n    MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\n    MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\n    MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\n    MapperKind[\"FIELD\"] = \"MapperKind.FIELD\";\n    MapperKind[\"COMPOSITE_FIELD\"] = \"MapperKind.COMPOSITE_FIELD\";\n    MapperKind[\"OBJECT_FIELD\"] = \"MapperKind.OBJECT_FIELD\";\n    MapperKind[\"ROOT_FIELD\"] = \"MapperKind.ROOT_FIELD\";\n    MapperKind[\"QUERY_ROOT_FIELD\"] = \"MapperKind.QUERY_ROOT_FIELD\";\n    MapperKind[\"MUTATION_ROOT_FIELD\"] = \"MapperKind.MUTATION_ROOT_FIELD\";\n    MapperKind[\"SUBSCRIPTION_ROOT_FIELD\"] = \"MapperKind.SUBSCRIPTION_ROOT_FIELD\";\n    MapperKind[\"INTERFACE_FIELD\"] = \"MapperKind.INTERFACE_FIELD\";\n    MapperKind[\"INPUT_OBJECT_FIELD\"] = \"MapperKind.INPUT_OBJECT_FIELD\";\n    MapperKind[\"ARGUMENT\"] = \"MapperKind.ARGUMENT\";\n    MapperKind[\"ENUM_VALUE\"] = \"MapperKind.ENUM_VALUE\";\n})(exports.MapperKind || (exports.MapperKind = {}));\n\nfunction getObjectTypeFromTypeMap(typeMap, type) {\n    if (type) {\n        const maybeObjectType = typeMap[type.name];\n        if (graphql.isObjectType(maybeObjectType)) {\n            return maybeObjectType;\n        }\n    }\n}\n\nfunction createNamedStub(name, type) {\n    let constructor;\n    if (type === 'object') {\n        constructor = graphql.GraphQLObjectType;\n    }\n    else if (type === 'interface') {\n        constructor = graphql.GraphQLInterfaceType;\n    }\n    else {\n        constructor = graphql.GraphQLInputObjectType;\n    }\n    return new constructor({\n        name,\n        fields: {\n            _fake: {\n                type: graphql.GraphQLString,\n            },\n        },\n    });\n}\nfunction createStub(node, type) {\n    switch (node.kind) {\n        case graphql.Kind.LIST_TYPE:\n            return new graphql.GraphQLList(createStub(node.type, type));\n        case graphql.Kind.NON_NULL_TYPE:\n            return new graphql.GraphQLNonNull(createStub(node.type, type));\n        default:\n            if (type === 'output') {\n                return createNamedStub(node.name.value, 'object');\n            }\n            return createNamedStub(node.name.value, 'input');\n    }\n}\nfunction isNamedStub(type) {\n    if ('getFields' in type) {\n        const fields = type.getFields();\n        // eslint-disable-next-line no-unreachable-loop\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            return field.name === '_fake';\n        }\n    }\n    return false;\n}\nfunction getBuiltInForStub(type) {\n    switch (type.name) {\n        case graphql.GraphQLInt.name:\n            return graphql.GraphQLInt;\n        case graphql.GraphQLFloat.name:\n            return graphql.GraphQLFloat;\n        case graphql.GraphQLString.name:\n            return graphql.GraphQLString;\n        case graphql.GraphQLBoolean.name:\n            return graphql.GraphQLBoolean;\n        case graphql.GraphQLID.name:\n            return graphql.GraphQLID;\n        default:\n            return type;\n    }\n}\n\nfunction rewireTypes(originalTypeMap, directives) {\n    const referenceTypeMap = Object.create(null);\n    for (const typeName in originalTypeMap) {\n        referenceTypeMap[typeName] = originalTypeMap[typeName];\n    }\n    const newTypeMap = Object.create(null);\n    for (const typeName in referenceTypeMap) {\n        const namedType = referenceTypeMap[typeName];\n        if (namedType == null || typeName.startsWith('__')) {\n            continue;\n        }\n        const newName = namedType.name;\n        if (newName.startsWith('__')) {\n            continue;\n        }\n        if (newTypeMap[newName] != null) {\n            throw new Error(`Duplicate schema type name ${newName}`);\n        }\n        newTypeMap[newName] = namedType;\n    }\n    for (const typeName in newTypeMap) {\n        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n    }\n    const newDirectives = directives.map(directive => rewireDirective(directive));\n    return {\n        typeMap: newTypeMap,\n        directives: newDirectives,\n    };\n    function rewireDirective(directive) {\n        if (graphql.isSpecifiedDirective(directive)) {\n            return directive;\n        }\n        const directiveConfig = directive.toConfig();\n        directiveConfig.args = rewireArgs(directiveConfig.args);\n        return new graphql.GraphQLDirective(directiveConfig);\n    }\n    function rewireArgs(args) {\n        const rewiredArgs = {};\n        for (const argName in args) {\n            const arg = args[argName];\n            const rewiredArgType = rewireType(arg.type);\n            if (rewiredArgType != null) {\n                arg.type = rewiredArgType;\n                rewiredArgs[argName] = arg;\n            }\n        }\n        return rewiredArgs;\n    }\n    function rewireNamedType(type) {\n        if (graphql.isObjectType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireFields(config.fields),\n                interfaces: () => rewireNamedTypes(config.interfaces),\n            };\n            return new graphql.GraphQLObjectType(newConfig);\n        }\n        else if (graphql.isInterfaceType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireFields(config.fields),\n            };\n            if ('interfaces' in newConfig) {\n                newConfig.interfaces = () => rewireNamedTypes(config.interfaces);\n            }\n            return new graphql.GraphQLInterfaceType(newConfig);\n        }\n        else if (graphql.isUnionType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                types: () => rewireNamedTypes(config.types),\n            };\n            return new graphql.GraphQLUnionType(newConfig);\n        }\n        else if (graphql.isInputObjectType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireInputFields(config.fields),\n            };\n            return new graphql.GraphQLInputObjectType(newConfig);\n        }\n        else if (graphql.isEnumType(type)) {\n            const enumConfig = type.toConfig();\n            return new graphql.GraphQLEnumType(enumConfig);\n        }\n        else if (graphql.isScalarType(type)) {\n            if (graphql.isSpecifiedScalarType(type)) {\n                return type;\n            }\n            const scalarConfig = type.toConfig();\n            return new graphql.GraphQLScalarType(scalarConfig);\n        }\n        throw new Error(`Unexpected schema type: ${type}`);\n    }\n    function rewireFields(fields) {\n        const rewiredFields = {};\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            const rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null && field.args) {\n                field.type = rewiredFieldType;\n                field.args = rewireArgs(field.args);\n                rewiredFields[fieldName] = field;\n            }\n        }\n        return rewiredFields;\n    }\n    function rewireInputFields(fields) {\n        const rewiredFields = {};\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            const rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null) {\n                field.type = rewiredFieldType;\n                rewiredFields[fieldName] = field;\n            }\n        }\n        return rewiredFields;\n    }\n    function rewireNamedTypes(namedTypes) {\n        const rewiredTypes = [];\n        for (const namedType of namedTypes) {\n            const rewiredType = rewireType(namedType);\n            if (rewiredType != null) {\n                rewiredTypes.push(rewiredType);\n            }\n        }\n        return rewiredTypes;\n    }\n    function rewireType(type) {\n        if (graphql.isListType(type)) {\n            const rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new graphql.GraphQLList(rewiredType) : null;\n        }\n        else if (graphql.isNonNullType(type)) {\n            const rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new graphql.GraphQLNonNull(rewiredType) : null;\n        }\n        else if (graphql.isNamedType(type)) {\n            let rewiredType = referenceTypeMap[type.name];\n            if (rewiredType === undefined) {\n                rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);\n                newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;\n            }\n            return rewiredType != null ? newTypeMap[rewiredType.name] : null;\n        }\n        return null;\n    }\n}\n\nfunction transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {\n    if (value == null) {\n        return value;\n    }\n    const nullableType = graphql.getNullableType(type);\n    if (graphql.isLeafType(nullableType)) {\n        return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;\n    }\n    else if (graphql.isListType(nullableType)) {\n        return value.map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));\n    }\n    else if (graphql.isInputObjectType(nullableType)) {\n        const fields = nullableType.getFields();\n        const newValue = {};\n        for (const key in value) {\n            const field = fields[key];\n            if (field != null) {\n                newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);\n            }\n        }\n        return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;\n    }\n    // unreachable, no other possible return value\n}\nfunction serializeInputValue(type, value) {\n    return transformInputValue(type, value, (t, v) => {\n        try {\n            return t.serialize(v);\n        }\n        catch (_a) {\n            return v;\n        }\n    });\n}\nfunction parseInputValue(type, value) {\n    return transformInputValue(type, value, (t, v) => {\n        try {\n            return t.parseValue(v);\n        }\n        catch (_a) {\n            return v;\n        }\n    });\n}\nfunction parseInputValueLiteral(type, value) {\n    return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));\n}\n\nfunction mapSchema(schema, schemaMapper = {}) {\n    const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, type => graphql.isLeafType(type)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, type => !graphql.isLeafType(type)), schema, schemaMapper), schema, schemaMapper);\n    const originalDirectives = schema.getDirectives();\n    const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n    const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);\n    return new graphql.GraphQLSchema({\n        ...schema.toConfig(),\n        query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),\n        mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),\n        subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),\n        types: Object.values(typeMap),\n        directives,\n    });\n}\nfunction mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (originalType == null || !testFn(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n            if (typeMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const maybeNewType = typeMapper(originalType, schema);\n            if (maybeNewType === undefined) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            newTypeMap[typeName] = maybeNewType;\n        }\n    }\n    return newTypeMap;\n}\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n    const enumValueMapper = getEnumValueMapper(schemaMapper);\n    if (!enumValueMapper) {\n        return originalTypeMap;\n    }\n    return mapTypes(originalTypeMap, schema, {\n        [exports.MapperKind.ENUM_TYPE]: type => {\n            const config = type.toConfig();\n            const originalEnumValueConfigMap = config.values;\n            const newEnumValueConfigMap = {};\n            for (const externalValue in originalEnumValueConfigMap) {\n                const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n                const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n                if (mappedEnumValue === undefined) {\n                    newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n                }\n                else if (Array.isArray(mappedEnumValue)) {\n                    const [newExternalValue, newEnumValueConfig] = mappedEnumValue;\n                    newEnumValueConfigMap[newExternalValue] =\n                        newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n                }\n                else if (mappedEnumValue !== null) {\n                    newEnumValueConfigMap[externalValue] = mappedEnumValue;\n                }\n            }\n            return correctASTNodes(new graphql.GraphQLEnumType({\n                ...config,\n                values: newEnumValueConfigMap,\n            }));\n        },\n    }, type => graphql.isEnumType(type));\n}\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n    const newTypeMap = mapArguments(originalTypeMap, schema, {\n        [exports.MapperKind.ARGUMENT]: argumentConfig => {\n            if (argumentConfig.defaultValue === undefined) {\n                return argumentConfig;\n            }\n            const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...argumentConfig,\n                    defaultValue: fn(maybeNewType, argumentConfig.defaultValue),\n                };\n            }\n        },\n    });\n    return mapFields(newTypeMap, schema, {\n        [exports.MapperKind.INPUT_OBJECT_FIELD]: inputFieldConfig => {\n            if (inputFieldConfig.defaultValue === undefined) {\n                return inputFieldConfig;\n            }\n            const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...inputFieldConfig,\n                    defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue),\n                };\n            }\n        },\n    });\n}\nfunction getNewType(newTypeMap, type) {\n    if (graphql.isListType(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new graphql.GraphQLList(newType) : null;\n    }\n    else if (graphql.isNonNullType(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new graphql.GraphQLNonNull(newType) : null;\n    }\n    else if (graphql.isNamedType(type)) {\n        const newType = newTypeMap[type.name];\n        return newType != null ? newType : null;\n    }\n    return null;\n}\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!graphql.isObjectType(originalType) && !graphql.isInterfaceType(originalType) && !graphql.isInputObjectType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n            if (fieldMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            for (const fieldName in originalFieldConfigMap) {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n                if (mappedField === undefined) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                }\n                else if (Array.isArray(mappedField)) {\n                    const [newFieldName, newFieldConfig] = mappedField;\n                    if (newFieldConfig.astNode != null) {\n                        newFieldConfig.astNode = {\n                            ...newFieldConfig.astNode,\n                            name: {\n                                ...newFieldConfig.astNode.name,\n                                value: newFieldName,\n                            },\n                        };\n                    }\n                    newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n                }\n                else if (mappedField !== null) {\n                    newFieldConfigMap[fieldName] = mappedField;\n                }\n            }\n            if (graphql.isObjectType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else if (graphql.isInterfaceType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else {\n                newTypeMap[typeName] = correctASTNodes(new graphql.GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        }\n    }\n    return newTypeMap;\n}\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!graphql.isObjectType(originalType) && !graphql.isInterfaceType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const argumentMapper = getArgumentMapper(schemaMapper);\n            if (argumentMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            for (const fieldName in originalFieldConfigMap) {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const originalArgumentConfigMap = originalFieldConfig.args;\n                if (originalArgumentConfigMap == null) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    continue;\n                }\n                const argumentNames = Object.keys(originalArgumentConfigMap);\n                if (!argumentNames.length) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    continue;\n                }\n                const newArgumentConfigMap = {};\n                for (const argumentName of argumentNames) {\n                    const originalArgumentConfig = originalArgumentConfigMap[argumentName];\n                    const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n                    if (mappedArgument === undefined) {\n                        newArgumentConfigMap[argumentName] = originalArgumentConfig;\n                    }\n                    else if (Array.isArray(mappedArgument)) {\n                        const [newArgumentName, newArgumentConfig] = mappedArgument;\n                        newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n                    }\n                    else if (mappedArgument !== null) {\n                        newArgumentConfigMap[argumentName] = mappedArgument;\n                    }\n                }\n                newFieldConfigMap[fieldName] = {\n                    ...originalFieldConfig,\n                    args: newArgumentConfigMap,\n                };\n            }\n            if (graphql.isObjectType(originalType)) {\n                newTypeMap[typeName] = new graphql.GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else if (graphql.isInterfaceType(originalType)) {\n                newTypeMap[typeName] = new graphql.GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else {\n                newTypeMap[typeName] = new graphql.GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n        }\n    }\n    return newTypeMap;\n}\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n    const directiveMapper = getDirectiveMapper(schemaMapper);\n    if (directiveMapper == null) {\n        return originalDirectives.slice();\n    }\n    const newDirectives = [];\n    for (const directive of originalDirectives) {\n        const mappedDirective = directiveMapper(directive, schema);\n        if (mappedDirective === undefined) {\n            newDirectives.push(directive);\n        }\n        else if (mappedDirective !== null) {\n            newDirectives.push(mappedDirective);\n        }\n    }\n    return newDirectives;\n}\nfunction getTypeSpecifiers(schema, typeName) {\n    var _a, _b, _c;\n    const type = schema.getType(typeName);\n    const specifiers = [exports.MapperKind.TYPE];\n    if (graphql.isObjectType(type)) {\n        specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.OBJECT_TYPE);\n        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n            specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.QUERY);\n        }\n        else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n            specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.MUTATION);\n        }\n        else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n            specifiers.push(exports.MapperKind.ROOT_OBJECT, exports.MapperKind.SUBSCRIPTION);\n        }\n    }\n    else if (graphql.isInputObjectType(type)) {\n        specifiers.push(exports.MapperKind.INPUT_OBJECT_TYPE);\n    }\n    else if (graphql.isInterfaceType(type)) {\n        specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.ABSTRACT_TYPE, exports.MapperKind.INTERFACE_TYPE);\n    }\n    else if (graphql.isUnionType(type)) {\n        specifiers.push(exports.MapperKind.COMPOSITE_TYPE, exports.MapperKind.ABSTRACT_TYPE, exports.MapperKind.UNION_TYPE);\n    }\n    else if (graphql.isEnumType(type)) {\n        specifiers.push(exports.MapperKind.ENUM_TYPE);\n    }\n    else if (graphql.isScalarType(type)) {\n        specifiers.push(exports.MapperKind.SCALAR_TYPE);\n    }\n    return specifiers;\n}\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n    const specifiers = getTypeSpecifiers(schema, typeName);\n    let typeMapper;\n    const stack = [...specifiers];\n    while (!typeMapper && stack.length > 0) {\n        // It is safe to use the ! operator here as we check the length.\n        const next = stack.pop();\n        typeMapper = schemaMapper[next];\n    }\n    return typeMapper != null ? typeMapper : null;\n}\nfunction getFieldSpecifiers(schema, typeName) {\n    var _a, _b, _c;\n    const type = schema.getType(typeName);\n    const specifiers = [exports.MapperKind.FIELD];\n    if (graphql.isObjectType(type)) {\n        specifiers.push(exports.MapperKind.COMPOSITE_FIELD, exports.MapperKind.OBJECT_FIELD);\n        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n            specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.QUERY_ROOT_FIELD);\n        }\n        else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n            specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.MUTATION_ROOT_FIELD);\n        }\n        else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n            specifiers.push(exports.MapperKind.ROOT_FIELD, exports.MapperKind.SUBSCRIPTION_ROOT_FIELD);\n        }\n    }\n    else if (graphql.isInterfaceType(type)) {\n        specifiers.push(exports.MapperKind.COMPOSITE_FIELD, exports.MapperKind.INTERFACE_FIELD);\n    }\n    else if (graphql.isInputObjectType(type)) {\n        specifiers.push(exports.MapperKind.INPUT_OBJECT_FIELD);\n    }\n    return specifiers;\n}\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n    const specifiers = getFieldSpecifiers(schema, typeName);\n    let fieldMapper;\n    const stack = [...specifiers];\n    while (!fieldMapper && stack.length > 0) {\n        // It is safe to use the ! operator here as we check the length.\n        const next = stack.pop();\n        // TODO: fix this as unknown cast\n        fieldMapper = schemaMapper[next];\n    }\n    return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;\n}\nfunction getArgumentMapper(schemaMapper) {\n    const argumentMapper = schemaMapper[exports.MapperKind.ARGUMENT];\n    return argumentMapper != null ? argumentMapper : null;\n}\nfunction getDirectiveMapper(schemaMapper) {\n    const directiveMapper = schemaMapper[exports.MapperKind.DIRECTIVE];\n    return directiveMapper != null ? directiveMapper : null;\n}\nfunction getEnumValueMapper(schemaMapper) {\n    const enumValueMapper = schemaMapper[exports.MapperKind.ENUM_VALUE];\n    return enumValueMapper != null ? enumValueMapper : null;\n}\nfunction correctASTNodes(type) {\n    if (graphql.isObjectType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: graphql.Kind.OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: graphql.Kind.OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new graphql.GraphQLObjectType(config);\n    }\n    else if (graphql.isInterfaceType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: graphql.Kind.INTERFACE_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: graphql.Kind.INTERFACE_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new graphql.GraphQLInterfaceType(config);\n    }\n    else if (graphql.isInputObjectType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new graphql.GraphQLInputObjectType(config);\n    }\n    else if (graphql.isEnumType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const values = [];\n            for (const enumKey in config.values) {\n                const enumValueConfig = config.values[enumKey];\n                if (enumValueConfig.astNode != null) {\n                    values.push(enumValueConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                values,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                values: undefined,\n            }));\n        }\n        return new graphql.GraphQLEnumType(config);\n    }\n    else {\n        return type;\n    }\n}\n\nfunction filterSchema({ schema, typeFilter = () => true, fieldFilter = undefined, rootFieldFilter = undefined, objectFieldFilter = undefined, interfaceFieldFilter = undefined, inputObjectFieldFilter = undefined, argumentFilter = undefined, }) {\n    const filteredSchema = mapSchema(schema, {\n        [exports.MapperKind.QUERY]: (type) => filterRootFields(type, 'Query', rootFieldFilter, argumentFilter),\n        [exports.MapperKind.MUTATION]: (type) => filterRootFields(type, 'Mutation', rootFieldFilter, argumentFilter),\n        [exports.MapperKind.SUBSCRIPTION]: (type) => filterRootFields(type, 'Subscription', rootFieldFilter, argumentFilter),\n        [exports.MapperKind.OBJECT_TYPE]: (type) => typeFilter(type.name, type)\n            ? filterElementFields(graphql.GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter)\n            : null,\n        [exports.MapperKind.INTERFACE_TYPE]: (type) => typeFilter(type.name, type)\n            ? filterElementFields(graphql.GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter)\n            : null,\n        [exports.MapperKind.INPUT_OBJECT_TYPE]: (type) => typeFilter(type.name, type)\n            ? filterElementFields(graphql.GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter)\n            : null,\n        [exports.MapperKind.UNION_TYPE]: (type) => (typeFilter(type.name, type) ? undefined : null),\n        [exports.MapperKind.ENUM_TYPE]: (type) => (typeFilter(type.name, type) ? undefined : null),\n        [exports.MapperKind.SCALAR_TYPE]: (type) => (typeFilter(type.name, type) ? undefined : null),\n    });\n    return filteredSchema;\n}\nfunction filterRootFields(type, operation, rootFieldFilter, argumentFilter) {\n    if (rootFieldFilter || argumentFilter) {\n        const config = type.toConfig();\n        for (const fieldName in config.fields) {\n            const field = config.fields[fieldName];\n            if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {\n                delete config.fields[fieldName];\n            }\n            else if (argumentFilter && field.args) {\n                for (const argName in field.args) {\n                    if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {\n                        delete field.args[argName];\n                    }\n                }\n            }\n        }\n        return new graphql.GraphQLObjectType(config);\n    }\n    return type;\n}\nfunction filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {\n    if (fieldFilter || argumentFilter) {\n        const config = type.toConfig();\n        for (const fieldName in config.fields) {\n            const field = config.fields[fieldName];\n            if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {\n                delete config.fields[fieldName];\n            }\n            else if (argumentFilter && 'args' in field) {\n                for (const argName in field.args) {\n                    if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {\n                        delete field.args[argName];\n                    }\n                }\n            }\n        }\n        return new ElementConstructor(config);\n    }\n}\n\n// Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n//\n// healSchema and its callers (visitSchema/visitSchemaDirectives) all modify the schema in place.\n// Therefore, private variables (such as the stored implementation map and the proper root types)\n// are not updated.\n//\n// If this causes issues, the schema could be more aggressively healed as follows:\n//\n// healSchema(schema);\n// const config = schema.toConfig()\n// const healedSchema = new GraphQLSchema({\n//   ...config,\n//   query: schema.getType('<desired new root query type name>'),\n//   mutation: schema.getType('<desired new root mutation type name>'),\n//   subscription: schema.getType('<desired new root subscription type name>'),\n// });\n//\n// One can then also -- if necessary --  assign the correct private variables to the initial schema\n// as follows:\n// Object.assign(schema, healedSchema);\n//\n// These steps are not taken automatically to preserve backwards compatibility with graphql-tools v4.\n// See https://github.com/ardatan/graphql-tools/issues/1462\n//\n// They were briefly taken in v5, but can now be phased out as they were only required when other\n// areas of the codebase were using healSchema and visitSchema more extensively.\n//\nfunction healSchema(schema) {\n    healTypes(schema.getTypeMap(), schema.getDirectives());\n    return schema;\n}\nfunction healTypes(originalTypeMap, directives) {\n    const actualNamedTypeMap = Object.create(null);\n    // If any of the .name properties of the GraphQLNamedType objects in\n    // schema.getTypeMap() have changed, the keys of the type map need to\n    // be updated accordingly.\n    for (const typeName in originalTypeMap) {\n        const namedType = originalTypeMap[typeName];\n        if (namedType == null || typeName.startsWith('__')) {\n            continue;\n        }\n        const actualName = namedType.name;\n        if (actualName.startsWith('__')) {\n            continue;\n        }\n        if (actualName in actualNamedTypeMap) {\n            throw new Error(`Duplicate schema type name ${actualName}`);\n        }\n        actualNamedTypeMap[actualName] = namedType;\n        // Note: we are deliberately leaving namedType in the schema by its\n        // original name (which might be different from actualName), so that\n        // references by that name can be healed.\n    }\n    // Now add back every named type by its actual name.\n    for (const typeName in actualNamedTypeMap) {\n        const namedType = actualNamedTypeMap[typeName];\n        originalTypeMap[typeName] = namedType;\n    }\n    // Directive declaration argument types can refer to named types.\n    for (const decl of directives) {\n        decl.args = decl.args.filter(arg => {\n            arg.type = healType(arg.type);\n            return arg.type !== null;\n        });\n    }\n    for (const typeName in originalTypeMap) {\n        const namedType = originalTypeMap[typeName];\n        // Heal all named types, except for dangling references, kept only to redirect.\n        if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\n            if (namedType != null) {\n                healNamedType(namedType);\n            }\n        }\n    }\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\n            delete originalTypeMap[typeName];\n        }\n    }\n    function healNamedType(type) {\n        if (graphql.isObjectType(type)) {\n            healFields(type);\n            healInterfaces(type);\n            return;\n        }\n        else if (graphql.isInterfaceType(type)) {\n            healFields(type);\n            if ('getInterfaces' in type) {\n                healInterfaces(type);\n            }\n            return;\n        }\n        else if (graphql.isUnionType(type)) {\n            healUnderlyingTypes(type);\n            return;\n        }\n        else if (graphql.isInputObjectType(type)) {\n            healInputFields(type);\n            return;\n        }\n        else if (graphql.isLeafType(type)) {\n            return;\n        }\n        throw new Error(`Unexpected schema type: ${type}`);\n    }\n    function healFields(type) {\n        const fieldMap = type.getFields();\n        for (const [key, field] of Object.entries(fieldMap)) {\n            field.args\n                .map(arg => {\n                arg.type = healType(arg.type);\n                return arg.type === null ? null : arg;\n            })\n                .filter(Boolean);\n            field.type = healType(field.type);\n            if (field.type === null) {\n                delete fieldMap[key];\n            }\n        }\n    }\n    function healInterfaces(type) {\n        if ('getInterfaces' in type) {\n            const interfaces = type.getInterfaces();\n            interfaces.push(...interfaces\n                .splice(0)\n                .map(iface => healType(iface))\n                .filter(Boolean));\n        }\n    }\n    function healInputFields(type) {\n        const fieldMap = type.getFields();\n        for (const [key, field] of Object.entries(fieldMap)) {\n            field.type = healType(field.type);\n            if (field.type === null) {\n                delete fieldMap[key];\n            }\n        }\n    }\n    function healUnderlyingTypes(type) {\n        const types = type.getTypes();\n        types.push(...types\n            .splice(0)\n            .map(t => healType(t))\n            .filter(Boolean));\n    }\n    function healType(type) {\n        // Unwrap the two known wrapper types\n        if (graphql.isListType(type)) {\n            const healedType = healType(type.ofType);\n            return healedType != null ? new graphql.GraphQLList(healedType) : null;\n        }\n        else if (graphql.isNonNullType(type)) {\n            const healedType = healType(type.ofType);\n            return healedType != null ? new graphql.GraphQLNonNull(healedType) : null;\n        }\n        else if (graphql.isNamedType(type)) {\n            // If a type annotation on a field or an argument or a union member is\n            // any `GraphQLNamedType` with a `name`, then it must end up identical\n            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n            // of truth for all named schema types.\n            // Note that new types can still be simply added by adding a field, as\n            // the official type will be undefined, not null.\n            const officialType = originalTypeMap[type.name];\n            if (officialType && type !== officialType) {\n                return officialType;\n            }\n        }\n        return type;\n    }\n}\n\nfunction getResolversFromSchema(schema) {\n    var _a, _b;\n    const resolvers = Object.create(null);\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        if (!typeName.startsWith('__')) {\n            const type = typeMap[typeName];\n            if (graphql.isScalarType(type)) {\n                if (!graphql.isSpecifiedScalarType(type)) {\n                    const config = type.toConfig();\n                    delete config.astNode; // avoid AST duplication elsewhere\n                    resolvers[typeName] = new graphql.GraphQLScalarType(config);\n                }\n            }\n            else if (graphql.isEnumType(type)) {\n                resolvers[typeName] = {};\n                const values = type.getValues();\n                for (const value of values) {\n                    resolvers[typeName][value.name] = value.value;\n                }\n            }\n            else if (graphql.isInterfaceType(type)) {\n                if (type.resolveType != null) {\n                    resolvers[typeName] = {\n                        __resolveType: type.resolveType,\n                    };\n                }\n            }\n            else if (graphql.isUnionType(type)) {\n                if (type.resolveType != null) {\n                    resolvers[typeName] = {\n                        __resolveType: type.resolveType,\n                    };\n                }\n            }\n            else if (graphql.isObjectType(type)) {\n                resolvers[typeName] = {};\n                if (type.isTypeOf != null) {\n                    resolvers[typeName].__isTypeOf = type.isTypeOf;\n                }\n                const fields = type.getFields();\n                for (const fieldName in fields) {\n                    const field = fields[fieldName];\n                    if (field.subscribe != null) {\n                        resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};\n                        resolvers[typeName][fieldName].subscribe = field.subscribe;\n                    }\n                    if (field.resolve != null &&\n                        ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== 'defaultFieldResolver' &&\n                        ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) !== 'defaultMergedResolver') {\n                        resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};\n                        resolvers[typeName][fieldName].resolve = field.resolve;\n                    }\n                }\n            }\n        }\n    }\n    return resolvers;\n}\n\nfunction forEachField(schema, fn) {\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = typeMap[typeName];\n        // TODO: maybe have an option to include these?\n        if (!graphql.getNamedType(type).name.startsWith('__') && graphql.isObjectType(type)) {\n            const fields = type.getFields();\n            for (const fieldName in fields) {\n                const field = fields[fieldName];\n                fn(field, typeName, fieldName);\n            }\n        }\n    }\n}\n\nfunction forEachDefaultValue(schema, fn) {\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = typeMap[typeName];\n        if (!graphql.getNamedType(type).name.startsWith('__')) {\n            if (graphql.isObjectType(type)) {\n                const fields = type.getFields();\n                for (const fieldName in fields) {\n                    const field = fields[fieldName];\n                    for (const arg of field.args) {\n                        arg.defaultValue = fn(arg.type, arg.defaultValue);\n                    }\n                }\n            }\n            else if (graphql.isInputObjectType(type)) {\n                const fields = type.getFields();\n                for (const fieldName in fields) {\n                    const field = fields[fieldName];\n                    field.defaultValue = fn(field.type, field.defaultValue);\n                }\n            }\n        }\n    }\n}\n\n// addTypes uses toConfig to create a new schema with a new or replaced\nfunction addTypes(schema, newTypesOrDirectives) {\n    const config = schema.toConfig();\n    const originalTypeMap = {};\n    for (const type of config.types) {\n        originalTypeMap[type.name] = type;\n    }\n    const originalDirectiveMap = {};\n    for (const directive of config.directives) {\n        originalDirectiveMap[directive.name] = directive;\n    }\n    for (const newTypeOrDirective of newTypesOrDirectives) {\n        if (graphql.isNamedType(newTypeOrDirective)) {\n            originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;\n        }\n        else if (graphql.isDirective(newTypeOrDirective)) {\n            originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;\n        }\n    }\n    const { typeMap, directives } = rewireTypes(originalTypeMap, Object.values(originalDirectiveMap));\n    return new graphql.GraphQLSchema({\n        ...config,\n        query: getObjectTypeFromTypeMap(typeMap, schema.getQueryType()),\n        mutation: getObjectTypeFromTypeMap(typeMap, schema.getMutationType()),\n        subscription: getObjectTypeFromTypeMap(typeMap, schema.getSubscriptionType()),\n        types: Object.values(typeMap),\n        directives,\n    });\n}\n\n/**\n * Prunes the provided schema, removing unused and empty types\n * @param schema The schema to prune\n * @param options Additional options for removing unused types from the schema\n */\nfunction pruneSchema(schema, options = {}) {\n    const { skipEmptyCompositeTypePruning, skipEmptyUnionPruning, skipPruning, skipUnimplementedInterfacesPruning, skipUnusedTypesPruning, } = options;\n    let prunedTypes = []; // Pruned types during mapping\n    let prunedSchema = schema;\n    do {\n        let visited = visitSchema(prunedSchema);\n        // Custom pruning  was defined, so we need to pre-emptively revisit the schema accounting for this\n        if (skipPruning) {\n            const revisit = [];\n            for (const typeName in prunedSchema.getTypeMap()) {\n                if (typeName.startsWith('__')) {\n                    continue;\n                }\n                const type = prunedSchema.getType(typeName);\n                // if we want to skip pruning for this type, add it to the list of types to revisit\n                if (type && skipPruning(type)) {\n                    revisit.push(typeName);\n                }\n            }\n            visited = visitQueue(revisit, prunedSchema, visited); // visit again\n        }\n        prunedTypes = [];\n        prunedSchema = mapSchema(prunedSchema, {\n            [exports.MapperKind.TYPE]: type => {\n                if (!visited.has(type.name) && !graphql.isSpecifiedScalarType(type)) {\n                    if (graphql.isUnionType(type) ||\n                        graphql.isInputObjectType(type) ||\n                        graphql.isInterfaceType(type) ||\n                        graphql.isObjectType(type) ||\n                        graphql.isScalarType(type)) {\n                        // skipUnusedTypesPruning: skip pruning unused types\n                        if (skipUnusedTypesPruning) {\n                            return type;\n                        }\n                        // skipEmptyUnionPruning: skip pruning empty unions\n                        if (graphql.isUnionType(type) && skipEmptyUnionPruning && !Object.keys(type.getTypes()).length) {\n                            return type;\n                        }\n                        if (graphql.isInputObjectType(type) || graphql.isInterfaceType(type) || graphql.isObjectType(type)) {\n                            // skipEmptyCompositeTypePruning: skip pruning object types or interfaces with no fields\n                            if (skipEmptyCompositeTypePruning && !Object.keys(type.getFields()).length) {\n                                return type;\n                            }\n                        }\n                        // skipUnimplementedInterfacesPruning: skip pruning interfaces that are not implemented by any other types\n                        if (graphql.isInterfaceType(type) && skipUnimplementedInterfacesPruning) {\n                            return type;\n                        }\n                    }\n                    prunedTypes.push(type.name);\n                    visited.delete(type.name);\n                    return null;\n                }\n                return type;\n            },\n        });\n    } while (prunedTypes.length); // Might have empty types and need to prune again\n    return prunedSchema;\n}\nfunction visitSchema(schema) {\n    const queue = []; // queue of nodes to visit\n    // Grab the root types and start there\n    for (const type of getRootTypes(schema)) {\n        queue.push(type.name);\n    }\n    return visitQueue(queue, schema);\n}\nfunction visitQueue(queue, schema, visited = new Set()) {\n    // Navigate all types starting with pre-queued types (root types)\n    while (queue.length) {\n        const typeName = queue.pop();\n        // Skip types we already visited\n        if (visited.has(typeName)) {\n            continue;\n        }\n        const type = schema.getType(typeName);\n        if (type) {\n            // Get types for union\n            if (graphql.isUnionType(type)) {\n                queue.push(...type.getTypes().map(type => type.name));\n            }\n            // If the type has files visit those field types\n            if ('getFields' in type) {\n                const fields = type.getFields();\n                const entries = Object.entries(fields);\n                if (!entries.length) {\n                    continue;\n                }\n                for (const [, field] of entries) {\n                    if (graphql.isObjectType(type)) {\n                        for (const arg of field.args) {\n                            queue.push(graphql.getNamedType(arg.type).name); // Visit arg types\n                        }\n                    }\n                    queue.push(graphql.getNamedType(field.type).name);\n                }\n            }\n            // Visit interfaces this type is implementing if they haven't been visited yet\n            if ('getInterfaces' in type) {\n                queue.push(...type.getInterfaces().map(iface => iface.name));\n            }\n            visited.add(typeName); // Mark as visited (and therefore it is used and should be kept)\n        }\n    }\n    return visited;\n}\n\nfunction mergeDeep(sources, respectPrototype = false) {\n    const target = sources[0] || {};\n    const output = {};\n    if (respectPrototype) {\n        Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));\n    }\n    for (const source of sources) {\n        if (isObject(target) && isObject(source)) {\n            if (respectPrototype) {\n                const outputPrototype = Object.getPrototypeOf(output);\n                const sourcePrototype = Object.getPrototypeOf(source);\n                if (sourcePrototype) {\n                    for (const key of Object.getOwnPropertyNames(sourcePrototype)) {\n                        const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);\n                        if (isSome(descriptor)) {\n                            Object.defineProperty(outputPrototype, key, descriptor);\n                        }\n                    }\n                }\n            }\n            for (const key in source) {\n                if (isObject(source[key])) {\n                    if (!(key in output)) {\n                        Object.assign(output, { [key]: source[key] });\n                    }\n                    else {\n                        output[key] = mergeDeep([output[key], source[key]], respectPrototype);\n                    }\n                }\n                else {\n                    Object.assign(output, { [key]: source[key] });\n                }\n            }\n        }\n    }\n    return output;\n}\nfunction isObject(item) {\n    return item && typeof item === 'object' && !Array.isArray(item);\n}\n\nfunction parseSelectionSet(selectionSet, options) {\n    const query = graphql.parse(selectionSet, options).definitions[0];\n    return query.selectionSet;\n}\n\n/**\n * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just\n * resolves aliases.\n * @param info The info argument to the resolver.\n */\nfunction getResponseKeyFromInfo(info) {\n    return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;\n}\n\nfunction appendObjectFields(schema, typeName, additionalFields) {\n    if (schema.getType(typeName) == null) {\n        return addTypes(schema, [\n            new graphql.GraphQLObjectType({\n                name: typeName,\n                fields: additionalFields,\n            }),\n        ]);\n    }\n    return mapSchema(schema, {\n        [exports.MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                const newFieldConfigMap = {};\n                for (const fieldName in originalFieldConfigMap) {\n                    newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];\n                }\n                for (const fieldName in additionalFields) {\n                    newFieldConfigMap[fieldName] = additionalFields[fieldName];\n                }\n                return correctASTNodes(new graphql.GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        },\n    });\n}\nfunction removeObjectFields(schema, typeName, testFn) {\n    const removedFields = {};\n    const newSchema = mapSchema(schema, {\n        [exports.MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                const newFieldConfigMap = {};\n                for (const fieldName in originalFieldConfigMap) {\n                    const originalFieldConfig = originalFieldConfigMap[fieldName];\n                    if (testFn(fieldName, originalFieldConfig)) {\n                        removedFields[fieldName] = originalFieldConfig;\n                    }\n                    else {\n                        newFieldConfigMap[fieldName] = originalFieldConfig;\n                    }\n                }\n                return correctASTNodes(new graphql.GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        },\n    });\n    return [newSchema, removedFields];\n}\nfunction selectObjectFields(schema, typeName, testFn) {\n    const selectedFields = {};\n    mapSchema(schema, {\n        [exports.MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                for (const fieldName in originalFieldConfigMap) {\n                    const originalFieldConfig = originalFieldConfigMap[fieldName];\n                    if (testFn(fieldName, originalFieldConfig)) {\n                        selectedFields[fieldName] = originalFieldConfig;\n                    }\n                }\n            }\n            return undefined;\n        },\n    });\n    return selectedFields;\n}\nfunction modifyObjectFields(schema, typeName, testFn, newFields) {\n    const removedFields = {};\n    const newSchema = mapSchema(schema, {\n        [exports.MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                const newFieldConfigMap = {};\n                for (const fieldName in originalFieldConfigMap) {\n                    const originalFieldConfig = originalFieldConfigMap[fieldName];\n                    if (testFn(fieldName, originalFieldConfig)) {\n                        removedFields[fieldName] = originalFieldConfig;\n                    }\n                    else {\n                        newFieldConfigMap[fieldName] = originalFieldConfig;\n                    }\n                }\n                for (const fieldName in newFields) {\n                    const fieldConfig = newFields[fieldName];\n                    newFieldConfigMap[fieldName] = fieldConfig;\n                }\n                return correctASTNodes(new graphql.GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        },\n    });\n    return [newSchema, removedFields];\n}\n\nfunction renameType(type, newTypeName) {\n    if (graphql.isObjectType(type)) {\n        return new graphql.GraphQLObjectType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (graphql.isInterfaceType(type)) {\n        return new graphql.GraphQLInterfaceType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (graphql.isUnionType(type)) {\n        return new graphql.GraphQLUnionType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (graphql.isInputObjectType(type)) {\n        return new graphql.GraphQLInputObjectType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (graphql.isEnumType(type)) {\n        return new graphql.GraphQLEnumType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (graphql.isScalarType(type)) {\n        return new graphql.GraphQLScalarType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    throw new Error(`Unknown type ${type}.`);\n}\n\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\n    let $return;\n    let abruptClose;\n    if (typeof iterator.return === 'function') {\n        $return = iterator.return;\n        abruptClose = (error) => {\n            const rethrow = () => Promise.reject(error);\n            return $return.call(iterator).then(rethrow, rethrow);\n        };\n    }\n    function mapResult(result) {\n        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n    }\n    let mapReject;\n    if (rejectCallback) {\n        // Capture rejectCallback to ensure it cannot be null.\n        const reject = rejectCallback;\n        mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);\n    }\n    return {\n        next() {\n            return iterator.next().then(mapResult, mapReject);\n        },\n        return() {\n            return $return\n                ? $return.call(iterator).then(mapResult, mapReject)\n                : Promise.resolve({ value: undefined, done: true });\n        },\n        throw(error) {\n            if (typeof iterator.throw === 'function') {\n                return iterator.throw(error).then(mapResult, mapReject);\n            }\n            return Promise.reject(error).catch(abruptClose);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\nfunction asyncMapValue(value, callback) {\n    return new Promise(resolve => resolve(callback(value)));\n}\nfunction iteratorResult(value) {\n    return { value, done: false };\n}\n\nfunction updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {\n    argumentNodes[argName] = {\n        kind: graphql.Kind.ARGUMENT,\n        name: {\n            kind: graphql.Kind.NAME,\n            value: argName,\n        },\n        value: {\n            kind: graphql.Kind.VARIABLE,\n            name: {\n                kind: graphql.Kind.NAME,\n                value: varName,\n            },\n        },\n    };\n    variableDefinitionsMap[varName] = {\n        kind: graphql.Kind.VARIABLE_DEFINITION,\n        variable: {\n            kind: graphql.Kind.VARIABLE,\n            name: {\n                kind: graphql.Kind.NAME,\n                value: varName,\n            },\n        },\n        type: astFromType(type),\n    };\n    if (value !== undefined) {\n        variableValues[varName] = value;\n        return;\n    }\n    // including the variable in the map with value of `undefined`\n    // will actually be translated by graphql-js into `null`\n    // see https://github.com/graphql/graphql-js/issues/2533\n    if (varName in variableValues) {\n        delete variableValues[varName];\n    }\n}\nfunction createVariableNameGenerator(variableDefinitionMap) {\n    let varCounter = 0;\n    return (argName) => {\n        let varName;\n        do {\n            varName = `_v${(varCounter++).toString()}_${argName}`;\n        } while (varName in variableDefinitionMap);\n        return varName;\n    };\n}\n\nfunction implementsAbstractType(schema, typeA, typeB) {\n    if (typeB == null || typeA == null) {\n        return false;\n    }\n    else if (typeA === typeB) {\n        return true;\n    }\n    else if (graphql.isCompositeType(typeA) && graphql.isCompositeType(typeB)) {\n        return graphql.doTypesOverlap(schema, typeA, typeB);\n    }\n    return false;\n}\n\nfunction relocatedError(originalError, path) {\n    return new graphql.GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path === null ? undefined : path === undefined ? originalError.path : path, originalError.originalError, originalError.extensions);\n}\n\nfunction observableToAsyncIterable(observable) {\n    const pullQueue = [];\n    const pushQueue = [];\n    let listening = true;\n    const pushValue = (value) => {\n        if (pullQueue.length !== 0) {\n            // It is safe to use the ! operator here as we check the length.\n            pullQueue.shift()({ value, done: false });\n        }\n        else {\n            pushQueue.push({ value, done: false });\n        }\n    };\n    const pushError = (error) => {\n        if (pullQueue.length !== 0) {\n            // It is safe to use the ! operator here as we check the length.\n            pullQueue.shift()({ value: { errors: [error] }, done: false });\n        }\n        else {\n            pushQueue.push({ value: { errors: [error] }, done: false });\n        }\n    };\n    const pushDone = () => {\n        if (pullQueue.length !== 0) {\n            // It is safe to use the ! operator here as we check the length.\n            pullQueue.shift()({ done: true });\n        }\n        else {\n            pushQueue.push({ done: true });\n        }\n    };\n    const pullValue = () => new Promise(resolve => {\n        if (pushQueue.length !== 0) {\n            const element = pushQueue.shift();\n            // either {value: {errors: [...]}} or {value: ...}\n            resolve(element);\n        }\n        else {\n            pullQueue.push(resolve);\n        }\n    });\n    const subscription = observable.subscribe({\n        next(value) {\n            pushValue(value);\n        },\n        error(err) {\n            pushError(err);\n        },\n        complete() {\n            pushDone();\n        },\n    });\n    const emptyQueue = () => {\n        if (listening) {\n            listening = false;\n            subscription.unsubscribe();\n            for (const resolve of pullQueue) {\n                resolve({ value: undefined, done: true });\n            }\n            pullQueue.length = 0;\n            pushQueue.length = 0;\n        }\n    };\n    return {\n        next() {\n            // return is a defined method, so it is safe to call it.\n            return listening ? pullValue() : this.return();\n        },\n        return() {\n            emptyQueue();\n            return Promise.resolve({ value: undefined, done: true });\n        },\n        throw(error) {\n            emptyQueue();\n            return Promise.reject(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\n\nfunction getOperationASTFromDocument(documentNode, operationName) {\n    const doc = graphql.getOperationAST(documentNode, operationName);\n    if (!doc) {\n        throw new Error(`Cannot infer operation ${operationName || ''}`);\n    }\n    return doc;\n}\nconst getOperationASTFromRequest = memoize1(function getOperationASTFromRequest(request) {\n    return getOperationASTFromDocument(request.document, request.operationName);\n});\n\n// Taken from GraphQL-JS v16 for backwards compat\nfunction collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n    for (const selection of selectionSet.selections) {\n        switch (selection.kind) {\n            case graphql.Kind.FIELD: {\n                if (!shouldIncludeNode(variableValues, selection)) {\n                    continue;\n                }\n                const name = getFieldEntryKey(selection);\n                const fieldList = fields.get(name);\n                if (fieldList !== undefined) {\n                    fieldList.push(selection);\n                }\n                else {\n                    fields.set(name, [selection]);\n                }\n                break;\n            }\n            case graphql.Kind.INLINE_FRAGMENT: {\n                if (!shouldIncludeNode(variableValues, selection) ||\n                    !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n                    continue;\n                }\n                collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n                break;\n            }\n            case graphql.Kind.FRAGMENT_SPREAD: {\n                const fragName = selection.name.value;\n                if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n                    continue;\n                }\n                visitedFragmentNames.add(fragName);\n                const fragment = fragments[fragName];\n                if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n                    continue;\n                }\n                collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n                break;\n            }\n        }\n    }\n    return fields;\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\nfunction shouldIncludeNode(variableValues, node) {\n    const skip = graphql.getDirectiveValues(graphql.GraphQLSkipDirective, node, variableValues);\n    if ((skip === null || skip === void 0 ? void 0 : skip['if']) === true) {\n        return false;\n    }\n    const include = graphql.getDirectiveValues(graphql.GraphQLIncludeDirective, node, variableValues);\n    if ((include === null || include === void 0 ? void 0 : include['if']) === false) {\n        return false;\n    }\n    return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n    const typeConditionNode = fragment.typeCondition;\n    if (!typeConditionNode) {\n        return true;\n    }\n    const conditionalType = graphql.typeFromAST(schema, typeConditionNode);\n    if (conditionalType === type) {\n        return true;\n    }\n    if (graphql.isAbstractType(conditionalType)) {\n        const possibleTypes = schema.getPossibleTypes(conditionalType);\n        return possibleTypes.includes(type);\n    }\n    return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\nfunction getFieldEntryKey(node) {\n    return node.alias ? node.alias.value : node.name.value;\n}\nconst collectSubFields = memoize5(function collectSubFields(schema, fragments, variableValues, type, fieldNodes) {\n    const subFieldNodes = new Map();\n    const visitedFragmentNames = new Set();\n    for (const fieldNode of fieldNodes) {\n        if (fieldNode.selectionSet) {\n            collectFields(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\n        }\n    }\n    return subFieldNodes;\n});\n\nfunction visitData(data, enter, leave) {\n    if (Array.isArray(data)) {\n        return data.map(value => visitData(value, enter, leave));\n    }\n    else if (typeof data === 'object') {\n        const newData = enter != null ? enter(data) : data;\n        if (newData != null) {\n            for (const key in newData) {\n                const value = newData[key];\n                Object.defineProperty(newData, key, {\n                    value: visitData(value, enter, leave),\n                });\n            }\n        }\n        return leave != null ? leave(newData) : newData;\n    }\n    return data;\n}\nfunction visitErrors(errors, visitor) {\n    return errors.map(error => visitor(error));\n}\nfunction visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {\n    const fragments = request.document.definitions.reduce((acc, def) => {\n        if (def.kind === graphql.Kind.FRAGMENT_DEFINITION) {\n            acc[def.name.value] = def;\n        }\n        return acc;\n    }, {});\n    const variableValues = request.variables || {};\n    const errorInfo = {\n        segmentInfoMap: new Map(),\n        unpathedErrors: new Set(),\n    };\n    const data = result.data;\n    const errors = result.errors;\n    const visitingErrors = errors != null && errorVisitorMap != null;\n    const operationDocumentNode = getOperationASTFromRequest(request);\n    if (data != null && operationDocumentNode != null) {\n        result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : undefined, errorInfo);\n    }\n    if (errors != null && errorVisitorMap) {\n        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);\n    }\n    return result;\n}\nfunction visitErrorsByType(errors, errorVisitorMap, errorInfo) {\n    const segmentInfoMap = errorInfo.segmentInfoMap;\n    const unpathedErrors = errorInfo.unpathedErrors;\n    const unpathedErrorVisitor = errorVisitorMap['__unpathed'];\n    return errors.map(originalError => {\n        const pathSegmentsInfo = segmentInfoMap.get(originalError);\n        const newError = pathSegmentsInfo == null\n            ? originalError\n            : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {\n                const typeName = segmentInfo.type.name;\n                const typeVisitorMap = errorVisitorMap[typeName];\n                if (typeVisitorMap == null) {\n                    return acc;\n                }\n                const errorVisitor = typeVisitorMap[segmentInfo.fieldName];\n                return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);\n            }, originalError);\n        if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {\n            return unpathedErrorVisitor(newError);\n        }\n        return newError;\n    });\n}\nfunction visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {\n    const operationRootType = graphql.getOperationRootType(schema, operation);\n    const collectedFields = collectFields(schema, fragments, variableValues, operationRootType, operation.selectionSet, new Map(), new Set());\n    return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);\n}\nfunction visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n    var _a;\n    const fieldMap = type.getFields();\n    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];\n    const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;\n    const newObject = enterObject != null ? enterObject(object) : object;\n    let sortedErrors;\n    let errorMap = null;\n    if (errors != null) {\n        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);\n        errorMap = sortedErrors.errorMap;\n        for (const error of sortedErrors.unpathedErrors) {\n            errorInfo.unpathedErrors.add(error);\n        }\n    }\n    for (const [responseKey, subFieldNodes] of fieldNodeMap) {\n        const fieldName = subFieldNodes[0].name.value;\n        const fieldType = fieldName === '__typename' ? graphql.TypeNameMetaFieldDef.type : (_a = fieldMap[fieldName]) === null || _a === void 0 ? void 0 : _a.type;\n        const newPathIndex = pathIndex + 1;\n        let fieldErrors;\n        if (errorMap) {\n            fieldErrors = errorMap[responseKey];\n            if (fieldErrors != null) {\n                delete errorMap[responseKey];\n            }\n            addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);\n        }\n        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);\n        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);\n    }\n    const oldTypename = newObject.__typename;\n    if (oldTypename != null) {\n        updateObject(newObject, '__typename', oldTypename, typeVisitorMap, '__typename');\n    }\n    if (errorMap) {\n        for (const errorsKey in errorMap) {\n            const errors = errorMap[errorsKey];\n            for (const error of errors) {\n                errorInfo.unpathedErrors.add(error);\n            }\n        }\n    }\n    const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;\n    return leaveObject != null ? leaveObject(newObject) : newObject;\n}\nfunction updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {\n    if (typeVisitorMap == null) {\n        object[responseKey] = newValue;\n        return;\n    }\n    const fieldVisitor = typeVisitorMap[fieldName];\n    if (fieldVisitor == null) {\n        object[responseKey] = newValue;\n        return;\n    }\n    const visitedValue = fieldVisitor(newValue);\n    if (visitedValue === undefined) {\n        delete object[responseKey];\n        return;\n    }\n    object[responseKey] = visitedValue;\n}\nfunction visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n    return list.map(listMember => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));\n}\nfunction visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {\n    if (value == null) {\n        return value;\n    }\n    const nullableType = graphql.getNullableType(returnType);\n    if (graphql.isListType(nullableType)) {\n        return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n    }\n    else if (graphql.isAbstractType(nullableType)) {\n        const finalType = schema.getType(value.__typename);\n        const collectedFields = collectSubFields(schema, fragments, variableValues, finalType, fieldNodes);\n        return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n    }\n    else if (graphql.isObjectType(nullableType)) {\n        const collectedFields = collectSubFields(schema, fragments, variableValues, nullableType, fieldNodes);\n        return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n    }\n    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];\n    if (typeVisitorMap == null) {\n        return value;\n    }\n    const visitedValue = typeVisitorMap(value);\n    return visitedValue === undefined ? value : visitedValue;\n}\nfunction sortErrorsByPathSegment(errors, pathIndex) {\n    var _a;\n    const errorMap = Object.create(null);\n    const unpathedErrors = new Set();\n    for (const error of errors) {\n        const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];\n        if (pathSegment == null) {\n            unpathedErrors.add(error);\n            continue;\n        }\n        if (pathSegment in errorMap) {\n            errorMap[pathSegment].push(error);\n        }\n        else {\n            errorMap[pathSegment] = [error];\n        }\n    }\n    return {\n        errorMap,\n        unpathedErrors,\n    };\n}\nfunction addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {\n    for (const error of errors) {\n        const segmentInfo = {\n            type,\n            fieldName,\n            pathIndex,\n        };\n        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);\n        if (pathSegmentsInfo == null) {\n            errorInfo.segmentInfoMap.set(error, [segmentInfo]);\n        }\n        else {\n            pathSegmentsInfo.push(segmentInfo);\n        }\n    }\n}\n\nfunction valueMatchesCriteria(value, criteria) {\n    if (value == null) {\n        return value === criteria;\n    }\n    else if (Array.isArray(value)) {\n        return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));\n    }\n    else if (typeof value === 'object') {\n        return (typeof criteria === 'object' &&\n            criteria &&\n            Object.keys(criteria).every(propertyName => valueMatchesCriteria(value[propertyName], criteria[propertyName])));\n    }\n    else if (criteria instanceof RegExp) {\n        return criteria.test(value);\n    }\n    return value === criteria;\n}\n\nfunction isAsyncIterable(value) {\n    return (typeof value === 'object' &&\n        value != null &&\n        Symbol.asyncIterator in value &&\n        typeof value[Symbol.asyncIterator] === 'function');\n}\n\nfunction isDocumentNode(object) {\n    return object && typeof object === 'object' && 'kind' in object && object.kind === graphql.Kind.DOCUMENT;\n}\n\nasync function defaultAsyncIteratorReturn(value) {\n    return { value, done: true };\n}\nconst proxyMethodFactory = memoize2(function proxyMethodFactory(target, targetMethod) {\n    return function proxyMethod(...args) {\n        return Reflect.apply(targetMethod, target, args);\n    };\n});\nfunction getAsyncIteratorWithCancel(asyncIterator, onCancel) {\n    return new Proxy(asyncIterator, {\n        has(asyncIterator, prop) {\n            if (prop === 'return') {\n                return true;\n            }\n            return Reflect.has(asyncIterator, prop);\n        },\n        get(asyncIterator, prop, receiver) {\n            const existingPropValue = Reflect.get(asyncIterator, prop, receiver);\n            if (prop === 'return') {\n                const existingReturn = existingPropValue || defaultAsyncIteratorReturn;\n                return async function returnWithCancel(value) {\n                    const returnValue = await onCancel(value);\n                    return Reflect.apply(existingReturn, asyncIterator, [returnValue]);\n                };\n            }\n            else if (typeof existingPropValue === 'function') {\n                return proxyMethodFactory(asyncIterator, existingPropValue);\n            }\n            return existingPropValue;\n        },\n    });\n}\nfunction getAsyncIterableWithCancel(asyncIterable, onCancel) {\n    return new Proxy(asyncIterable, {\n        get(asyncIterable, prop, receiver) {\n            const existingPropValue = Reflect.get(asyncIterable, prop, receiver);\n            if (Symbol.asyncIterator === prop) {\n                return function asyncIteratorFactory() {\n                    const asyncIterator = Reflect.apply(existingPropValue, asyncIterable, []);\n                    return getAsyncIteratorWithCancel(asyncIterator, onCancel);\n                };\n            }\n            else if (typeof existingPropValue === 'function') {\n                return proxyMethodFactory(asyncIterable, existingPropValue);\n            }\n            return existingPropValue;\n        },\n    });\n}\n\nfunction buildFixedSchema(schema, options) {\n    const document = getDocumentNodeFromSchema(schema);\n    return graphql.buildASTSchema(document, {\n        ...(options || {}),\n    });\n}\nfunction fixSchemaAst(schema, options) {\n    // eslint-disable-next-line no-undef-init\n    let schemaWithValidAst = undefined;\n    if (!schema.astNode || !schema.extensionASTNodes) {\n        schemaWithValidAst = buildFixedSchema(schema, options);\n    }\n    if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {\n        schema.astNode = schemaWithValidAst.astNode;\n    }\n    if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {\n        schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;\n    }\n    return schema;\n}\n\nexports.addTypes = addTypes;\nexports.appendObjectFields = appendObjectFields;\nexports.asArray = asArray;\nexports.assertSome = assertSome;\nexports.astFromArg = astFromArg;\nexports.astFromDirective = astFromDirective;\nexports.astFromEnumType = astFromEnumType;\nexports.astFromEnumValue = astFromEnumValue;\nexports.astFromField = astFromField;\nexports.astFromInputField = astFromInputField;\nexports.astFromInputObjectType = astFromInputObjectType;\nexports.astFromInterfaceType = astFromInterfaceType;\nexports.astFromObjectType = astFromObjectType;\nexports.astFromScalarType = astFromScalarType;\nexports.astFromSchema = astFromSchema;\nexports.astFromUnionType = astFromUnionType;\nexports.astFromValueUntyped = astFromValueUntyped;\nexports.buildOperationNodeForField = buildOperationNodeForField;\nexports.checkValidationErrors = checkValidationErrors;\nexports.collectComment = collectComment;\nexports.collectFields = collectFields;\nexports.collectSubFields = collectSubFields;\nexports.compareNodes = compareNodes;\nexports.compareStrings = compareStrings;\nexports.correctASTNodes = correctASTNodes;\nexports.createDefaultRules = createDefaultRules;\nexports.createNamedStub = createNamedStub;\nexports.createStub = createStub;\nexports.createVariableNameGenerator = createVariableNameGenerator;\nexports.dedentBlockStringValue = dedentBlockStringValue;\nexports.filterSchema = filterSchema;\nexports.fixSchemaAst = fixSchemaAst;\nexports.forEachDefaultValue = forEachDefaultValue;\nexports.forEachField = forEachField;\nexports.getArgumentValues = getArgumentValues;\nexports.getAsyncIterableWithCancel = getAsyncIterableWithCancel;\nexports.getAsyncIteratorWithCancel = getAsyncIteratorWithCancel;\nexports.getBlockStringIndentation = getBlockStringIndentation;\nexports.getBuiltInForStub = getBuiltInForStub;\nexports.getComment = getComment;\nexports.getDefinedRootType = getDefinedRootType;\nexports.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;\nexports.getDescription = getDescription;\nexports.getDirective = getDirective;\nexports.getDirectiveInExtensions = getDirectiveInExtensions;\nexports.getDirectiveNodes = getDirectiveNodes;\nexports.getDirectives = getDirectives;\nexports.getDirectivesInExtensions = getDirectivesInExtensions;\nexports.getDocumentNodeFromSchema = getDocumentNodeFromSchema;\nexports.getFieldsWithDirectives = getFieldsWithDirectives;\nexports.getImplementingTypes = getImplementingTypes;\nexports.getLeadingCommentBlock = getLeadingCommentBlock;\nexports.getOperationASTFromDocument = getOperationASTFromDocument;\nexports.getOperationASTFromRequest = getOperationASTFromRequest;\nexports.getResolversFromSchema = getResolversFromSchema;\nexports.getResponseKeyFromInfo = getResponseKeyFromInfo;\nexports.getRootTypeMap = getRootTypeMap;\nexports.getRootTypeNames = getRootTypeNames;\nexports.getRootTypes = getRootTypes;\nexports.healSchema = healSchema;\nexports.healTypes = healTypes;\nexports.implementsAbstractType = implementsAbstractType;\nexports.inspect = inspect;\nexports.isAggregateError = isAggregateError;\nexports.isAsyncIterable = isAsyncIterable;\nexports.isDescribable = isDescribable;\nexports.isDocumentNode = isDocumentNode;\nexports.isDocumentString = isDocumentString;\nexports.isNamedStub = isNamedStub;\nexports.isSome = isSome;\nexports.isValidPath = isValidPath;\nexports.makeDeprecatedDirective = makeDeprecatedDirective;\nexports.makeDirectiveNode = makeDirectiveNode;\nexports.makeDirectiveNodes = makeDirectiveNodes;\nexports.mapAsyncIterator = mapAsyncIterator;\nexports.mapSchema = mapSchema;\nexports.memoize1 = memoize1;\nexports.memoize2 = memoize2;\nexports.memoize2of4 = memoize2of4;\nexports.memoize3 = memoize3;\nexports.memoize4 = memoize4;\nexports.memoize5 = memoize5;\nexports.mergeDeep = mergeDeep;\nexports.modifyObjectFields = modifyObjectFields;\nexports.nodeToString = nodeToString;\nexports.observableToAsyncIterable = observableToAsyncIterable;\nexports.parseGraphQLJSON = parseGraphQLJSON;\nexports.parseGraphQLSDL = parseGraphQLSDL;\nexports.parseInputValue = parseInputValue;\nexports.parseInputValueLiteral = parseInputValueLiteral;\nexports.parseSelectionSet = parseSelectionSet;\nexports.printComment = printComment;\nexports.printSchemaWithDirectives = printSchemaWithDirectives;\nexports.printWithComments = printWithComments;\nexports.pruneSchema = pruneSchema;\nexports.pushComment = pushComment;\nexports.relocatedError = relocatedError;\nexports.removeObjectFields = removeObjectFields;\nexports.renameType = renameType;\nexports.resetComments = resetComments;\nexports.rewireTypes = rewireTypes;\nexports.selectObjectFields = selectObjectFields;\nexports.serializeInputValue = serializeInputValue;\nexports.transformCommentsToDescriptions = transformCommentsToDescriptions;\nexports.transformInputValue = transformInputValue;\nexports.updateArgument = updateArgument;\nexports.validateGraphQlDocuments = validateGraphQlDocuments;\nexports.valueMatchesCriteria = valueMatchesCriteria;\nexports.visitData = visitData;\nexports.visitErrors = visitErrors;\nexports.visitResult = visitResult;\nexports.withCancel = getAsyncIterableWithCancel;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}