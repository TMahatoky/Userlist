{"ast":null,"code":"var net = require('net');\n\nvar http = require('http');\n\nvar crypto = require('crypto');\n\nvar express = require('express');\n\nvar expressWs = require('express-ws');\n\nvar bodyParser = require('body-parser');\n\nfunction generateToken() {\n  return crypto.randomBytes(32).toString('hex');\n}\n\nfunction checkTo(allowed, requested) {\n  if (!(allowed instanceof Array)) {\n    allowed = [allowed];\n  } // For each rule\n\n\n  for (var i = 0; i < allowed.length; i++) {\n    var to = allowed[i];\n\n    if ((to.host == requested.host || !to.host) && (to.port == requested.port || !to.port)) {\n      if (to.blacklist) {\n        // This item is blacklisted\n        return false;\n      } else {\n        // Otheriwse, it's whitelisted\n        return true;\n      }\n    }\n  } // No rule found, access denied\n\n\n  return false;\n}\n\nmodule.exports = function (options, connectionListener) {\n  options = options || {};\n  var app = express();\n  var jsonParser = bodyParser.json();\n  var urlRoot = options.urlRoot || '/api/vm/net';\n  var server;\n\n  if (options.server) {\n    server = options.server;\n  } else {\n    server = http.createServer();\n  }\n\n  var sockets = {};\n\n  if (options.allowOrigin) {\n    var allowOrigin = options.allowOrigin;\n\n    if (typeof options.allowOrigin != 'string') {\n      allowOrigin = options.allowOrigin === true ? '*' : '';\n    }\n\n    if (allowOrigin) {\n      // Set Access-Control headers (CORS)\n      app.use(function (req, res, next) {\n        if (req.path.indexOf(urlRoot) !== 0) {\n          next();\n          return;\n        }\n\n        res.header('Access-Control-Allow-Origin', allowOrigin);\n\n        if (req.method.toUpperCase() == 'OPTIONS') {\n          // Preflighted requests\n          res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n          res.header('Access-Control-Allow-Headers', 'Content-Type');\n          res.header('Access-Control-Max-Age', 1728000); // Access-Control headers cached for 20 days\n        }\n\n        next();\n      });\n    }\n  }\n\n  app.post(urlRoot + '/connect', jsonParser, function (req, res) {\n    var host = req.body.host,\n        port = req.body.port;\n\n    if (!host || !port) {\n      res.status(400).send({\n        code: 400,\n        error: 'No host and port specified'\n      });\n      return;\n    }\n\n    if (options.to) {\n      if (!checkTo(options.to, {\n        host: host,\n        port: port\n      })) {\n        res.status(403).send({\n          code: 403,\n          error: 'Destination not allowed'\n        });\n        return;\n      }\n    }\n\n    var socket = net.connect({\n      host: host,\n      port: port\n    }, function (err) {\n      if (err) {\n        res.status(500).send({\n          code: 500,\n          error: err\n        });\n        return;\n      } // Generate a token for this connection\n\n\n      var token = generateToken();\n      sockets[token] = socket; // Remove the socket from the list when closed\n\n      socket.on('end', function () {\n        if (sockets[token]) {\n          delete sockets[token];\n        }\n      });\n      console.log('Connected to ' + req.body.host + ':' + req.body.port + ' (' + token + ')');\n      var remote = socket.address();\n      res.send({\n        token: token,\n        remote: remote\n      });\n    });\n    socket.on('error', function (err) {\n      if (res.finished) {\n        console.log(\"Socket error after response closed: \" + err);\n        return;\n      }\n\n      res.status(502).send({\n        code: 502,\n        error: 'Socket error: ' + err.code,\n        details: err\n      });\n    });\n\n    if (connectionListener) {\n      connectionListener(socket);\n    }\n  });\n  var wss = expressWs(app, server);\n  app.ws(urlRoot + '/socket', function (ws, req) {\n    var token = req.query.token;\n\n    if (!sockets[token]) {\n      console.warn('WARN: Unknown TCP connection with token \"' + token + '\"');\n      ws.close();\n      return;\n    }\n\n    var socket = sockets[token]; //delete sockets[token];\n\n    console.log('Forwarding socket with token ' + token);\n    ws.on('message', function (chunk, flags) {\n      socket.write(flags.buffer || chunk, 'binary', function () {//console.log('Sent: ', (flags.buffer || chunk).toString());\n      });\n    });\n    socket.on('data', function (chunk) {\n      //console.log('Received: ', chunk.toString());\n      // Providing a callback is important, otherwise errors can be thrown\n      ws.send(chunk, {\n        binary: true\n      }, function (err) {});\n    });\n    socket.on('end', function () {\n      console.log('TCP connection closed by remote (' + token + ')');\n      ws.close();\n    });\n    ws.on('close', function () {\n      socket.end();\n      console.log('Websocket connection closed (' + token + ')');\n    });\n  });\n  app.on('mount', function (parentApp) {\n    // @see https://github.com/strongloop/express/blob/master/lib/application.js#L615\n    parentApp.listen = function listen() {\n      server.addListener('request', this);\n      return server.listen.apply(server, arguments);\n    };\n  });\n  return app;\n};","map":{"version":3,"names":["net","require","http","crypto","express","expressWs","bodyParser","generateToken","randomBytes","toString","checkTo","allowed","requested","Array","i","length","to","host","port","blacklist","module","exports","options","connectionListener","app","jsonParser","json","urlRoot","server","createServer","sockets","allowOrigin","use","req","res","next","path","indexOf","header","method","toUpperCase","post","body","status","send","code","error","socket","connect","err","token","on","console","log","remote","address","finished","details","wss","ws","query","warn","close","chunk","flags","write","buffer","binary","end","parentApp","listen","addListener","apply","arguments"],"sources":["C:/Users/User/react-app/react-app/node_modules/net-browserify/api.js"],"sourcesContent":["var net = require('net');\nvar http = require('http');\nvar crypto = require('crypto');\nvar express = require('express');\nvar expressWs = require('express-ws');\nvar bodyParser = require('body-parser');\n\nfunction generateToken() {\n\treturn crypto.randomBytes(32).toString('hex');\n}\n\nfunction checkTo(allowed, requested) {\n\tif (!(allowed instanceof Array)) {\n\t\tallowed = [allowed];\n\t}\n\n\t// For each rule\n\tfor (var i = 0; i < allowed.length; i++) {\n\t\tvar to = allowed[i];\n\n\t\tif ((to.host == requested.host || !to.host) && (to.port == requested.port || !to.port)) {\n\t\t\tif (to.blacklist) { // This item is blacklisted\n\t\t\t\treturn false;\n\t\t\t} else { // Otheriwse, it's whitelisted\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// No rule found, access denied\n\treturn false;\n}\n\nmodule.exports = function (options, connectionListener) {\n\toptions = options || {};\n\n\tvar app = express();\n\tvar jsonParser = bodyParser.json();\n\tvar urlRoot = options.urlRoot || '/api/vm/net';\n\n\tvar server;\n\tif (options.server) {\n\t\tserver = options.server;\n\t} else {\n\t\tserver = http.createServer();\n\t}\n\n\tvar sockets = {};\n\n\tif (options.allowOrigin) {\n\t\tvar allowOrigin = options.allowOrigin;\n\t\tif (typeof options.allowOrigin != 'string') {\n\t\t\tallowOrigin = (options.allowOrigin === true) ? '*' : '';\n\t\t}\n\n\t\tif (allowOrigin) {\n\t\t\t// Set Access-Control headers (CORS)\n\t\t\tapp.use(function (req, res, next) {\n\t\t\t\tif (req.path.indexOf(urlRoot) !== 0) {\n\t\t\t\t\tnext();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tres.header('Access-Control-Allow-Origin', allowOrigin);\n\n\t\t\t\tif (req.method.toUpperCase() == 'OPTIONS') { // Preflighted requests\n\t\t\t\t\tres.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n\t\t\t\t\tres.header('Access-Control-Allow-Headers', 'Content-Type');\n\n\t\t\t\t\tres.header('Access-Control-Max-Age', 1728000); // Access-Control headers cached for 20 days\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t});\n\t\t}\n\t}\n\n\tapp.post(urlRoot + '/connect', jsonParser, function (req, res) {\n\t\tvar host = req.body.host,\n\t\t\tport = req.body.port;\n\n\t\tif (!host || !port) {\n\t\t\tres.status(400).send({\n\t\t\t\tcode: 400,\n\t\t\t\terror: 'No host and port specified'\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tif (options.to) {\n\t\t\tif (!checkTo(options.to, { host: host, port: port })) {\n\t\t\t\tres.status(403).send({\n\t\t\t\t\tcode: 403,\n\t\t\t\t\terror: 'Destination not allowed'\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tvar socket = net.connect({\n\t\t\thost: host,\n\t\t\tport: port\n\t\t}, function (err) {\n\t\t\tif (err) {\n\t\t\t\tres.status(500).send({\n\t\t\t\t\tcode: 500,\n\t\t\t\t\terror: err\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Generate a token for this connection\n\t\t\tvar token = generateToken();\n\t\t\tsockets[token] = socket;\n\n\t\t\t// Remove the socket from the list when closed\n\t\t\tsocket.on('end', function () {\n\t\t\t\tif (sockets[token]) {\n\t\t\t\t\tdelete sockets[token];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconsole.log('Connected to '+req.body.host+':'+req.body.port+' ('+token+')');\n\n\t\t\tvar remote = socket.address();\n\t\t\tres.send({\n\t\t\t\ttoken: token,\n\t\t\t\tremote: remote\n\t\t\t});\n\t\t});\n\t\tsocket.on('error', function (err) {\n\t\t\tif (res.finished) {\n\t\t\t\tconsole.log(\"Socket error after response closed: \"+err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tres.status(502).send({\n\t\t\t\tcode: 502,\n\t\t\t\terror: 'Socket error: '+err.code,\n\t\t\t\tdetails: err\n\t\t\t});\n\t\t});\n\t\tif (connectionListener) {\n\t\t\tconnectionListener(socket)\n\t\t}\n\t});\n\n\tvar wss = expressWs(app, server);\n\n\tapp.ws(urlRoot + '/socket', function (ws, req) {\n\t\tvar token = req.query.token;\n\n\t\tif (!sockets[token]) {\n\t\t\tconsole.warn('WARN: Unknown TCP connection with token \"'+token+'\"');\n\t\t\tws.close();\n\t\t\treturn;\n\t\t}\n\n\t\tvar socket = sockets[token];\n\t\t//delete sockets[token];\n\n\t\tconsole.log('Forwarding socket with token '+token);\n\n\t\tws.on('message', function (chunk, flags) {\n\t\t\tsocket.write(flags.buffer || chunk, 'binary', function () {\n\t\t\t\t//console.log('Sent: ', (flags.buffer || chunk).toString());\n\t\t\t});\n\t\t});\n\t\tsocket.on('data', function (chunk) {\n\t\t\t//console.log('Received: ', chunk.toString());\n\t\t\t// Providing a callback is important, otherwise errors can be thrown\n\t\t\tws.send(chunk, { binary: true }, function (err) {});\n\t\t});\n\t\tsocket.on('end', function () {\n\t\t\tconsole.log('TCP connection closed by remote ('+token+')');\n\t\t\tws.close();\n\t\t});\n\t\tws.on('close', function () {\n\t\t\tsocket.end();\n\t\t\tconsole.log('Websocket connection closed ('+token+')');\n\t\t});\n\t});\n\n\tapp.on('mount', function (parentApp) {\n\t\t// @see https://github.com/strongloop/express/blob/master/lib/application.js#L615\n\t\tparentApp.listen = function listen() {\n\t\t\tserver.addListener('request', this);\n\t\t\treturn server.listen.apply(server, arguments);\n\t\t};\n\t});\n\n\treturn app;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}